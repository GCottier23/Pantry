<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="color-scheme" content="dark light" />
  <title>Pantry App</title>

  <!-- Use your existing dark / modern CSS file -->
  <link rel="stylesheet" href="styles.css?v=22"/>

  <!-- PWA bits (keep for your phone shortcut) -->
<!-- iOS Home Screen Icon -->
<link rel="apple-touch-icon" sizes="180x180" href="icon-180.png">

<!-- PWA Manifest -->
<link rel="manifest" href="manifest.json">

<meta name="theme-color" content="#ff7a00">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
</head>
<body>
  <!-- TOP BAR -->
  <header class="top-bar">
    <span class="top-bar-title">Pantry App</span>
  </header>

  <!-- NAV BAR (simple, always visible) -->
  <nav
    id="app-nav"
    class="app-nav"
    role="tablist"
    aria-label="Pantry navigation"
  >
    <button
      id="nav-inventory"
      role="tab"
      aria-selected="true"
      aria-controls="page-inventory"
      type="button"
    >
      Inventory
    </button>
    <button
      id="nav-recipes"
      role="tab"
      aria-selected="false"
      aria-controls="page-recipes"
      type="button"
    >
      Recipes
    </button>
    <button
      id="nav-mealplan"
      role="tab"
      aria-selected="false"
      aria-controls="page-mealplan"
      type="button"
    >
      Meal plan
    </button>
    <button
      id="nav-shopping"
      role="tab"
      aria-selected="false"
      aria-controls="page-shopping"
      type="button"
    >
      Shopping list
    </button>
  </nav>

  <!-- PAGE 1: INVENTORY -->
  <main id="page-inventory" class="page" role="tabpanel" aria-labelledby="nav-inventory">

  <section class="panel">
  <h2>Inventory</h2>

  <button id="add-inventory-item-btn" type="button">
    + Add item
  </button>

  <div class="barcode-tools">
    <button id="fake-scan-btn" type="button" class="secondary">
      Fake barcode scan
    </button>
    <button id="real-scan-btn" type="button">
      üì∑ Scan barcode
    </button>
  </div>

  <div id="inventory-list" class="inventory-list"></div>
</section>
  </main>

  <!-- PAGE 2: RECIPES -->
  <section
    id="page-recipes"
    class="page hidden"
    role="tabpanel"
    aria-labelledby="nav-recipes"
  >
    <section class="panel">
      <h2>Recipes</h2>

        <div class="recipe-import card">
    <h2>Import from BBC Food</h2>
    <p class="help-text">
      Paste a BBC Food / BBC Good Food recipe link and tap ‚ÄúFetch image‚Äù.
    </p>
   <div class="recipe-import-row">
   <input
     type="url"
     id="recipe-import-url"
     class="text-input"
     placeholder="https://www.bbc.co.uk/food/recipes/..."
     autocomplete="off"
  />
  <button type="button" id="recipe-fetch-image" class="btn-primary">
    Fetch image
  </button>
  <button type="button" id="recipe-clear-import" class="secondary">
    Clear
  </button>
</div>
    <p id="recipe-import-status" class="import-status"></p>
    <div class="recipe-image-preview-wrapper">
      <img
        id="recipe-image-preview"
        class="recipe-image-preview"
        alt="Recipe image preview"
        style="display:none;"
      />
    </div>
  </div>

      <form id="recipe-form">
        <label>
          Recipe name
          <input id="recipe-name" type="text" required />
        </label>
        <label>
          Servings (base recipe)
          <input id="recipe-servings" type="number" value="2" min="1" required />
        </label>
        <div class="form-actions">
          <button id="start-recipe" type="button">Start new recipe</button>
          <button id="cancel-recipe-edit" type="button" class="secondary hidden">
            Cancel edit
          </button>
        </div>
      </form>

      <div id="recipe-ingredients-section" class="subpanel hidden">
        <h3>Ingredients for current recipe</h3>

        <form id="ingredient-form">
          <label>
            Ingredient name
            <input id="ing-name" type="text" required />
          </label>
          <div class="grid-2">
            <label>
              Quantity
              <input id="ing-qty" type="number" value="1" min="0" step="0.1" required />
            </label>
            <label>
              Unit
              <input id="ing-unit" type="text" placeholder="g, ml, pcs..." />
            </label>
          </div>
          <div class="form-actions">
            <button id="ingredient-submit-btn" type="submit">
              Add ingredient
            </button>
            <button id="cancel-ingredient-edit" type="button" class="secondary hidden">
              Cancel ingredient edit
            </button>
          </div>
        </form>

        <ul id="current-recipe-ingredients"></ul>

        <button id="save-recipe" type="button">Save recipe</button>

        <div class="subpanel">
          <h3>Quick import from text</h3>
          <p>
            Paste one ingredient per line, e.g.
            ‚Äú500g beef mince‚Äù or ‚Äú4 sticks celery‚Äù.
          </p>
          <label>
            Ingredients text
            <textarea
              id="import-text"
              rows="6"
              placeholder="Example:
500g beef mince
4 sticks celery
1 onion, chopped"
            ></textarea>
          </label>
          <button id="import-ingredients-btn" type="button">
            Import into current recipe
          </button>
        </div>
      </div>
    </section>

    <section class="panel">
      <h2>Saved recipes</h2>
      <p>Recipes you create here can be used on the Meal plan page.</p>
      <div id="recipes-list"></div>
    </section>
  </section>

  <!-- PAGE 3: MEAL PLAN -->
  <section
    id="page-mealplan"
    class="page hidden"
    role="tabpanel"
    aria-labelledby="nav-mealplan"
  >
    <section class="panel">
      <h2>Meal plan</h2>
      <p>Select meals for each day and how many portions you‚Äôll cook.</p>
      <div id="meal-plan-container"></div>
      <button id="generate-shopping-list" type="button">
        Generate shopping list
      </button>
    </section>
  </section>

  <!-- PAGE 4: SHOPPING LIST -->
  <section
    id="page-shopping"
    class="page hidden"
    role="tabpanel"
    aria-labelledby="nav-shopping"
  >
    <section class="panel">
      <h2>Shopping list</h2>
      <p>This list is based on your weekly meal plan and current inventory.</p>
      <table id="shopping-table">
        <thead>
          <tr>
            <th>‚úì</th>
            <th>Item</th>
            <th>To buy</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </section>
  </section>

<!-- Barcode scanner library (UMD build, exposes global ZXingBrowser) -->
<script src="https://unpkg.com/@zxing/browser@latest/umd/zxing-browser.min.js"></script>

  <!-- =============== JAVASCRIPT =============== -->
  <script>
    const WORKER_BASE = "https://icy-rain-e28c.gaz-cottier23.workers.dev";
    // ---------- UTILITIES ----------

    function titleCase(str) {
      return str
        .toLowerCase()
        .split(" ")
        .filter(Boolean)
        .map((w) => w.charAt(0).toUpperCase() + w.slice(1))
        .join(" ");
    }

    function convertToUnit(quantity, fromUnit, toUnit) {
      if (!fromUnit || !toUnit) return quantity;
      if (fromUnit === toUnit) return quantity;
      if (fromUnit === "g" && toUnit === "kg") return quantity / 1000;
      if (fromUnit === "kg" && toUnit === "g") return quantity * 1000;
      if (fromUnit === "ml" && toUnit === "l") return quantity / 1000;
      if (fromUnit === "l" && toUnit === "ml") return quantity * 1000;
      return quantity;
    }

    function normalizeInventoryItem(item) {
      if (item.unit === "g" && item.quantity >= 1000) {
        item.quantity = item.quantity / 1000;
        item.unit = "kg";
      } else if (item.unit === "ml" && item.quantity >= 1000) {
        item.quantity = item.quantity / 1000;
        item.unit = "l";
      }
    }

    function chooseBaseUnit(unit) {
      if (unit === "kg" || unit === "g") return "g";
      if (unit === "l" || unit === "ml") return "ml";
      return unit || "";
    }

    function formatQuantityWithUnit(quantity, unit) {
      if (!unit) return String(quantity);
      const compact = ["g", "kg", "ml", "l"];
      const isCompact = compact.includes(unit);
      const nStr = Number.isInteger(quantity)
        ? String(quantity)
        : quantity.toString();
      return isCompact ? nStr + unit : nStr + " " + unit.toLowerCase();
    }

    // Auto-compact g/ml to kg/l when quantity is 1000 or more
function autoCompactQuantityUnit(quantity, unit) {
  let q = quantity;
  let u = (unit || "").toLowerCase();

  if ((u === "g" || u === "ml") && q >= 1000) {
    q = q / 1000;
    u = u === "g" ? "kg" : "l";
  }

  return { quantity: q, unit: u };
}

// Ingredients that we never want in shopping lists / inventory logic
// (case-insensitive exact matches)
const ALWAYS_IN_CUPBOARD = [
  "salt",
  "fine sea salt",
  "sea salt",
  "sea salt flakes",
  "maldon sea salt flakes",
  "black pepper",
  "freshly ground black pepper",
  "pepper",
  "salt and freshly ground black pepper",
  "salt and black pepper",
  "salt & freshly ground black pepper",
  "salt & pepper"
];

// "Default" staple keywords you ship with the app.
// You can tweak these in code.
const STAPLE_KEYWORDS = [
  "salt",
  "pepper",
  "black pepper",
  "white pepper",
  "nutmeg",
  "mixed spice",
  "mixed herbs",
  "oil",
  "olive oil",
  "vegetable oil",
  "sunflower oil",
  "rapeseed oil",
  "cooking oil",
  "butter",
  "unsalted butter",
  "salted butter",
  "flour",
  "plain flour",
  "self-raising flour"
];

// User-added staples (by ingredient name, lower-cased). Persisted in localStorage.
let userStaples = [];

// True if this ingredient should be treated as a staple
function isStapleIngredient(name) {
  if (!name) return false;
  const lower = name.toLowerCase().trim();

  // 1) Exact phrase from ALWAYS_IN_CUPBOARD (your hard-coded combos)
  if (ALWAYS_IN_CUPBOARD.includes(lower)) return true;

  // 2) User-added staples (via long-press ‚Üí "Mark as staple")
  if (userStaples.includes(lower)) return true;

  // 3) Contains one of the default staple keywords
  return STAPLE_KEYWORDS.some((kw) => lower.includes(kw));
}

// Toggle user staple on/off for this device
function toggleUserStaple(name) {
  if (!name) return;
  const lower = name.toLowerCase().trim();
  if (!lower) return;

  const idx = userStaples.indexOf(lower);
  if (idx === -1) {
    userStaples.push(lower);
  } else {
    userStaples.splice(idx, 1);
  }
  saveState();
}

// Split a list into { staples, regular }, keeping the original index
function splitIngredientsByStaples(ingredients) {
  const staples = [];
  const regular = [];
  (ingredients || []).forEach((ing, index) => {
    if (!ing || !ing.name) return;
    const bucket = isStapleIngredient(ing.name) ? staples : regular;
    bucket.push({ ing, index }); // remember which ingredient it was
  });
  return { staples, regular };
}

// Merge duplicate ingredients with the same name inside a recipe.
// - Combines quantities where it's safe.
// - Special case: "Butter" ‚Äì converts tbsp ‚Üí grams (1 tbsp = 14g, 1 tsp = 5g).
function mergeDuplicateIngredientsInList(ingredients) {
  if (!Array.isArray(ingredients)) return [];

  const groups = new Map(); // name (lowercase) -> [ingredients]

  ingredients.forEach((ing) => {
    if (!ing || !ing.name) return;
    const key = ing.name.trim().toLowerCase();
    if (!groups.has(key)) groups.set(key, []);
    groups.get(key).push(ing);
  });

  const result = [];

  groups.forEach((list, key) => {
    if (list.length === 1) {
      result.push(list[0]);
      return;
    }

    const sampleName = list[0].name || "";

    const hasAnyQty = list.some(
      (ing) => ing.quantity && ing.quantity > 0
    );
    if (!hasAnyQty) {
      // All lines are effectively "no numeric quantity" ‚Üí just keep one
      result.push({
        name: titleCase(sampleName),
        quantity: null,
        unit: ""
      });
      return;
    }

    const lowerName = key;
    const isButter = lowerName.includes("butter");

    // ---- Special case: Butter -> combine everything into grams ----
    if (isButter) {
      let totalG = 0;
      let hadConvertible = false;
      let hadUnconvertible = false;

      list.forEach((ing) => {
        let q = ing.quantity || 0;
        if (!q || q <= 0) return;

        let u = (ing.unit || "").toLowerCase();
        if (u === "kg") {
          totalG += q * 1000;
          hadConvertible = true;
        } else if (u === "g" || !u) {
          totalG += q;
          hadConvertible = true;
        } else if (u === "tbsp" || u === "tablespoon" || u === "tablespoons") {
          totalG += q * 14; // 1 tbsp butter ‚âà 14g
          hadConvertible = true;
        } else if (u === "tsp" || u === "teaspoon" || u === "teaspoons") {
          totalG += q * 5; // 1 tsp butter ‚âà 5g
          hadConvertible = true;
        } else {
          hadUnconvertible = true;
        }
      });

      if (hadConvertible && totalG > 0) {
        result.push({
          name: titleCase(sampleName),
          quantity: totalG,
          unit: "g"
        });
      }

      // Any weird units we couldn‚Äôt convert stay as separate lines
      if (hadUnconvertible) {
        list.forEach((ing) => {
          let u = (ing.unit || "").toLowerCase();
          if (
            u !== "kg" &&
            u !== "g" &&
            u !== "tbsp" &&
            u !== "tablespoon" &&
            u !== "tablespoons" &&
            u !== "tsp" &&
            u !== "teaspoon" &&
            u !== "teaspoons"
          ) {
            result.push(ing);
          }
        });
      }
      return;
    }

    // ---- Generic safe merge for non-butter ingredients ----
    const units = new Set(
      list
        .filter((ing) => ing.quantity && ing.quantity > 0)
        .map((ing) => (ing.unit || "").toLowerCase())
    );
    const unitsArr = Array.from(units);

    const canMergeSameUnitOnly =
      unitsArr.length === 1 && unitsArr[0] !== "";

    const isGAndKg =
      unitsArr.length === 2 &&
      unitsArr.includes("g") &&
      unitsArr.includes("kg");

    const isMlAndL =
      unitsArr.length === 2 &&
      unitsArr.includes("ml") &&
      unitsArr.includes("l");

    if (!canMergeSameUnitOnly && !isGAndKg && !isMlAndL) {
      // Different / incompatible units ‚Äì don‚Äôt try to be clever
      list.forEach((ing) => result.push(ing));
      return;
    }

    let baseUnit = "";
    if (canMergeSameUnitOnly) baseUnit = unitsArr[0];
    else if (isGAndKg) baseUnit = "g";
    else if (isMlAndL) baseUnit = "ml";

    let totalBase = 0;

    list.forEach((ing) => {
      const q = ing.quantity || 0;
      if (!q || q <= 0) return;

      const u = (ing.unit || "").toLowerCase();
      let qBase = q;

      if (baseUnit === "g" && u === "kg") qBase = q * 1000;
      else if (baseUnit === "ml" && u === "l") qBase = q * 1000;
      else if (baseUnit === u) qBase = q;

      totalBase += qBase;
    });

    result.push({
      name: titleCase(sampleName),
      quantity: totalBase,
      unit: baseUnit
    });
  });

  return result;
}

        function tidyRecipeTitle(str) {
      if (!str) return "";
      let t = str.trim();
      // Strip trailing " - BBC Food" / " - BBC Good Food"
      t = t.replace(/\s*-\s*BBC\s*Food\s*$/i, "");
      t = t.replace(/\s*-\s*BBC\s*Good\s*Food\s*$/i, "");
      return t;
    }

    function parseServingsNumber(servingsText) {
      if (!servingsText) return null;
      // Look for the first number: "Serves 8-10" -> 8
      const m = servingsText.match(/(\d+)/);
      if (!m) return null;
      const n = parseInt(m[1], 10);
      return Number.isNaN(n) ? null : n;
    }

    // ---------- VERY SIMPLE PARSER FOR IMPORT ----------

function parseBbcIngredient(rawLine, ingredientNames) {
  const line = (rawLine || "").trim();
  if (!line) return null;

  // Normalise long-form units so we can match them
  let normLine = line
    .replace(/grams?/gi, "g")
    .replace(/millilitres?|milliliters?/gi, "ml")
    .replace(/litres?|liters?/gi, "l")
    .replace(/tablespoons?/gi, "tbsp")
    .replace(/teaspoons?/gi, "tsp");

  const lower = normLine.toLowerCase();

  // --- 1. Find the best matching ingredient name from ingredientNames ---
  let bestName = null;
  let bestIndex = -1;
  let bestLen = 0;

  (ingredientNames || []).forEach((name) => {
    const nLower = name.toLowerCase();
    const idx = lower.indexOf(nLower);
    if (idx !== -1 && nLower.length > bestLen) {
      bestName = name;
      bestIndex = idx;
      bestLen = nLower.length;
    }
  });

  // If we can‚Äôt find a clean name, fall back to the generic parser
  if (!bestName) {
    return parseIngredientLine(normLine);
  }

  const before = normLine.slice(0, bestIndex).trim(); // text before name
  const after  = normLine.slice(bestIndex + bestName.length).trim(); // text after

  let quantity = 0;
  let unit = "";

  // Only care about the *first* metric ‚Äì drop anything after a slash
  let qtyText = before;
  if (qtyText.includes("/")) {
    qtyText = qtyText.split("/")[0].trim(); // "1.2 l/2 pints" -> "1.2 l"
  }

  // --- 2. Pattern: "2 x 400g tins" -> 800 g ---
  let m = qtyText.match(
    /(\d+(?:\.\d+)?)\s*[x√ó]\s*(\d+(?:\.\d+)?)\s*(g|kg|ml|l)\b/i
  );
  if (m) {
    const count = parseFloat(m[1]);
    const size  = parseFloat(m[2]);
    let u       = m[3].toLowerCase();

    let baseQty = count * size; // e.g. 2 * 400 = 800

    if (u === "kg") {
      baseQty *= 1000;
      u = "g";
    } else if (u === "l") {
      baseQty *= 1000;
      u = "ml";
    }

    quantity = baseQty;
    unit     = u;
  } else {
    // --- 3. Metric stuck to the number, like "900g" or "150ml" ---
    let m2 = qtyText.match(/(\d+(?:\.\d+)?)(g|kg|ml|l)\b/i);
    if (m2) {
      quantity = parseFloat(m2[1]);
      unit = m2[2].toLowerCase();

      if (unit === "kg") {
        quantity *= 1000;
        unit = "g";
      } else if (unit === "l") {
        quantity *= 1000;
        unit = "ml";
      }
    } else {
      // --- 4. "number unit" with a space, like "2 tbsp" or "1.2 l" ---
      const numMatch  = qtyText.match(/(\d+(?:\.\d+)?)/);
      const unitMatch = qtyText.match(/\b(g|kg|ml|l|tsp|tbsp)\b/i);

      if (numMatch) {
        quantity = parseFloat(numMatch[1]);
      }
      if (unitMatch) {
        unit = unitMatch[1].toLowerCase();
        if (unit === "kg") {
          quantity *= 1000;
          unit = "g";
        } else if (unit === "l") {
          quantity *= 1000;
          unit = "ml";
        }
      }

      // --- 5. Wordy units like "cloves", "sticks", "tins" ---
      if (!unit && quantity > 0) {
        const unitWords = [
          "clove", "cloves",
          "stick", "sticks",
          "tin", "tins",
          "packet", "packets",
          "pack", "packs"
        ];

        if (after) {
          const firstWord = after
            .split(/[ ,()]/)
            .filter(Boolean)[0];
          if (firstWord && unitWords.includes(firstWord.toLowerCase())) {
            unit = firstWord.toLowerCase();
          }
        }
      }

      // No number at all (e.g. salt/pepper line) ‚Üí assume 1
      if (!numMatch) {
        quantity = 1;
      }
    }
  }

  return {
    name: titleCase(bestName),
    quantity,
    unit,
  };
}
    
    function parseIngredientLine(line) {
  let trimmed = line.trim();
  if (!trimmed) return null;

  // Normalise common long-form units to short ones
  let cleaned = trimmed
    .replace(/grams?/gi, "g")
    .replace(/millilitres?|milliliters?/gi, "ml")
    .replace(/litres?|liters?/gi, "l")
    .replace(/tablespoons?/gi, "tbsp")
    .replace(/teaspoons?/gi, "tsp");

  // Strip trailing notes after comma (e.g. ", sliced", ", finely chopped")
  const commaIndex = cleaned.indexOf(",");
  if (commaIndex !== -1) cleaned = cleaned.slice(0, commaIndex).trim();

  const parts = cleaned.split(/\s+/);
  if (!parts.length) return null;

  // Map lots of unit spellings ‚Üí short forms
  const unitMap = {
    g: "g",
    kg: "kg",
    ml: "ml",
    l: "l",

    tsp: "tsp",
    tbsp: "tbsp",

    pack: "pack",
    packs: "packs",

    clove: "clove",
    cloves: "cloves",

    stick: "stick",
    sticks: "sticks",
  };

  // Words we DON'T want to keep at the start of the ingredient name
  const noiseWords = new Set([
    "pint", "pints",
    "cup", "cups",
    "level", "heaped",
    "large", "small", "medium"
  ]);

  let quantity;
  let unit = "";
  let nameWords = [];

  const first = parts[0];

  // 1) Try "inline unit" in first token, e.g. "150ml", "225g"
  const inlineMatch = first.match(/^([\d.]+)([a-zA-Z]+)$/);
  if (inlineMatch) {
    quantity = parseFloat(inlineMatch[1]);
    if (isNaN(quantity) || quantity <= 0) {
      return { name: titleCase(trimmed), quantity: 1, unit: "" };
    }
    const unitRaw = inlineMatch[2].toLowerCase();
    const unitClean = unitRaw.replace(/[^a-z]/g, ""); // strip odd chars
    unit = unitMap[unitClean] || "";
    nameWords = parts.slice(1);
  } else {
    // 2) Normal case: first token is just the number, second is (maybe) the unit
    quantity = parseFloat(first);
    if (isNaN(quantity) || quantity <= 0) {
      // No leading number ‚Üí treat whole line as name
      return { name: titleCase(trimmed), quantity: 1, unit: "" };
    }

    if (parts.length === 1) {
      // Just "2" or "500" etc.
      return { name: "", quantity, unit: "" };
    }

    const secondRaw = parts[1].toLowerCase();
    const unitClean = secondRaw.replace(/[^a-z]/g, ""); // e.g. "l/2" ‚Üí "l"

    if (unitMap[unitClean]) {
      unit = unitMap[unitClean];
      nameWords = parts.slice(2);
    } else {
      unit = "";
      nameWords = parts.slice(1);
    }
  }

  // Strip leading noise words from the ingredient name
  while (nameWords.length && noiseWords.has(nameWords[0].toLowerCase())) {
    nameWords.shift();
  }

  return {
    name: titleCase(nameWords.join(" ")),
    quantity,
    unit,
  };
}

    // ---------- STATE ----------

    const STORAGE_KEY = "pantryApp_simple_v1";

    let inventory = [];
    let recipes = [];
    let mealPlan = [];
    let barcodeMap = {}; // barcode -> {name, baseQty, unit}

    let inventoryFilter = "";
    let editingInventoryKey = null;

    let currentRecipe = null;
    let editingRecipeId = null;
    let editingIngredientIndex = null;

    let lastImportedRecipeMeta = null; // { instructions: [...], sourceUrl, servingsText }

    function initDefaultMealPlan() {
      const days = [
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday",
        "Sunday",
      ];
      mealPlan = days.map((d) => ({
        dayId: d.toLowerCase(),
        dayLabel: d,
        recipeId: "",
        servings: 0,
      }));
    }

 function loadState() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) {
      initDefaultMealPlan();
      return;
    }
    const data = JSON.parse(raw);
    if (Array.isArray(data.inventory)) inventory = data.inventory;
    if (Array.isArray(data.recipes)) recipes = data.recipes;
    // Tidy up any old recipes that had duplicate ingredients
if (Array.isArray(recipes)) {
  recipes.forEach((r) => {
    if (Array.isArray(r.ingredients)) {
      r.ingredients = mergeDuplicateIngredientsInList(r.ingredients);
    }
  });
}
    if (Array.isArray(data.mealPlan)) mealPlan = data.mealPlan;

    // user staples
    if (Array.isArray(data.userStaples)) {
      userStaples = data.userStaples
        .map((n) => String(n).toLowerCase().trim())
        .filter(Boolean);
    } else {
      userStaples = [];
    }

    // --- migrate barcodeMap into the new "array of names" shape ---
    barcodeMap = {};
    if (data.barcodeMap && typeof data.barcodeMap === "object") {
      Object.keys(data.barcodeMap).forEach((code) => {
        const entry = data.barcodeMap[code];

        if (Array.isArray(entry)) {
          // already new-style
          barcodeMap[code] = entry.slice();
        } else if (entry && typeof entry === "object" && entry.name) {
          // old-style { name, baseQty, unit }
          barcodeMap[code] = [titleCase(entry.name)];
        }
        // anything else is ignored
      });
    }

    if (!mealPlan || !mealPlan.length) initDefaultMealPlan();
  } catch {
    initDefaultMealPlan();
  }
}

function saveState() {
  try {
    localStorage.setItem(
      STORAGE_KEY,
      JSON.stringify({
        inventory,
        recipes,
        mealPlan,
        barcodeMap,
        userStaples      // ‚¨ÖÔ∏è persist user staples
      })
    );
  } catch (e) {
    console.error("Failed to save", e);
  }
}

    // ---------- INVENTORY ----------

    function upsertInventoryItem(name, quantity, unit) {
      const cleanName = titleCase(name.trim());
      const key = cleanName.toLowerCase();
      let item = inventory.find((i) => i.key === key);

      if (!item) {
        item = { key, name: cleanName, quantity, unit };
        normalizeInventoryItem(item);
        inventory.push(item);
      } else {
        const baseUnit = item.unit || unit;
        const converted = convertToUnit(quantity, unit, baseUnit);
        if (!item.unit && unit) item.unit = unit;
        item.quantity += converted;
        normalizeInventoryItem(item);
      }
    }

    function setInventoryItemExact(originalKey, name, quantity, unit) {
      const cleanName = titleCase(name.trim());
      const newKey = cleanName.toLowerCase();
      let item = inventory.find((i) => i.key === originalKey);

      if (!item) {
        item = { key: newKey, name: cleanName, quantity, unit };
        normalizeInventoryItem(item);
        inventory.push(item);
      } else {
        item.name = cleanName;
        item.key = newKey;
        item.quantity = quantity;
        item.unit = unit;
        normalizeInventoryItem(item);
      }
    }

    // Deduct a quantity of an ingredient from inventory by name.
// qtyBase is in baseUnit (g/ml/whatever chooseBaseUnit returned).
function deductInventoryForCooking(name, qtyBase, baseUnit) {
  if (!name || !qtyBase || qtyBase <= 0) return;

  const key = name.toLowerCase();
  const item = inventory.find((i) => i.name.toLowerCase() === key);
  if (!item) {
    // Caller handles "not found" confirmation
    return false;
  }

  // Decide a common base unit between ingredient + inventory
  const invUnit = item.unit || "";
  const base = baseUnit || chooseBaseUnit(invUnit);

  // Current inventory in base units
  let invQtyBase = convertToUnit(item.quantity, invUnit, base);

  // Deduct
  let newBase = invQtyBase - qtyBase;
  if (newBase <= 0.0001) {
    // Effectively used it all up ‚Üí remove item
    deleteInventoryItem(item.key);
  } else {
    // Convert back into the item's original unit
    const newQty = convertToUnit(newBase, base, invUnit || "");
    item.quantity = newQty;
    normalizeInventoryItem(item);
  }

  return true;
}

    function deleteInventoryItem(key) {
      inventory = inventory.filter((i) => i.key !== key);
    }

    function renderInventoryNameSuggestions() {
      const dl = document.getElementById("inv-name-list");
      if (!dl) return;
      dl.innerHTML = "";
      inventory
        .slice()
        .sort((a, b) => a.name.localeCompare(b.name))
        .forEach((item) => {
          const opt = document.createElement("option");
          opt.value = item.name;
          dl.appendChild(opt);
        });
    }

    function renderInventory() {
      const container = document.getElementById("inventory-list");
      if (!container) return;
      container.innerHTML = "";

      const filter = (inventoryFilter || "").toLowerCase();

      inventory
        .slice()
        .sort((a, b) => a.name.localeCompare(b.name))
        .forEach((item) => {
          if (filter && !item.name.toLowerCase().includes(filter)) return;

          const row = document.createElement("div");
          row.className = "inventory-item";

          const text = document.createElement("span");
          text.className = "inventory-item-text";
          text.textContent =
            item.name +
            " - " +
            formatQuantityWithUnit(item.quantity, item.unit || "");
          row.appendChild(text);

          const actions = document.createElement("div");
          actions.className = "inventory-actions";

          const editBtn = document.createElement("button");
editBtn.type = "button";
editBtn.textContent = "‚úé";
editBtn.title = "Edit";
editBtn.addEventListener("click", () => {
  openAddInventoryItemDialog(item);
});

          const delBtn = document.createElement("button");
          delBtn.type = "button";
          delBtn.textContent = "üóë";
          delBtn.title = "Delete";
          delBtn.addEventListener("click", () => {
            if (confirm(`Delete ${item.name} from inventory?`)) {
              deleteInventoryItem(item.key);
              if (editingInventoryKey === item.key) clearInventoryEditState();
              renderInventory();
              renderInventoryNameSuggestions();
              saveState();
            }
          });

          actions.appendChild(editBtn);
          actions.appendChild(delBtn);
          row.appendChild(actions);

          container.appendChild(row);
        });
    }

    function startInventoryEdit(key) {
      const item = inventory.find((i) => i.key === key);
      if (!item) return;

      document.getElementById("inv-name").value = item.name;
      document.getElementById("inv-qty").value = item.quantity;
      document.getElementById("inv-unit").value = item.unit || "";

      document.getElementById("inventory-submit-btn").textContent =
        "Save changes";
      document
        .getElementById("inventory-cancel-edit")
        .classList.remove("hidden");
      editingInventoryKey = key;
    }

    function clearInventoryEditState() {
      document.getElementById("inv-name").value = "";
      document.getElementById("inv-qty").value = "1";
      document.getElementById("inv-unit").value = "";
      document.getElementById("inventory-submit-btn").textContent =
        "Add / Update";
      document
        .getElementById("inventory-cancel-edit")
        .classList.add("hidden");
      editingInventoryKey = null;
    }

        // ---------- BARCODE ‚Üí ITEM MAPPINGS (SIMPLE NAMES ONLY) ----------

    // barcodeMap[barcode] = ["Sausages", "Beef", ...]
  

    // Open a dialog asking:
    // 1) What is the item?
    // 2) What is the quantity?
    // 3) What is the unit?
    // It works for both new & known barcodes.
    function openBarcodeItemDialog(barcode) {
      const existing = Array.isArray(barcodeMap[barcode])
        ? Array.from(new Set(barcodeMap[barcode])) // unique
        : [];

      // Create overlay
      let overlay = document.getElementById("barcode-input-overlay");
      if (overlay) overlay.remove(); // ensure clean slate

      overlay = document.createElement("div");
      overlay.id = "barcode-input-overlay";
      overlay.className = "barcode-scanner-overlay"; // reuse same dim style

      const panel = document.createElement("div");
      panel.className = "barcode-scanner-panel";

      const title = document.createElement("h2");
      title.textContent = "Add item from barcode";
      panel.appendChild(title);

      // --- Item selection row ---
      const itemRow = document.createElement("div");
      itemRow.className = "barcode-input-row";

      const itemLabel = document.createElement("label");
      itemLabel.textContent = "What is the item?";
      itemLabel.style.display = "block";

      // We will either show a TEXT input, or a SELECT + optional TEXT
      const itemTextInput = document.createElement("input");
      itemTextInput.type = "text";
      itemTextInput.id = "barcode-item-name-input";
      itemTextInput.placeholder = "e.g. Sausages";

      const itemSelect = document.createElement("select");
      itemSelect.id = "barcode-item-select";

      const customNameInput = document.createElement("input");
      customNameInput.type = "text";
      customNameInput.id = "barcode-item-custom-name";
      customNameInput.placeholder = "Type item name‚Ä¶";
      customNameInput.style.display = "none";

      if (existing.length === 0) {
        // Brand new barcode ‚Üí just text box
        itemLabel.appendChild(itemTextInput);
      } else if (existing.length === 1) {
        // One known item ‚Üí text box prefilled
        itemTextInput.value = existing[0];
        itemLabel.appendChild(itemTextInput);
      } else {
        // Several known items ‚Üí dropdown + "Something else"
        const defaultOpt = document.createElement("option");
        defaultOpt.value = "";
        defaultOpt.textContent = "Select item‚Ä¶";
        itemSelect.appendChild(defaultOpt);

        existing.forEach((name) => {
          const opt = document.createElement("option");
          opt.value = name;
          opt.textContent = name;
          itemSelect.appendChild(opt);
        });

        const otherOpt = document.createElement("option");
        otherOpt.value = "__other";
        otherOpt.textContent = "Something else‚Ä¶";
        itemSelect.appendChild(otherOpt);

        itemSelect.addEventListener("change", () => {
          if (itemSelect.value === "__other") {
            customNameInput.style.display = "block";
            customNameInput.focus();
          } else {
            customNameInput.style.display = "none";
            customNameInput.value = "";
          }
        });

        itemLabel.appendChild(itemSelect);
        itemLabel.appendChild(customNameInput);
      }

      itemRow.appendChild(itemLabel);
      panel.appendChild(itemRow);

      // --- Quantity row ---
      const qtyRow = document.createElement("div");
      qtyRow.className = "barcode-input-row";

      const qtyLabel = document.createElement("label");
      qtyLabel.textContent = "What is the quantity?";
      qtyLabel.style.display = "block";

      const qtyInput = document.createElement("input");
      qtyInput.type = "number";
      qtyInput.min = "0";
      qtyInput.step = "0.1";
      qtyInput.value = "1";

      qtyLabel.appendChild(qtyInput);
      qtyRow.appendChild(qtyLabel);
      panel.appendChild(qtyRow);

      // --- Unit row ---
      const unitRow = document.createElement("div");
      unitRow.className = "barcode-input-row";

      const unitLabel = document.createElement("label");
      unitLabel.textContent = "What is the unit?";
      unitLabel.style.display = "block";

      const unitSelect = document.createElement("select");
      const units = [
        { value: "", label: "(none)" },
        { value: "g", label: "g" },
        { value: "kg", label: "kg" },
        { value: "ml", label: "ml" },
        { value: "l", label: "l" },
        { value: "pack", label: "pack" },
        { value: "packs", label: "packs" },
        { value: "pcs", label: "pcs" },
      ];
      units.forEach((u) => {
        const opt = document.createElement("option");
        opt.value = u.value;
        opt.textContent = u.label;
        unitSelect.appendChild(opt);
      });

      unitLabel.appendChild(unitSelect);
      unitRow.appendChild(unitLabel);
      panel.appendChild(unitRow);

      // --- Buttons ---
      const btnRow = document.createElement("div");
      btnRow.className = "barcode-scanner-actions";

      const cancelBtn = document.createElement("button");
      cancelBtn.type = "button";
      cancelBtn.textContent = "Cancel";
      cancelBtn.className = "secondary";
      cancelBtn.addEventListener("click", () => {
        overlay.remove();
      });

      const addBtn = document.createElement("button");
      addBtn.type = "button";
      addBtn.textContent = "Add to inventory";

        addBtn.addEventListener("click", () => {
        let name = "";

        if (existing.length >= 2) {
          const sel = itemSelect.value;
          if (sel === "__other") {
            name = customNameInput.value.trim();
          } else {
            name = sel.trim();
          }
        } else {
          name = itemTextInput.value.trim();
        }

        const qty = parseFloat(qtyInput.value || "0");
        const unit = unitSelect.value || "";

        if (!name) {
          alert("Please enter an item name.");
          return;
        }
        if (!qty || qty <= 0 || Number.isNaN(qty)) {
          alert("Please enter a valid quantity.");
          return;
        }

        const cleanName = titleCase(name);

        // ---- SAFE barcodeMap update (handles old shapes) ----
        let existingEntry = barcodeMap[barcode];
        let names = [];

        if (Array.isArray(existingEntry)) {
          names = existingEntry.slice();
        } else if (
          existingEntry &&
          typeof existingEntry === "object" &&
          existingEntry.name
        ) {
          // migrate one last time if somehow still old style
          names = [titleCase(existingEntry.name)];
        }

        if (!names.includes(cleanName)) {
          names.push(cleanName);
        }
        barcodeMap[barcode] = names;
        // ---- end barcodeMap update ----

        // Add to inventory
        upsertInventoryItem(cleanName, qty, unit);
        renderInventory();
        renderInventoryNameSuggestions();
        saveState();

        overlay.remove();
        alert(
          "Added " + formatQuantityWithUnit(qty, unit || "") + " of " + cleanName
        );
      });

      btnRow.appendChild(cancelBtn);
      btnRow.appendChild(addBtn);
      panel.appendChild(btnRow);

      overlay.appendChild(panel);

      overlay.addEventListener("click", (e) => {
        if (e.target === overlay) overlay.remove();
      });

      document.body.appendChild(overlay);

      // Focus first sensible field
      if (existing.length >= 2) {
        itemSelect.focus();
      } else {
        itemTextInput.focus();
      }
    }
    
    // Simple popup to add OR edit an inventory item (no barcode)
function openAddInventoryItemDialog(existingItem) {
  const isEdit = !!existingItem;

  // Create overlay
  let overlay = document.getElementById("inventory-item-overlay");
  if (overlay) overlay.remove();

  overlay = document.createElement("div");
  overlay.id = "inventory-item-overlay";
  overlay.className = "barcode-scanner-overlay"; // reuse same dim style

  const panel = document.createElement("div");
  panel.className = "barcode-scanner-panel";

  const title = document.createElement("h2");
  title.textContent = isEdit ? "Edit inventory item" : "Add inventory item";
  panel.appendChild(title);

  // Item name
  const itemRow = document.createElement("div");
  itemRow.className = "barcode-input-row";

  const itemLabel = document.createElement("label");
  itemLabel.textContent = "What is the item?";
  itemLabel.style.display = "block";

  const itemInput = document.createElement("input");
  itemInput.type = "text";
  itemInput.required = true;
  itemInput.placeholder = "e.g. Sausages";

  itemLabel.appendChild(itemInput);
  itemRow.appendChild(itemLabel);
  panel.appendChild(itemRow);

  // Quantity
  const qtyRow = document.createElement("div");
  qtyRow.className = "barcode-input-row";

  const qtyLabel = document.createElement("label");
  qtyLabel.textContent = "What is the quantity?";
  qtyLabel.style.display = "block";

  const qtyInput = document.createElement("input");
  qtyInput.type = "number";
  qtyInput.min = "0";
  qtyInput.step = "0.1";
  qtyInput.value = "1";

  qtyLabel.appendChild(qtyInput);
  qtyRow.appendChild(qtyLabel);
  panel.appendChild(qtyRow);

  // Unit
  const unitRow = document.createElement("div");
  unitRow.className = "barcode-input-row";

  const unitLabel = document.createElement("label");
  unitLabel.textContent = "What is the unit?";
  unitLabel.style.display = "block";

  const unitSelect = document.createElement("select");
  const units = [
    { value: "", label: "(none)" },
    { value: "g", label: "g" },
    { value: "kg", label: "kg" },
    { value: "ml", label: "ml" },
    { value: "l", label: "l" },
    { value: "pack", label: "pack" },
    { value: "packs", label: "packs" },
    { value: "pcs", label: "pcs" },
  ];
  units.forEach((u) => {
    const opt = document.createElement("option");
    opt.value = u.value;
    opt.textContent = u.label;
    unitSelect.appendChild(opt);
  });

  unitLabel.appendChild(unitSelect);
  unitRow.appendChild(unitLabel);
  panel.appendChild(unitRow);

  // If we're editing, pre-fill the fields
  if (isEdit) {
    itemInput.value = existingItem.name || "";
    qtyInput.value =
      typeof existingItem.quantity === "number"
        ? existingItem.quantity
        : "1";
    unitSelect.value = existingItem.unit || "";
  }

  // Buttons
  const btnRow = document.createElement("div");
  btnRow.className = "barcode-scanner-actions";

  const cancelBtn = document.createElement("button");
  cancelBtn.type = "button";
  cancelBtn.textContent = "Cancel";
  cancelBtn.className = "secondary";
  cancelBtn.addEventListener("click", () => overlay.remove());

  const saveBtn = document.createElement("button");
  saveBtn.type = "button";
  saveBtn.textContent = isEdit ? "Save" : "Add to inventory";

  saveBtn.addEventListener("click", () => {
    const name = itemInput.value.trim();
    const qty = parseFloat(qtyInput.value || "0");
    const unit = unitSelect.value || "";

    if (!name) {
      alert("Please enter an item name.");
      return;
    }
    if (!qty || qty <= 0 || Number.isNaN(qty)) {
      alert("Please enter a valid quantity.");
      return;
    }

    if (isEdit && existingItem && existingItem.key) {
      // exact edit
      setInventoryItemExact(existingItem.key, name, qty, unit);
    } else {
      // normal add
      upsertInventoryItem(name, qty, unit);
    }

    renderInventory();
    renderInventoryNameSuggestions();
    saveState();
    overlay.remove();
  });

  btnRow.appendChild(cancelBtn);
  btnRow.appendChild(saveBtn);
  panel.appendChild(btnRow);

  overlay.appendChild(panel);

  // Tap outside to close
  overlay.addEventListener("click", (e) => {
    if (e.target === overlay) overlay.remove();
  });

  document.body.appendChild(overlay);
  itemInput.focus();
}

    // For real barcode scans
    function handleBarcodeCode(code) {
      if (!code) return;
      code = String(code).trim();
      if (!code) return;

      openBarcodeItemDialog(code);
    }

    // For the fake scan button
    function handleFakeBarcodeScan() {
      let code = prompt("Fake barcode scan: enter a code.", "");
      if (!code) return;
      handleBarcodeCode(code);
    }

    // ---------- RECIPES ----------

function renderCurrentRecipeIngredients() {
  const ul = document.getElementById("current-recipe-ingredients");
  if (!ul) return;
  ul.innerHTML = "";

  if (!currentRecipe || !Array.isArray(currentRecipe.ingredients)) return;

  currentRecipe.ingredients.forEach((ing, index) => {
    const li = document.createElement("li");

    const textSpan = document.createElement("span");
    let label = ing.name || "";

    let q = ing.quantity;
    let u = ing.unit || "";

    // auto-compact to kg/l where appropriate
    if (q && q > 0) {
      ({ quantity: q, unit: u } = autoCompactQuantityUnit(q, u));

      const compactUnits = ["g", "kg", "ml", "l"];
      const unitLower = (u || "").toLowerCase();

      if (compactUnits.includes(unitLower)) {
        label += `: ${q}${unitLower}`;
      } else if (unitLower) {
        label += `: ${q} ${unitLower}`;
      } else {
        label += `: ${q}`;
      }
    }

    textSpan.textContent = label;
    li.appendChild(textSpan);

    const actions = document.createElement("div");
    actions.className = "table-actions";

    const editBtn = document.createElement("button");
    editBtn.type = "button";
    editBtn.className = "secondary";
    editBtn.textContent = "Edit";
    editBtn.addEventListener("click", () => startIngredientEdit(index));

    const delBtn = document.createElement("button");
    delBtn.type = "button";
    delBtn.className = "secondary";
    delBtn.textContent = "Delete";
    delBtn.addEventListener("click", () => {
      currentRecipe.ingredients.splice(index, 1);
      renderCurrentRecipeIngredients();
    });

    actions.appendChild(editBtn);
    actions.appendChild(delBtn);
    li.appendChild(actions);
    ul.appendChild(li);
  });
}

    function startIngredientEdit(index) {
      if (!currentRecipe || !currentRecipe.ingredients[index]) return;
      const ing = currentRecipe.ingredients[index];

      document.getElementById("ing-name").value = ing.name;
      document.getElementById("ing-qty").value = ing.quantity;
      document.getElementById("ing-unit").value = ing.unit;

      document.getElementById("ingredient-submit-btn").textContent =
        "Save ingredient";
      document
        .getElementById("cancel-ingredient-edit")
        .classList.remove("hidden");
      editingIngredientIndex = index;
    }

    function clearIngredientEditState() {
      document.getElementById("ing-name").value = "";
      document.getElementById("ing-qty").value = "1";
      document.getElementById("ing-unit").value = "";
      document.getElementById("ingredient-submit-btn").textContent =
        "Add ingredient";
      document
        .getElementById("cancel-ingredient-edit")
        .classList.add("hidden");
      editingIngredientIndex = null;
    }

    function clearRecipeEditState() {
      editingRecipeId = null;
      currentRecipe = null;
      document.getElementById("recipe-name").value = "";
      document.getElementById("recipe-servings").value = "2";
      document.getElementById("current-recipe-ingredients").innerHTML = "";
      document
        .getElementById("recipe-ingredients-section")
        .classList.add("hidden");
      document
        .getElementById("cancel-recipe-edit")
        .classList.add("hidden");
      clearIngredientEditState();
    }

        function renderRecipesList() {
  const container = document.getElementById("recipes-list");
  if (!container) return;
  container.innerHTML = "";

  if (!recipes.length) {
    container.textContent = "No recipes saved yet.";
    return;
  }

  const grid = document.createElement("div");
  grid.className = "recipe-grid";

  recipes.forEach((r) => {
    const card = document.createElement("article");
    card.className = "recipe-card";
    card.dataset.recipeId = r.id;

      // Thumbnail
    const thumb = document.createElement("div");
    thumb.className = "recipe-card-thumb";
    if (r.imageUrl) {
      const img = document.createElement("img");
      img.src = r.imageUrl;
      img.alt = r.name;
      thumb.appendChild(img);
    } else {
      const placeholder = document.createElement("div");
      placeholder.className = "recipe-card-placeholder";
      placeholder.textContent = (r.name || "R")
        .charAt(0)
        .toUpperCase();
      thumb.appendChild(placeholder);
    }

    // NEW: clicking the image/placeholder opens the detail view
    thumb.style.cursor = "pointer";
    thumb.addEventListener("click", () => openRecipeDetail(r.id));

    card.appendChild(thumb);

    // Body
    const body = document.createElement("div");
    body.className = "recipe-card-body";

    const title = document.createElement("h3");
    title.className = "recipe-card-title";
    title.textContent = r.name;
    body.appendChild(title);

    const meta = document.createElement("p");
    meta.className = "recipe-card-meta";
    meta.textContent = r.servings
      ? `Serves ${r.servings}`
      : "Servings not set";
    body.appendChild(meta);

    card.appendChild(body);

    // Footer buttons (Edit + Delete only)
    const footer = document.createElement("div");
    footer.className = "recipe-card-footer";

    const editBtn = document.createElement("button");
editBtn.type = "button";
editBtn.className = "secondary";
editBtn.textContent = "Edit";
editBtn.addEventListener("click", () => {
  openRecipeQuickEditDialog(r.id);
});

    const delBtn = document.createElement("button");
    delBtn.type = "button";
    delBtn.className = "secondary";
    delBtn.textContent = "Delete";
    delBtn.addEventListener("click", () => {
      if (confirm(`Delete recipe "${r.name}"?`)) {
        recipes = recipes.filter((x) => x.id !== r.id);
        mealPlan.forEach((entry) => {
          if (entry.recipeId === r.id) {
            entry.recipeId = "";
            entry.servings = 0;
          }
        });
        renderRecipesList();
        renderMealPlan();
        saveState();
      }
    });

    footer.appendChild(editBtn);
    footer.appendChild(delBtn);
    card.appendChild(footer);

    grid.appendChild(card);
  });

  container.appendChild(grid);

  // keep meal plan dropdowns in sync
  renderMealPlan();
}

function openRecipeQuickEditDialog(recipeId) {
  const recipe = recipes.find((r) => r.id === recipeId);
  if (!recipe) {
    alert("Recipe not found.");
    return;
  }
  if (!Array.isArray(recipe.ingredients) || !recipe.ingredients.length) {
    alert("This recipe has no ingredients to edit yet.");
    return;
  }

  // Remove any existing overlay
  let overlay = document.getElementById("recipe-quick-edit-overlay");
  if (overlay) overlay.remove();

  overlay = document.createElement("div");
  overlay.id = "recipe-quick-edit-overlay";
  // Re-use the same dim background style as the barcode dialog
  overlay.className = "barcode-scanner-overlay";

  const panel = document.createElement("div");
  // Re-use the same panel style as the barcode dialog
  panel.className = "barcode-scanner-panel";

  const title = document.createElement("h2");
  title.textContent = `Edit "${recipe.name}"`;
  panel.appendChild(title);

  // ---------- Ingredient selector ----------
  const ingRow = document.createElement("div");
  ingRow.className = "barcode-input-row";

  const ingLabel = document.createElement("label");
  ingLabel.textContent = "What is the item?";
  ingLabel.style.display = "block";

  const ingSelect = document.createElement("select");
  ingSelect.id = "recipe-quick-edit-select";

  const defaultOpt = document.createElement("option");
  defaultOpt.value = "";
  defaultOpt.textContent = "Select ingredient‚Ä¶";
  ingSelect.appendChild(defaultOpt);

  // Helper to build a small label like "Butter: 50g"
  const makeIngLabel = (ing) => {
    let label = ing.name || "Ingredient";
    let q = ing.quantity;
    let u = ing.unit || "";

    if (q && q > 0) {
      ({ quantity: q, unit: u } = autoCompactQuantityUnit(q, u));
      const compactUnits = ["g", "kg", "ml", "l"];
      const nice = Number.isInteger(q)
        ? String(q)
        : (Math.round(q * 10) / 10).toString();

      if (!u) {
        label += `: ${nice}`;
      } else if (compactUnits.includes(u)) {
        label += `: ${nice}${u}`;
      } else {
        label += `: ${nice} ${u}`;
      }
    }
    return label;
  };

  recipe.ingredients.forEach((ing, index) => {
    const opt = document.createElement("option");
    opt.value = String(index);
    opt.textContent = makeIngLabel(ing);
    ingSelect.appendChild(opt);
  });

  ingLabel.appendChild(ingSelect);
  ingRow.appendChild(ingLabel);
  panel.appendChild(ingRow);

  // ---------- Quantity field ----------
  const qtyRow = document.createElement("div");
  qtyRow.className = "barcode-input-row";

  const qtyLabel = document.createElement("label");
  qtyLabel.textContent = "What is the quantity?";
  qtyLabel.style.display = "block";

  const qtyInput = document.createElement("input");
  qtyInput.type = "number";
  qtyInput.min = "0";
  qtyInput.step = "0.1";
  qtyInput.value = "1";

  qtyLabel.appendChild(qtyInput);
  qtyRow.appendChild(qtyLabel);
  panel.appendChild(qtyRow);

  // ---------- Unit field ----------
  const unitRow = document.createElement("div");
  unitRow.className = "barcode-input-row";

  const unitLabel = document.createElement("label");
  unitLabel.textContent = "What is the unit?";
  unitLabel.style.display = "block";

  const unitSelect = document.createElement("select");

  const unitOptions = [
    { value: "", label: "(none)" },
    { value: "g", label: "g" },
    { value: "kg", label: "kg" },
    { value: "ml", label: "ml" },
    { value: "l", label: "l" },
    { value: "tsp", label: "tsp" },
    { value: "tbsp", label: "tbsp" },
    { value: "pack", label: "pack" },
    { value: "packs", label: "packs" },
    { value: "pcs", label: "pcs" },
    { value: "clove", label: "clove" },
    { value: "cloves", label: "cloves" },
    { value: "stick", label: "stick" },
    { value: "sticks", label: "sticks" },
  ];

  unitOptions.forEach((u) => {
    const opt = document.createElement("option");
    opt.value = u.value;
    opt.textContent = u.label;
    unitSelect.appendChild(opt);
  });

  unitLabel.appendChild(unitSelect);
  unitRow.appendChild(unitLabel);
  panel.appendChild(unitRow);

  // When an ingredient is chosen, populate qty + unit
  function populateFieldsFromIngredient(index) {
    const ing = recipe.ingredients[index];
    if (!ing) return;

    // quantity
    if (typeof ing.quantity === "number" && !Number.isNaN(ing.quantity)) {
      qtyInput.value = String(ing.quantity);
    } else {
      qtyInput.value = "1";
    }

    // unit
    const u = (ing.unit || "").toLowerCase();
    // if it's not one of our known options, add it so it can still be selected
    if (
      u &&
      !Array.from(unitSelect.options).some(
        (opt) => opt.value.toLowerCase() === u
      )
    ) {
      const extraOpt = document.createElement("option");
      extraOpt.value = u;
      extraOpt.textContent = u;
      unitSelect.appendChild(extraOpt);
    }
    unitSelect.value = u;
  }

  ingSelect.addEventListener("change", () => {
    const idx = parseInt(ingSelect.value, 10);
    if (!Number.isNaN(idx)) {
      populateFieldsFromIngredient(idx);
    }
  });

  // Auto-select the first real ingredient to make it feel snappy
  if (recipe.ingredients.length > 0) {
    ingSelect.value = "0";
    populateFieldsFromIngredient(0);
  }

  // ---------- Buttons ----------
  const btnRow = document.createElement("div");
  btnRow.className = "barcode-scanner-actions";

  const cancelBtn = document.createElement("button");
  cancelBtn.type = "button";
  cancelBtn.textContent = "Cancel";
  cancelBtn.className = "secondary";
  cancelBtn.addEventListener("click", () => overlay.remove());

  const saveBtn = document.createElement("button");
  saveBtn.type = "button";
  saveBtn.textContent = "Save changes";

  saveBtn.addEventListener("click", () => {
    const idx = parseInt(ingSelect.value, 10);
    if (Number.isNaN(idx) || !recipe.ingredients[idx]) {
      alert("Please choose an ingredient first.");
      return;
    }

    const newQty = parseFloat(qtyInput.value || "0");
    if (!newQty || newQty <= 0 || Number.isNaN(newQty)) {
      alert("Please enter a valid quantity.");
      return;
    }

    const newUnit = unitSelect.value || "";

    // Actually update the recipe‚Äôs ingredient
    recipe.ingredients[idx].quantity = newQty;
    recipe.ingredients[idx].unit = newUnit;

    saveState();
    renderRecipesList(); // refresh the cards so the "Serves" etc stay in sync
    overlay.remove();
  });

  btnRow.appendChild(cancelBtn);
  btnRow.appendChild(saveBtn);
  panel.appendChild(btnRow);

  overlay.appendChild(panel);

  // Click outside to close
  overlay.addEventListener("click", (e) => {
    if (e.target === overlay) overlay.remove();
  });

  document.body.appendChild(overlay);
}

// Simple long-press helper
function attachIngredientLongPress(li, recipeId, ingredientIndex, ingredientName) {
  let pressTimer = null;

  // ‚ùå Stop the browser selecting text on long-press
  li.style.userSelect = "none";
  li.style.webkitUserSelect = "none";

  const start = (event) => {
    event.preventDefault();
    if (pressTimer !== null) return;

    pressTimer = setTimeout(() => {
      pressTimer = null;
      openIngredientContextMenu(recipeId, ingredientIndex, ingredientName);
    }, 450); // ~0.45s long press
  };

  const cancel = () => {
    if (pressTimer !== null) {
      clearTimeout(pressTimer);
      pressTimer = null;
    }
  };

  li.addEventListener("pointerdown", start);
  li.addEventListener("pointerup", cancel);
  li.addEventListener("pointerleave", cancel);
  li.addEventListener("pointercancel", cancel);
}

// Small popup for "Staple / Edit / Delete"
function openIngredientContextMenu(recipeId, ingredientIndex, ingredientName) {
  const recipe = recipes.find((r) => r.id === recipeId);
  if (!recipe) return;

  const overlay = document.createElement("div");
  overlay.className = "recipe-detail-overlay"; // reuse dim background

  const panel = document.createElement("div");
  panel.className = "recipe-detail-panel";
  panel.style.maxWidth = "320px";

  const title = document.createElement("h3");
  title.textContent = ingredientName;
  panel.appendChild(title);

  // --- Staple toggle button ---
  const stapleBtn = document.createElement("button");
  stapleBtn.type = "button";

  const currentlyStaple = isStapleIngredient(ingredientName);
  stapleBtn.textContent = currentlyStaple
    ? "Remove from staples"
    : "Mark as staple";

  stapleBtn.addEventListener("click", () => {
    toggleUserStaple(ingredientName);
    overlay.remove();
    // Re-open the detail view so the ingredient jumps into / out of the staples section
    openRecipeDetail(recipeId);
  });

  // --- Edit ingredient button ---
  const editBtn = document.createElement("button");
  editBtn.type = "button";
  editBtn.className = "secondary";
  editBtn.textContent = "Edit ingredient";
  editBtn.addEventListener("click", () => {
    overlay.remove();
    showPage("page-recipes");
    startRecipeEdit(recipeId, ingredientIndex); // jump straight to that ingredient
  });

  // --- Delete ingredient button ---
  const deleteBtn = document.createElement("button");
  deleteBtn.type = "button";
  deleteBtn.className = "secondary";
  deleteBtn.textContent = "Delete ingredient";
  deleteBtn.addEventListener("click", () => {
    const ok = confirm(`Remove "${ingredientName}" from this recipe?`);
    if (!ok) return;

    if (
      Array.isArray(recipe.ingredients) &&
      ingredientIndex >= 0 &&
      ingredientIndex < recipe.ingredients.length
    ) {
      recipe.ingredients.splice(ingredientIndex, 1);
      saveState();
    }
    overlay.remove();
    openRecipeDetail(recipeId);
  });

  // --- Cancel button ---
  const closeBtn = document.createElement("button");
  closeBtn.type = "button";
  closeBtn.className = "secondary";
  closeBtn.textContent = "Cancel";
  closeBtn.addEventListener("click", () => overlay.remove());

  panel.appendChild(stapleBtn);
  panel.appendChild(editBtn);
  panel.appendChild(deleteBtn);
  panel.appendChild(closeBtn);

  overlay.appendChild(panel);

  // Close if you tap outside the panel
  overlay.addEventListener("click", (e) => {
    if (e.target === overlay) overlay.remove();
  });

  document.body.appendChild(overlay);
}

function openRecipeDetail(recipeId) {
  const recipe = recipes.find((r) => r.id === recipeId);
  if (!recipe) return;

  const recipeIdActual = recipe.id;

  // Work on a copy so we don't mutate the underlying recipe
  const ingForDisplay = (recipe.ingredients || []).slice();

  // If any ingredient mentions black pepper but none mentions salt,
  // add a synthetic "Salt" line (staple, shown as "to taste").
  const hasBlackPepper = ingForDisplay.some(
    (ing) => ing.name && ing.name.toLowerCase().includes("black pepper")
  );
  const hasAnySalt = ingForDisplay.some(
    (ing) => ing.name && ing.name.toLowerCase().includes("salt")
  );

  if (hasBlackPepper && !hasAnySalt) {
    ingForDisplay.push({
      name: "Salt",
      quantity: null,
      unit: ""
    });
  }

  const overlay = document.createElement("div");
  overlay.className = "recipe-detail-overlay";

  const panel = document.createElement("div");
  panel.className = "recipe-detail-panel";

  // Close button
  const closeBtn = document.createElement("button");
  closeBtn.type = "button";
  closeBtn.className = "recipe-detail-close";
  closeBtn.textContent = "Close";
  closeBtn.addEventListener("click", () => overlay.remove());
  panel.appendChild(closeBtn);

  // Title
  const title = document.createElement("h2");
  title.className = "recipe-detail-title";
  title.textContent = recipe.name;
  panel.appendChild(title);

  // Image
  if (recipe.imageUrl) {
    const imgWrap = document.createElement("div");
    imgWrap.className = "recipe-detail-image-wrap";
    const img = document.createElement("img");
    img.src = recipe.imageUrl;
    img.alt = recipe.name;
    imgWrap.appendChild(img);
    panel.appendChild(imgWrap);
  }

  // Meta
  const meta = document.createElement("p");
  meta.className = "recipe-detail-meta";
  meta.textContent = recipe.servings ? `Serves ${recipe.servings}` : "";
  panel.appendChild(meta);

  // ---- Ingredients section ----
  const ingTitle = document.createElement("h3");
  ingTitle.textContent = "Ingredients";
  panel.appendChild(ingTitle);

  // Use the indexed split so we know which ingredient to edit/delete
  const split = splitIngredientsByStaples(ingForDisplay);
  let staples = split.staples;
  const regular = split.regular;

  // --- SPECIAL CASE: merge salt/pepper "to taste" into one line ---
  // We only merge when there is NO real quantity/unit
  // (so things like "2 tbsp black peppercorns" are left alone).
  let mergedStaples = [];
  let saltPepperAdded = false;

  staples.forEach(({ ing, index }) => {
    const nameLower = (ing.name || "").toLowerCase();
    const hasSalt = nameLower.includes("salt");
    const hasPepper = nameLower.includes("pepper");

    const noRealQty =
      (!ing.unit || !ing.unit.trim()) &&
      (!ing.quantity || ing.quantity === 1);

    const isSaltPepperLine = hasSalt && hasPepper && noRealQty;
    const isSaltOnlyLine = hasSalt && !hasPepper && noRealQty;
    const isPepperOnlyLine = hasPepper && !hasSalt && noRealQty;

    const candidate =
      isSaltPepperLine || isSaltOnlyLine || isPepperOnlyLine;

    if (candidate) {
      if (!saltPepperAdded) {
        mergedStaples.push({
          ing: { name: "Salt and Pepper", quantity: null, unit: "" },
          index: -1
        });
        saltPepperAdded = true;
      }
      // Skip the original salt/pepper lines
      return;
    }

    mergedStaples.push({ ing, index });
  });

  staples = mergedStaples;

  function addIngredientLi(ul, obj, isStapleList) {
    const { ing, index } = obj;
    const li = document.createElement("li");

    const nameSpan = document.createElement("span");
    nameSpan.textContent = ing.name || "";
    li.appendChild(nameSpan);

    let q = ing.quantity;
    let u = ing.unit || "";
    const nameLower = (ing.name || "").toLowerCase();

    // --- SPECIAL CASE: nutmeg "pinch" ---
    // If it's nutmeg, no unit, and quantity is the default 1,
    // treat it as "pinch" instead of "1".
    const isNutmegFallback =
      nameLower.includes("nutmeg") &&
      (!u || !u.trim()) &&
      (q === 1 || !q);

    const hasNumericQty = q && q > 0 && !isNutmegFallback;

    if (hasNumericQty) {
      ({ quantity: q, unit: u } = autoCompactQuantityUnit(q, u));

      const compactUnits = ["g", "kg", "ml", "l"];
      const unitLower = (u || "").toLowerCase();
      const qtySpan = document.createElement("span");

      let label = ": ";
      if (compactUnits.includes(unitLower)) {
        label += `${q}${unitLower}`;
      } else if (unitLower) {
        label += `${q} ${unitLower}`;
      } else {
        label += `${q}`;
      }

      qtySpan.textContent = label;
      li.appendChild(qtySpan);
    } else if (isNutmegFallback || isStapleList) {
      // For nutmeg fallback ‚Üí "pinch"
      // For staple ingredients with no usable quantity ‚Üí "to taste"
      const sep = document.createTextNode(": ");
      const em = document.createElement("em");
      em.textContent = isNutmegFallback ? "pinch" : "to taste";
      li.appendChild(sep);
      li.appendChild(em);
    }

    // Attach long-press menu (Staple / Edit / Delete)
    attachIngredientLongPress(li, recipeIdActual, index, ing.name);

    ul.appendChild(li);
  }

  // Non-staple ingredients
  const ingList = document.createElement("ul");
  ingList.className = "recipe-detail-ingredients";
  regular.forEach((obj) => addIngredientLi(ingList, obj, false));
  panel.appendChild(ingList);

  // Staples: "Make sure you have" (italic heading)
  if (staples.length) {
    const staplesTitle = document.createElement("h3");
    staplesTitle.innerHTML = "<em>Make sure you have</em>";
    panel.appendChild(staplesTitle);

    const staplesList = document.createElement("ul");
    staplesList.className = "recipe-detail-ingredients";
    staples.forEach((obj) => addIngredientLi(staplesList, obj, true));
    panel.appendChild(staplesList);
  }

  // ---- Method ----
  const instrTitle = document.createElement("h3");
  instrTitle.textContent = "Method";
  panel.appendChild(instrTitle);

  const instrList = document.createElement("ol");
  instrList.className = "recipe-detail-instructions";
  if (Array.isArray(recipe.instructions) && recipe.instructions.length) {
    recipe.instructions.forEach((step) => {
      const li = document.createElement("li");
      li.textContent = step;
      instrList.appendChild(li);
    });
  } else {
    const li = document.createElement("li");
    li.textContent = "No method stored yet.";
    instrList.appendChild(li);
  }
  panel.appendChild(instrList);

  // Source link (if we have it)
  if (recipe.sourceUrl) {
    const link = document.createElement("a");
    link.className = "recipe-detail-source";
    link.href = recipe.sourceUrl;
    link.target = "_blank";
    link.rel = "noopener noreferrer";
    link.textContent = "View original recipe on BBC";
    panel.appendChild(link);
  }

  overlay.appendChild(panel);
  document.body.appendChild(overlay);

  // Close if you tap the dim background
  overlay.addEventListener("click", (e) => {
    if (e.target === overlay) overlay.remove();
  });
}

    // ----- COOK MODE: tick ingredients to deduct from inventory -----

function openCookDialog(dayId) {
  const entry = mealPlan.find((d) => d.dayId === dayId);
  if (!entry || !entry.recipeId) {
    alert("No recipe selected for this day.");
    return;
  }

  const recipe = recipes.find((r) => r.id === entry.recipeId);
  if (!recipe) {
    alert("Recipe not found.");
    return;
  }
  if (!recipe.ingredients || !recipe.ingredients.length) {
    alert("This recipe has no ingredients saved yet.");
    return;
  }

  // Default servings = planned servings, or recipe base if 0
  const defaultServings =
    entry.servings && entry.servings > 0 ? entry.servings : recipe.servings || 1;

  // Build overlay
  const overlay = document.createElement("div");
  overlay.className = "recipe-detail-overlay cook-overlay";

  const panel = document.createElement("div");
  panel.className = "recipe-detail-panel";

  // Close button
  const closeBtn = document.createElement("button");
  closeBtn.type = "button";
  closeBtn.className = "recipe-detail-close";
  closeBtn.textContent = "Close";
  closeBtn.addEventListener("click", () => overlay.remove());
  panel.appendChild(closeBtn);

  // Title
  const title = document.createElement("h2");
  title.textContent = `Cook: ${recipe.name}`;
  panel.appendChild(title);

  // Servings chooser
  const servingsLabel = document.createElement("label");
  servingsLabel.textContent = "How many servings are you cooking?";
  servingsLabel.style.display = "block";

  const servingsInput = document.createElement("input");
  servingsInput.type = "number";
  servingsInput.min = "1";
  servingsInput.step = "1";
  servingsInput.value = String(defaultServings);
  servingsInput.style.marginTop = "0.5rem";

  servingsLabel.appendChild(servingsInput);
  panel.appendChild(servingsLabel);

  // Container for ingredient checklist
  const ingSection = document.createElement("div");
  ingSection.className = "subpanel";
  ingSection.style.marginTop = "1rem";

  const ingHeading = document.createElement("h3");
  ingHeading.textContent = "Ingredients to use";
  ingSection.appendChild(ingHeading);

  const ingHelp = document.createElement("p");
  ingHelp.textContent =
    "Tick each ingredient as you get it out. Ticking will deduct it from your inventory.";
  ingSection.appendChild(ingHelp);

  const ingList = document.createElement("ul");
  ingList.className = "recipe-detail-ingredients";
  ingSection.appendChild(ingList);

  panel.appendChild(ingSection);

  // Bottom buttons
  const footer = document.createElement("div");
  footer.className = "barcode-scanner-actions"; // reuse nice flex styling if you have it

  const cancelBtn = document.createElement("button");
  cancelBtn.type = "button";
  cancelBtn.className = "secondary";
  cancelBtn.textContent = "Cancel";
  cancelBtn.addEventListener("click", () => overlay.remove());

  const finishBtn = document.createElement("button");
  finishBtn.type = "button";
  finishBtn.textContent = "Finish cooking";

  footer.appendChild(cancelBtn);
  footer.appendChild(finishBtn);

  panel.appendChild(footer);
  overlay.appendChild(panel);
  document.body.appendChild(overlay);

  // Close by tapping dark background
  overlay.addEventListener("click", (e) => {
    if (e.target === overlay) overlay.remove();
  });

  // Helper to render scaled ingredient list
  function renderCookIngredients() {
    ingList.innerHTML = "";

    const cookServings = parseFloat(servingsInput.value || "0");
    if (!cookServings || cookServings <= 0) return;

        const baseServings = recipe.servings && recipe.servings > 0 ? recipe.servings : 1;
    const scale = cookServings / baseServings;

    recipe.ingredients.forEach((ing) => {
      // Skip cupboard staples ‚Äì you don't deduct salt / pepper / oil / nutmeg, etc.
      if (isStapleIngredient(ing.name)) {
        return;
      }

      const li = document.createElement("li");
    
      const row = document.createElement("div");
      row.style.display = "flex";
      row.style.alignItems = "center";
      row.style.gap = "0.5rem";

      const cb = document.createElement("input");
      cb.type = "checkbox";

      // Work out scaled quantity + baseUnit for deduction
      let q = ing.quantity || 0;
      let u = ing.unit || "";
      let scaledQty = q * scale;

      const baseUnit = chooseBaseUnit(u);
      const qtyBase = convertToUnit(scaledQty, u, baseUnit);

      // Nicely formatted label
      let displayQty = scaledQty;
      let displayUnit = u;

      if (displayQty && (u === "g" || u === "ml") && displayQty >= 1000) {
        displayQty = displayQty / 1000;
        displayUnit = u === "g" ? "kg" : "l";
      }

      const compactUnits = ["g", "kg", "ml", "l"];
      const niceNum = Number.isInteger(displayQty)
        ? String(displayQty)
        : (Math.round(displayQty * 10) / 10).toString();
      let qtyStr = "";
      if (displayQty > 0) {
        if (!displayUnit) {
          qtyStr = niceNum;
        } else if (compactUnits.includes(displayUnit)) {
          qtyStr = niceNum + displayUnit;
        } else {
          qtyStr = niceNum + " " + displayUnit;
        }
      }

      const labelSpan = document.createElement("span");
      labelSpan.textContent = qtyStr
        ? `${ing.name}: ${qtyStr}`
        : ing.name;

      // Attach metadata for deduction
      cb.dataset.ingName = ing.name;
      cb.dataset.qtyBase = String(qtyBase);
      cb.dataset.baseUnit = baseUnit || "";

      cb.addEventListener("change", () => {
        if (!cb.checked || cb.dataset.applied === "true") return;

        const name = cb.dataset.ingName;
        const qtyBaseNum = parseFloat(cb.dataset.qtyBase || "0");
        const base = cb.dataset.baseUnit || "";

        // Check exists in inventory first
        const invItem = inventory.find(
          (i) => i.name.toLowerCase() === name.toLowerCase()
        );

        if (!invItem) {
          const ok = confirm(
            `"${name}" is not currently in your inventory.\n\n` +
              "Did you forget to add it, or are you happy to continue without deducting anything?"
          );
          if (!ok) {
            cb.checked = false;
            return;
          }
          // If they are happy ‚Üí do nothing to inventory, just mark as applied
          cb.dataset.applied = "true";
          cb.disabled = true;
          return;
        }

        // Deduct from inventory
        const success = deductInventoryForCooking(name, qtyBaseNum, base);
        if (!success) {
          alert("Could not update inventory for " + name);
          cb.checked = false;
          return;
        }

        cb.dataset.applied = "true";
        cb.disabled = true;

        renderInventory();
        saveState();
      });

      row.appendChild(cb);
      row.appendChild(labelSpan);
      li.appendChild(row);
      ingList.appendChild(li);
    });
  }

  // Initial render
  renderCookIngredients();

  // If servings change, regenerate checklist
  servingsInput.addEventListener("change", () => {
    const val = parseFloat(servingsInput.value || "0");
    if (!val || val <= 0) {
      servingsInput.value = "1";
    }
    renderCookIngredients();
  });

  // Finish cooking: warn if some ingredients not ticked
  finishBtn.addEventListener("click", () => {
    const unchecked = Array.from(
      ingList.querySelectorAll('input[type="checkbox"]:not(:checked)')
    ).map((cb) => cb.dataset.ingName);

    if (unchecked.length) {
      const ok = confirm(
        "You haven't ticked these ingredients:\n\n" +
          unchecked.map((n) => "‚Ä¢ " + n).join("\n") +
          "\n\nIs that because you didn't use them or couldn't buy them?"
      );
      if (!ok) return;
      // We don't change inventory here ‚Äì it's just a safety check
    }

    overlay.remove();
  });
}

  function startRecipeEdit(id, ingredientIndexToEdit) {
  const recipe = recipes.find((r) => r.id === id);
  if (!recipe) return;

  editingRecipeId = id;
  currentRecipe = {
    id: recipe.id,
    name: recipe.name,
    servings: recipe.servings,
    ingredients: recipe.ingredients.map((ing) => ({
      name: ing.name,
      quantity: ing.quantity,
      unit: ing.unit,
    })),
  };

  document.getElementById("recipe-name").value = currentRecipe.name;
  document.getElementById("recipe-servings").value =
    currentRecipe.servings;

  document
    .getElementById("recipe-ingredients-section")
    .classList.remove("hidden");
  document
    .getElementById("cancel-recipe-edit")
    .classList.remove("hidden");

  renderCurrentRecipeIngredients();

  // If we came from the long-press popup, drop straight into that ingredient
  if (
    typeof ingredientIndexToEdit === "number" &&
    ingredientIndexToEdit >= 0 &&
    ingredientIndexToEdit < currentRecipe.ingredients.length
  ) {
    startIngredientEdit(ingredientIndexToEdit);
  } else {
    clearIngredientEditState();
  }
}

    // ---------- MEAL PLAN ----------

    function renderMealPlan() {
      const container = document.getElementById("meal-plan-container");
      if (!container) return;
      container.innerHTML = "";

      if (!mealPlan || !mealPlan.length) initDefaultMealPlan();

      const validIds = new Set(recipes.map((r) => r.id));
      mealPlan.forEach((entry) => {
        if (entry.recipeId && !validIds.has(entry.recipeId)) {
          entry.recipeId = "";
          entry.servings = 0;
        }
      });

      mealPlan.forEach((entry) => {
        const row = document.createElement("div");
        row.className = "subpanel";

        const label = document.createElement("h3");
        label.textContent = entry.dayLabel;
        row.appendChild(label);

        const recipeLabel = document.createElement("label");
        recipeLabel.textContent = "Recipe";

        const select = document.createElement("select");
        select.dataset.dayId = entry.dayId;

        const defaultOpt = document.createElement("option");
        defaultOpt.value = "";
        defaultOpt.textContent = "(no meal selected)";
        select.appendChild(defaultOpt);

        recipes
          .slice()
          .sort((a, b) => a.name.localeCompare(b.name))
          .forEach((recipe) => {
            const opt = document.createElement("option");
            opt.value = recipe.id;
            opt.textContent = `${recipe.name} (serves ${recipe.servings})`;
            select.appendChild(opt);
          });

        select.value = entry.recipeId || "";
        select.addEventListener("change", (e) => {
         const id = e.target.dataset.dayId;
         const planEntry = mealPlan.find((p) => p.dayId === id);
         if (!planEntry) return;
         planEntry.recipeId = e.target.value;
         if (!planEntry.recipeId) {
          planEntry.servings = 0;
          const sInput = document.querySelector(
            `input[data-day-id="${id}"]`
          );
          if (sInput) sInput.value = "0";
        }
        saveState();
        updateCookBtnState();
      });

        recipeLabel.appendChild(select);
        row.appendChild(recipeLabel);

        const servingsLabel = document.createElement("label");
        servingsLabel.textContent = "Planned servings";

        const servingsInput = document.createElement("input");
        servingsInput.type = "number";
        servingsInput.min = "0";
        servingsInput.step = "1";
        servingsInput.dataset.dayId = entry.dayId;
        servingsInput.value =
          entry.servings && entry.servings > 0 ? entry.servings : "0";

        servingsInput.addEventListener("change", (e) => {
  const id = e.target.dataset.dayId;
  const planEntry = mealPlan.find((p) => p.dayId === id);
  if (!planEntry) return;
  let val = parseFloat(e.target.value || "0");
  if (isNaN(val) || val < 0) val = 0;
  planEntry.servings = val;
  e.target.value = val === 0 ? "0" : String(val);
  saveState();
  updateCookBtnState();
});

        servingsLabel.appendChild(servingsInput);
        row.appendChild(servingsLabel);

                // "I'm cooking this" button
        const cookBtn = document.createElement("button");
        cookBtn.type = "button";
        cookBtn.textContent = "I'm cooking this";
        cookBtn.className = "secondary";
        cookBtn.style.marginTop = "0.5rem";

        // Enable only if recipe + servings selected
        function updateCookBtnState() {
          const hasRecipe = !!entry.recipeId;
          const hasServings = entry.servings && entry.servings > 0;
          cookBtn.disabled = !(hasRecipe && hasServings);
        }

        cookBtn.addEventListener("click", () => {
          openCookDialog(entry.dayId);
        });

        updateCookBtnState();
        row.appendChild(cookBtn);

        container.appendChild(row);
      });
    }

    // ---------- SHOPPING LIST ----------
function roundUpForShopping(quantity, unit) {
  if (!quantity || quantity <= 0) return 0;
  unit = (unit || "").toLowerCase();

  // g / ml ‚Üí round up to nearest 50
  if (unit === "g" || unit === "ml") {
    return Math.ceil(quantity / 50) * 50; // e.g. 241.7 ‚Üí 250
  }

  // kg / l ‚Üí round up to nearest 0.1
  if (unit === "kg" || unit === "l") {
    return Math.ceil(quantity * 10) / 10; // e.g. 1.21 ‚Üí 1.3
  }

  // tsp / tbsp ‚Üí round up to nearest 0.5
  if (
    unit === "tsp" ||
    unit === "teaspoon" ||
    unit === "teaspoons" ||
    unit === "tbsp" ||
    unit === "tablespoon" ||
    unit === "tablespoons"
  ) {
    return Math.ceil(quantity * 2) / 2; // e.g. 0.42 ‚Üí 0.5
  }

  // cloves / sticks / packs / pieces ‚Üí round to whole items
  if (
    unit === "clove" ||
    unit === "cloves" ||
    unit === "stick" ||
    unit === "sticks" ||
    unit === "pack" ||
    unit === "packs" ||
    unit === "pc" ||
    unit === "pcs" ||
    unit === "piece" ||
    unit === "pieces"
  ) {
    return Math.ceil(quantity);
  }

  // Fallback: round up to 1 decimal place
  return Math.ceil(quantity * 10) / 10;
}
    function generateShoppingList() {
  const required = {};

  // Work out how much is needed for all planned meals
  mealPlan.forEach((entry) => {
    if (!entry.recipeId) return;
    const plannedServings = parseFloat(entry.servings || "0");
    if (plannedServings <= 0) return;

    const recipe = recipes.find((r) => r.id === entry.recipeId);
    if (!recipe) return;

    const scale = plannedServings / recipe.servings;

          recipe.ingredients.forEach((ing) => {
      // Skip cupboard staples (salt, pepper, oil, nutmeg, etc.)
      if (isStapleIngredient(ing.name)) {
        return;
      }

      // Skip ingredients that don't have a usable quantity
      if (!ing.quantity || ing.quantity <= 0) {
        return;
      }

      const key = ing.name.toLowerCase();
      const ingUnit = ing.unit || "";
      const baseUnit = required[key]
        ? required[key].baseUnit
        : chooseBaseUnit(ingUnit); // g/kg -> g, ml/l -> ml, else itself

      if (!required[key]) {
        required[key] = {
          name: ing.name,
          quantityBase: 0,
          baseUnit,
        };
      }

      const qtyScaled = ing.quantity * scale;
      const qtyInBase = convertToUnit(qtyScaled, ingUnit, required[key].baseUnit);
      required[key].quantityBase += qtyInBase;
    });
  });

  const tbody = document.querySelector("#shopping-table tbody");
  if (!tbody) return;
  tbody.innerHTML = "";

  // Helper to make numbers look tidy
  function formatNumberNice(n) {
    if (Number.isInteger(n)) return String(n);
    const oneDp = Math.round(n * 10) / 10;
    if (Number.isInteger(oneDp * 10)) return oneDp.toString();
    return (Math.round(n * 100) / 100).toString();
  }

  Object.keys(required).forEach((key) => {
    const need = required[key];
    const baseUnit = need.baseUnit;
    let requiredBase = need.quantityBase;

    // Work out what we already have in inventory (in the same base unit)
    let invQtyBase = 0;
    const invItem = inventory.find((i) => i.name.toLowerCase() === key);
    if (invItem && baseUnit) {
      invQtyBase = convertToUnit(invItem.quantity, invItem.unit || "", baseUnit);
    } else if (invItem && !baseUnit) {
      invQtyBase = invItem.quantity;
    }

    let toBuyBase = Math.max(0, requiredBase - invQtyBase);
    if (toBuyBase <= 1e-9) return; // nothing to buy ‚Üí skip row

    // Decide how to *display* that quantity
    let displayQty = toBuyBase;
    let displayUnit = baseUnit;

    // Rule we want:
    //  - if < 1000g/ml -> stay in g/ml
    //  - if >= 1000g/ml -> convert to kg/L
    if (baseUnit === "g") {
      if (displayQty >= 1000) {
        displayQty = displayQty / 1000;
        displayUnit = "kg";
      } else {
        displayUnit = "g";
      }
    } else if (baseUnit === "ml") {
      if (displayQty >= 1000) {
        displayQty = displayQty / 1000;
        displayUnit = "l";
      } else {
        displayUnit = "ml";
      }
    }
        // Round up to sensible shopping amounts
    displayQty = roundUpForShopping(displayQty, displayUnit);

    // Build a nice string like "500g" or "1.5kg" or "2 packs"
    let qtyStr;
    if (!displayUnit) {
      qtyStr = formatNumberNice(displayQty);
    } else {
      const smallUnits = ["g", "kg", "ml", "l"];
      const nStr = formatNumberNice(displayQty);
      if (smallUnits.includes(displayUnit)) {
        qtyStr = nStr + displayUnit;
      } else {
        qtyStr = nStr + " " + displayUnit.toLowerCase();
      }
    }

    // Create table row
    const tr = document.createElement("tr");
    tr.dataset.itemName = need.name;
    tr.dataset.buyQty = String(displayQty);
    tr.dataset.buyUnit = displayUnit || "";

    const tdCheck = document.createElement("td");
    const cb = document.createElement("input");
    cb.type = "checkbox";
    cb.className = "shopping-bought";
    tdCheck.appendChild(cb);

    const tdName = document.createElement("td");
    tdName.textContent = need.name;

    const tdBuy = document.createElement("td");
    // Convert tiny kg / L amounts back to g / ml for display
let fixedQtyStr = qtyStr;
const match = qtyStr.match(/^(\d+(?:\.\d+)?)\s*(kg|KG|l|L)$/); // e.g. "0.5kg", "0.75L"

if (match) {
  let value = parseFloat(match[1]);
  const unit = match[2].toLowerCase();

  // helper to make the number look neat
  const tidy = (n) =>
    Number.isInteger(n) ? String(n) : (Math.round(n * 100) / 100).toString();

  if (unit === "kg" && value < 1) {
    // e.g. 0.5kg -> 500g
    const grams = value * 1000;
    fixedQtyStr = tidy(grams) + "g";
  } else if (unit === "l" && value < 1) {
    // e.g. 0.75L -> 750ml
    const ml = value * 1000;
    fixedQtyStr = tidy(ml) + "ml";
  }
}

tdBuy.textContent = fixedQtyStr;

    tr.appendChild(tdCheck);
    tr.appendChild(tdName);
    tr.appendChild(tdBuy);
    tbody.appendChild(tr);
  });

  // When you tick items, add them into inventory
  const checkboxes = tbody.querySelectorAll(".shopping-bought");
  checkboxes.forEach((cb) => {
    cb.addEventListener("change", () => {
      const tr = cb.closest("tr");
      if (!tr) return;
      if (!cb.checked || tr.dataset.applied === "true") return;

      const name = tr.dataset.itemName;
      const qty = parseFloat(tr.dataset.buyQty || "0");
      const unit = tr.dataset.buyUnit || "";
      if (!name || !qty || qty <= 0) return;

      upsertInventoryItem(name, qty, unit);
      tr.dataset.applied = "true";

      renderInventory();
      renderInventoryNameSuggestions();
      saveState();
    });
  });
}

// ---------- BARCODE CAMERA SCANNER ----------

// ---------- BARCODE CAMERA SCANNER ----------

let activeBarcodeReader = null;
let barcodeScanHandled = false;     // prevents multiple runs for one scan
let lastScannedCode = null;         // remember the last successful barcode

function closeBarcodeScannerOverlay() {
  const overlay = document.getElementById("barcode-scanner-overlay");
  if (overlay) overlay.remove();

  barcodeScanHandled = true;

  if (activeBarcodeReader) {
    try {
      activeBarcodeReader.reset();
    } catch (e) {
      console.error(e);
    }
    activeBarcodeReader = null;
  }
}

function openBarcodeScanner() {
  if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
    alert("Camera access is not supported on this device / browser.");
    return;
  }

  // Always start with a fresh overlay
  let overlay = document.getElementById("barcode-scanner-overlay");
  if (overlay) {
    overlay.remove();
  }

  lastScannedCode = null;

  overlay = document.createElement("div");
  overlay.id = "barcode-scanner-overlay";
  overlay.className = "barcode-scanner-overlay";

  const panel = document.createElement("div");
  panel.className = "barcode-scanner-panel";

  const title = document.createElement("h2");
  title.textContent = "Scan barcode";
  panel.appendChild(title);

  const video = document.createElement("video");
  video.id = "barcode-video";
  video.autoplay = true;
  video.playsInline = true;
  panel.appendChild(video);

  const btnRow = document.createElement("div");
  btnRow.className = "barcode-scanner-actions";

  const cancelBtn = document.createElement("button");
  cancelBtn.type = "button";
  cancelBtn.textContent = "Cancel";
  cancelBtn.className = "secondary";
  cancelBtn.addEventListener("click", () => {
    closeBarcodeScannerOverlay();
  });

  btnRow.appendChild(cancelBtn);
  panel.appendChild(btnRow);

  overlay.appendChild(panel);

  // Close if you tap the dim background
  overlay.addEventListener("click", (e) => {
    if (e.target === overlay) closeBarcodeScannerOverlay();
  });

  document.body.appendChild(overlay);

  const ZX = window.ZXingBrowser || window.ZXing;
  if (!ZX || !ZX.BrowserMultiFormatReader) {
    alert("Barcode scanner library not loaded.");
    return;
  }

  barcodeScanHandled = false;

  activeBarcodeReader = new ZX.BrowserMultiFormatReader();

  activeBarcodeReader.decodeFromVideoDevice(null, "barcode-video", (result, err) => {
    if (barcodeScanHandled) return;

    if (!result || !result.text) return;

    const code = result.text.trim();
    if (!code) return;

    // üëá KEY BIT: if it‚Äôs the same barcode as the previous successful scan,
    // completely ignore it. This stops the ‚Äúauto reusing 123‚Äù issue.
    if (code === lastScannedCode) {
      return; // keep scanning, waiting for a different code
    }

    lastScannedCode = code;

    barcodeScanHandled = true;
    closeBarcodeScannerOverlay();
    handleBarcodeCode(code); // opens your ‚ÄúAdd item from barcode‚Äù dialog
  });
}

// ---------- NAVIGATION ----------
function showPage(pageId) {
  const pages = document.querySelectorAll(".page");
  const navButtons = document.querySelectorAll(".app-nav button");

  pages.forEach((page) => {
    if (!page) return;
    page.classList.toggle("hidden", page.id !== pageId);
  });

  navButtons.forEach((btn) => {
    if (!btn) return;
    const controls = btn.getAttribute("aria-controls");
    btn.setAttribute(
      "aria-selected",
      controls === pageId ? "true" : "false"
    );
  });
}

// ---------- INIT EVERYTHING ONCE THE PAGE IS READY ----------

document.addEventListener("DOMContentLoaded", () => {
  // Load saved data (inventory, recipes, meal plan, staples, barcodes)
  loadState();

  // === NAV BAR BUTTONS ===
  document.getElementById("nav-inventory")?.addEventListener("click", () => {
    showPage("page-inventory");
  });

  document.getElementById("nav-recipes")?.addEventListener("click", () => {
    showPage("page-recipes");
  });

  document.getElementById("nav-mealplan")?.addEventListener("click", () => {
    showPage("page-mealplan");
  });

  document.getElementById("nav-shopping")?.addEventListener("click", () => {
    showPage("page-shopping");
  });

  // Start on Inventory
  showPage("page-inventory");

  // === INVENTORY EVENTS ===
  const invForm = document.getElementById("inventory-form");
  const cancelInvEditBtn = document.getElementById("inventory-cancel-edit");
  const fakeScanBtn = document.getElementById("fake-scan-btn");
  const realScanBtn = document.getElementById("real-scan-btn");
  
    const addInventoryBtn = document.getElementById("add-inventory-item-btn");

  if (addInventoryBtn) {
    addInventoryBtn.addEventListener("click", () => {
      openAddInventoryItemDialog(); // add new item
    });
  }

  if (fakeScanBtn) {
    fakeScanBtn.addEventListener("click", handleFakeBarcodeScan);
  }
  if (realScanBtn) {
    realScanBtn.addEventListener("click", openBarcodeScanner);
  }

  if (invForm) {
    invForm.addEventListener("submit", (e) => {
      e.preventDefault();

      const nameEl = document.getElementById("inv-name");
      const qtyEl = document.getElementById("inv-qty");
      const unitEl = document.getElementById("inv-unit");

      const name = nameEl.value.trim();
      const qty = parseFloat(qtyEl.value || "0");
      const unit = unitEl.value || "";

      if (!name) {
        alert("Please enter an item name.");
        return;
      }
      if (!qty || qty <= 0 || Number.isNaN(qty)) {
        alert("Please enter a valid quantity.");
        return;
      }

      if (editingInventoryKey) {
        setInventoryItemExact(editingInventoryKey, name, qty, unit);
      } else {
        upsertInventoryItem(name, qty, unit);
      }

      renderInventory();
      renderInventoryNameSuggestions();
      saveState();
      clearInventoryEditState();
    });
  }

  if (cancelInvEditBtn) {
    cancelInvEditBtn.addEventListener("click", () => {
      clearInventoryEditState();
    });
  }

  if (fakeScanBtn) {
    fakeScanBtn.addEventListener("click", () => {
      handleFakeBarcodeScan();
    });
  }

  if (realScanBtn) {
    realScanBtn.addEventListener("click", () => {
      openBarcodeScanner();
    });
  }

  // === RECIPES: START / INGREDIENTS ===
  const startRecipeBtn = document.getElementById("start-recipe");
  const cancelRecipeEditBtn = document.getElementById("cancel-recipe-edit");
  const ingredientForm = document.getElementById("ingredient-form");
  const cancelIngredientEditBtn = document.getElementById("cancel-ingredient-edit");

  if (startRecipeBtn) {
    startRecipeBtn.addEventListener("click", () => {
      const nameEl = document.getElementById("recipe-name");
      const servingsEl = document.getElementById("recipe-servings");

      const name = (nameEl.value || "").trim();
      const servings = parseFloat(servingsEl.value || "0");

      if (!name) {
        alert("Please enter a recipe name first.");
        return;
      }
      if (!servings || servings <= 0 || Number.isNaN(servings)) {
        alert("Please enter how many servings the base recipe makes.");
        return;
      }

      const id = editingRecipeId || ("r_" + Date.now());

      currentRecipe = {
        id,
        name,
        servings,
        ingredients: [],
        instructions: currentRecipe && currentRecipe.instructions
          ? currentRecipe.instructions
          : [],
        imageUrl: currentRecipe && currentRecipe.imageUrl
          ? currentRecipe.imageUrl
          : "",
        sourceUrl: currentRecipe && currentRecipe.sourceUrl
          ? currentRecipe.sourceUrl
          : ""
      };

      document
        .getElementById("recipe-ingredients-section")
        .classList.remove("hidden");
      document
        .getElementById("cancel-recipe-edit")
        .classList.remove("hidden");

      renderCurrentRecipeIngredients();
      clearIngredientEditState();
    });
  }

  if (cancelRecipeEditBtn) {
    cancelRecipeEditBtn.addEventListener("click", () => {
      clearRecipeEditState();
    });
  }

  if (ingredientForm) {
    ingredientForm.addEventListener("submit", (e) => {
      e.preventDefault();
      if (!currentRecipe) {
        alert("Start a recipe first (name + servings, then 'Start new recipe').");
        return;
      }

      const nameEl = document.getElementById("ing-name");
      const qtyEl = document.getElementById("ing-qty");
      const unitEl = document.getElementById("ing-unit");

      const name = nameEl.value.trim();
      const qty = parseFloat(qtyEl.value || "0");
      const unit = unitEl.value || "";

      if (!name) {
        alert("Please enter an ingredient name.");
        return;
      }
      if (!qty || qty <= 0 || Number.isNaN(qty)) {
        alert("Please enter a valid quantity.");
        return;
      }

      const newIng = { name: titleCase(name), quantity: qty, unit };

      if (
        typeof editingIngredientIndex === "number" &&
        editingIngredientIndex >= 0 &&
        currentRecipe.ingredients[editingIngredientIndex]
      ) {
        currentRecipe.ingredients[editingIngredientIndex] = newIng;
      } else {
        currentRecipe.ingredients.push(newIng);
      }

      renderCurrentRecipeIngredients();
      clearIngredientEditState();
    });
  }

  if (cancelIngredientEditBtn) {
    cancelIngredientEditBtn.addEventListener("click", () => {
      clearIngredientEditState();
    });
  }

  // === IMPORT INGREDIENTS (BIG TEXT AREA) ===
  const importBtn = document.getElementById("import-ingredients-btn");
  if (importBtn) {
    importBtn.addEventListener("click", () => {
      if (!currentRecipe) {
        alert(
          "Start a recipe first (name + servings, then 'Start new recipe')."
        );
        return;
      }

      const textarea = document.getElementById("import-text");
      const raw = textarea.value || "";
      const lines = raw
        .split(/\r?\n/)
        .map((l) => l.trim())
        .filter(Boolean);

      let imported = 0;

      const bbcNames =
        lastImportedRecipeMeta &&
        Array.isArray(lastImportedRecipeMeta.ingredientNames) &&
        lastImportedRecipeMeta.ingredientNames.length
          ? lastImportedRecipeMeta.ingredientNames
          : null;

      lines.forEach((line) => {
        let parsed;

        if (bbcNames) {
          parsed = parseBbcIngredient(line, bbcNames);
        } else {
          parsed = parseIngredientLine(line);
        }

        if (!parsed || !parsed.name) return;

        if (parsed.quantity !== null && parsed.quantity !== undefined) {
          if (Number.isNaN(parsed.quantity) || parsed.quantity <= 0) return;
        }

        currentRecipe.ingredients.push(parsed);
        imported++;
      });

      renderCurrentRecipeIngredients();
      if (imported) {
        alert(`Imported ${imported} ingredient(s).`);
        textarea.value = "";
      } else {
        alert("No valid ingredients found.");
      }
    });
  }

  // === SAVE RECIPE BUTTON ===
  const saveRecipeBtn = document.getElementById("save-recipe");
  if (saveRecipeBtn) {
    saveRecipeBtn.addEventListener("click", () => {
      if (!currentRecipe) {
        alert("No recipe in progress.");
        return;
      }
      if (
        !currentRecipe.ingredients ||
        !currentRecipe.ingredients.length
      ) {
        alert("Add at least one ingredient.");
        return;
      }

      if (
        lastImportedRecipeMeta &&
        Array.isArray(lastImportedRecipeMeta.instructions) &&
        (!currentRecipe.instructions ||
          !currentRecipe.instructions.length)
      ) {
        currentRecipe.instructions =
          lastImportedRecipeMeta.instructions.slice();
      }

      if (lastImportedRecipeMeta) {
        if (!currentRecipe.imageUrl && lastImportedRecipeMeta.image) {
          currentRecipe.imageUrl = lastImportedRecipeMeta.image;
        }
        if (!currentRecipe.sourceUrl && lastImportedRecipeMeta.sourceUrl) {
          currentRecipe.sourceUrl = lastImportedRecipeMeta.sourceUrl;
        }
      }

      currentRecipe.ingredients = mergeDuplicateIngredientsInList(
        currentRecipe.ingredients || []
      );

      if (editingRecipeId) {
        const idx = recipes.findIndex(
          (r) => r.id === editingRecipeId
        );
        if (idx !== -1) {
          recipes[idx] = {
            id: editingRecipeId,
            name: currentRecipe.name,
            servings: currentRecipe.servings,
            ingredients: currentRecipe.ingredients,
            instructions: currentRecipe.instructions || [],
            imageUrl: currentRecipe.imageUrl || "",
            sourceUrl: currentRecipe.sourceUrl || "",
          };
        }
      } else {
        recipes.push(currentRecipe);
      }

      clearRecipeEditState();
      renderRecipesList();
      saveState();
    });
  }

  // === BBC IMPORT (IMAGE + TITLE + INGREDIENTS + METHOD) ===
  const recipeImportUrlInput = document.getElementById("recipe-import-url");
  const recipeImageFetchBtn = document.getElementById("recipe-fetch-image");
  const recipeImportStatus = document.getElementById("recipe-import-status");
  const recipeImagePreview = document.getElementById("recipe-image-preview");
  const recipeImportTextarea = document.getElementById("import-text");
  const recipeClearBtn = document.getElementById("recipe-clear-import");

  if (
    recipeImportUrlInput &&
    recipeImageFetchBtn &&
    recipeImportStatus &&
    recipeImagePreview &&
    recipeImportTextarea
  ) {
    if (recipeClearBtn) {
      recipeClearBtn.addEventListener("click", () => {
        recipeImportUrlInput.value = "";
        recipeImportStatus.textContent = "";
        recipeImportStatus.classList.remove("error");
        recipeImagePreview.style.display = "none";
        recipeImagePreview.src = "";
        recipeImportTextarea.value = "";
        lastImportedRecipeMeta = null;
      });
    }

    recipeImageFetchBtn.addEventListener("click", async () => {
      const rawUrl = recipeImportUrlInput.value.trim();
      if (!rawUrl) {
        recipeImportStatus.textContent = "Please paste a recipe URL first.";
        recipeImportStatus.classList.add("error");
        recipeImagePreview.style.display = "none";
        return;
      }

      recipeImportStatus.textContent = "Fetching recipe‚Ä¶";
      recipeImportStatus.classList.remove("error");
      recipeImagePreview.style.display = "none";
      lastImportedRecipeMeta = null;

      try {
        const endpoint = WORKER_BASE + "?url=" + encodeURIComponent(rawUrl);
        const res = await fetch(endpoint);
        if (!res.ok) {
          throw new Error("Proxy returned " + res.status);
        }
        const data = await res.json();

        if (!data || data.ok === false) {
          recipeImportStatus.textContent =
            (data && data.error) || "Recipe not found on that page.";
          recipeImportStatus.classList.add("error");
          recipeImagePreview.style.display = "none";
          return;
        }

        if (data.image) {
          recipeImagePreview.src = data.image;
          recipeImagePreview.style.display = "block";
        } else {
          recipeImagePreview.style.display = "none";
        }

        const titleInput = document.getElementById("recipe-name");
        if (titleInput && !titleInput.value.trim() && data.title) {
          titleInput.value = tidyRecipeTitle(data.title);
        }

        const servingsInput = document.getElementById("recipe-servings");
        if (servingsInput && data.servings) {
          const currentVal = servingsInput.value.trim();
          if (!currentVal || currentVal === "2") {
            const parsed = parseServingsNumber(data.servings);
            if (parsed && parsed > 0) {
              servingsInput.value = String(parsed);
            }
          }
        }

        if (Array.isArray(data.ingredients) && data.ingredients.length) {
          recipeImportTextarea.value = data.ingredients.join("\n");
        }

        const ingredientNames = Array.isArray(data.ingredientNames)
          ? data.ingredientNames
          : [];

        if (Array.isArray(data.instructions) && data.instructions.length) {
          lastImportedRecipeMeta = {
            instructions: data.instructions.slice(),
            sourceUrl: data.source || rawUrl,
            servingsText: data.servings || "",
            image: data.image || "",
            title: data.title || "",
            ingredientNames
          };
        } else {
          lastImportedRecipeMeta = {
            instructions: [],
            sourceUrl: data.source || rawUrl,
            servingsText: data.servings || "",
            image: data.image || "",
            title: data.title || "",
            ingredientNames
          };
        }

        recipeImportStatus.textContent =
          "Recipe info loaded. Review, then click 'Import ingredients'.";
        recipeImportStatus.classList.remove("error");
      } catch (err) {
        console.error(err);
        recipeImportStatus.textContent = "Could not fetch recipe.";
        recipeImportStatus.classList.add("error");
        recipeImagePreview.style.display = "none";
        lastImportedRecipeMeta = null;
      }
    });
  }

  // === MEAL PLAN / SHOPPING ===
  const generateShoppingBtn = document.getElementById("generate-shopping-list");
  if (generateShoppingBtn) {
    generateShoppingBtn.addEventListener("click", () => {
      generateShoppingList();
      showPage("page-shopping");
    });
  }

  // === INITIAL RENDERS ===
  renderInventory();
  renderInventoryNameSuggestions();
  renderRecipesList();
  renderMealPlan();

  // === SERVICE WORKER (PWA) ===
  if ("serviceWorker" in navigator) {
    navigator.serviceWorker
      .register("./sw.js")
      .catch(() => {});
  }
});
  </script>
</body>
</html>