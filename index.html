<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport"
  content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover"/>
  <meta name="color-scheme" content="dark light" />
  <title>Pantry App</title>

  <link rel="stylesheet" href="styles.css?v=23"/>

  <!-- PWA -->
  <link rel="apple-touch-icon" sizes="180x180" href="icon-180.png">
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#ff7a00">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
</head>

<body>

  <!-- TOP BAR -->
  <header class="top-bar">
    <span class="top-bar-title">Pantry App</span>
  </header>

  <!-- NAVIGATION BUTTONS -->
  <nav id="app-nav" class="app-nav" role="tablist" aria-label="Pantry navigation">
    <button id="nav-inventory" aria-controls="page-inventory" aria-selected="true" type="button">Inventory</button>
    <button id="nav-recipes" aria-controls="page-recipes" aria-selected="false" type="button">Recipes</button>
    <button id="nav-mealplan" aria-controls="page-mealplan" aria-selected="false" type="button">Meal plan</button>
    <button id="nav-shopping" aria-controls="page-shopping" aria-selected="false" type="button">Shopping list</button>
  </nav>

  <!-- ======================================= -->
  <!-- PAGE 1 ‚Äì INVENTORY                      -->
  <!-- ======================================= -->
<main id="page-inventory" class="page" role="tabpanel" aria-labelledby="nav-inventory">
  <section class="panel">
    <h2>Inventory</h2>

   <div class="inventory-actions-row">
  <button id="add-inventory-item-btn">Add Item</button>
  <button id="real-scan-btn">Scan barcode</button>
</div>

    <div id="inventory-list" class="inventory-list"></div>
  </section>
</main>

  <!-- ======================================= -->
  <!-- PAGE 2 ‚Äì RECIPES                        -->
  <!-- ======================================= -->
  <section id="page-recipes" class="page hidden" role="tabpanel" aria-labelledby="nav-recipes">
    <section class="panel">
      <h2>Recipes</h2>

      <div class="barcode-tools">
        <button id="add-recipe-btn" type="button">Add recipe</button>
        <button id="import-recipe-btn" type="button" class="secondary">Import recipe</button>
      </div>

      <div id="recipe-import-card" class="recipe-import card hidden">
        <h2>Import from BBC Food</h2>

        <p>Paste a BBC link and tap "Fetch image".</p>

        <div class="recipe-import-row">
          <input type="url" id="recipe-import-url" placeholder="https://www.bbc.co.uk/food/recipes/..." />
          <button id="recipe-fetch-image" type="button">Fetch image</button>
          <button id="recipe-clear-import" type="button" class="secondary">Clear</button>
        </div>

        <p id="recipe-import-status" class="import-status"></p>

        <div class="recipe-image-preview-wrapper">
          <img id="recipe-image-preview" class="recipe-image-preview" alt="Recipe preview" style="display:none;">
        </div>
      </div>

      <!-- Legacy inline recipe editor -- stays hidden -->
      <form id="recipe-form" class="hidden">
        <label>Recipe name <input id="recipe-name" type="text"></label>
        <label>Servings <input id="recipe-servings" type="number" value="2" min="1"></label>

        <div class="form-actions">
          <button id="start-recipe" type="button">Start new recipe</button>
          <button id="cancel-recipe-edit" type="button" class="secondary hidden">Cancel</button>
        </div>
      </form>

      <div id="recipe-ingredients-section" class="subpanel hidden">
        <h3>Ingredients for current recipe</h3>

        <form id="ingredient-form">
          <label>Ingredient name <input id="ing-name" type="text"></label>

          <div class="grid-2">
            <label>Quantity <input id="ing-qty" type="number" value="1" min="0" step="0.1"></label>
            <label>Unit <input id="ing-unit" type="text" placeholder="g, ml, pcs‚Ä¶"></label>
          </div>

          <div class="form-actions">
            <button type="submit">Add ingredient</button>
            <button id="cancel-ingredient-edit" type="button" class="secondary hidden">Cancel</button>
          </div>
        </form>

        <ul id="current-recipe-ingredients"></ul>

        <button id="save-recipe" type="button">Save recipe</button>

        <div class="subpanel">
          <h3>Quick import from text</h3>
          <textarea id="import-text" rows="6"></textarea>
          <button id="import-ingredients-btn" type="button">Import into current recipe</button>
        </div>
      </div>

    </section>

    <section class="panel">
      <h2>Saved recipes</h2>
      <p>These can be used in your meal plan.</p>
      <div id="recipes-list"></div>
    </section>

  </section>

  <!-- ======================================= -->
  <!-- PAGE 3 ‚Äì MEAL PLAN                      -->
  <!-- ======================================= -->
  <section id="page-mealplan" class="page hidden" role="tabpanel" aria-labelledby="nav-mealplan">
    <section class="panel">
      <h2>Meal plan</h2>
      <p>Select meals for each day and portions.</p>

      <div id="meal-plan-container"></div>

      <button id="generate-shopping-list" type="button">Generate shopping list</button>
    </section>
  </section>

  <!-- ======================================= -->
  <!-- PAGE 4 ‚Äì SHOPPING LIST                  -->
  <!-- ======================================= -->
  <section id="page-shopping" class="page hidden" role="tabpanel" aria-labelledby="nav-shopping">
    <section class="panel">
      <h2>Shopping list</h2>
      <p>Based on your meal plan & inventory.</p>

      <table id="shopping-table">
        <thead>
          <tr>
            <th>‚úì</th>
            <th>Item</th>
            <th>To buy</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </section>
  </section>

<!-- Barcode scanner library (UMD build, exposes global ZXingBrowser) -->
<script src="https://unpkg.com/@zxing/browser@latest/umd/zxing-browser.min.js"></script>

  <!-- =============== JAVASCRIPT =============== -->
  <script>
    const WORKER_BASE = "https://icy-rain-e28c.gaz-cottier23.workers.dev";
    // ---------- UTILITIES ----------

    function titleCase(str) {
      return str
        .toLowerCase()
        .split(" ")
        .filter(Boolean)
        .map((w) => w.charAt(0).toUpperCase() + w.slice(1))
        .join(" ");
    }

    function convertToUnit(quantity, fromUnit, toUnit) {
      if (!fromUnit || !toUnit) return quantity;
      if (fromUnit === toUnit) return quantity;
      if (fromUnit === "g" && toUnit === "kg") return quantity / 1000;
      if (fromUnit === "kg" && toUnit === "g") return quantity * 1000;
      if (fromUnit === "ml" && toUnit === "l") return quantity / 1000;
      if (fromUnit === "l" && toUnit === "ml") return quantity * 1000;
      return quantity;
    }

    function normalizeInventoryItem(item) {
      if (item.unit === "g" && item.quantity >= 1000) {
        item.quantity = item.quantity / 1000;
        item.unit = "kg";
      } else if (item.unit === "ml" && item.quantity >= 1000) {
        item.quantity = item.quantity / 1000;
        item.unit = "l";
      }
    }

    function chooseBaseUnit(unit) {
      if (unit === "kg" || unit === "g") return "g";
      if (unit === "l" || unit === "ml") return "ml";
      return unit || "";
    }

    function formatQuantityWithUnit(quantity, unit) {
      if (!unit) return String(quantity);
      const compact = ["g", "kg", "ml", "l"];
      const isCompact = compact.includes(unit);
      const nStr = Number.isInteger(quantity)
        ? String(quantity)
        : quantity.toString();
      return isCompact ? nStr + unit : nStr + " " + unit.toLowerCase();
    }

    // Auto-compact g/ml to kg/l when quantity is 1000 or more
function autoCompactQuantityUnit(quantity, unit) {
  let q = quantity;
  let u = (unit || "").toLowerCase();

  if ((u === "g" || u === "ml") && q >= 1000) {
    q = q / 1000;
    u = u === "g" ? "kg" : "l";
  }

  return { quantity: q, unit: u };
}

// Ingredients that we never want in shopping lists / inventory logic
// (case-insensitive exact matches)
const ALWAYS_IN_CUPBOARD = [
  "salt",
  "fine sea salt",
  "sea salt",
  "sea salt flakes",
  "maldon sea salt flakes",
  "black pepper",
  "freshly ground black pepper",
  "pepper",
  "salt and freshly ground black pepper",
  "salt and black pepper",
  "salt & freshly ground black pepper",
  "salt & pepper"
];

// "Default" staple keywords you ship with the app.
// You can tweak these in code.
const STAPLE_KEYWORDS = [
  "salt",
  "pepper",
  "black pepper",
  "white pepper",
  "nutmeg",
  "mixed spice",
  "mixed herbs",
  "oil",
  "olive oil",
  "vegetable oil",
  "sunflower oil",
  "rapeseed oil",
  "cooking oil",
  "butter",
  "unsalted butter",
  "salted butter",
  "flour",
  "plain flour",
  "self-raising flour"
];

// User-added staples (by ingredient name, lower-cased). Persisted in localStorage.
let userStaples = [];

// True if this ingredient should be treated as a staple
function isStapleIngredient(name) {
  if (!name) return false;
  const lower = name.toLowerCase().trim();

  // 1) Exact phrase from ALWAYS_IN_CUPBOARD (your hard-coded combos)
  if (ALWAYS_IN_CUPBOARD.includes(lower)) return true;

  // 2) User-added staples (via long-press ‚Üí "Mark as staple")
  if (userStaples.includes(lower)) return true;

  // 3) Contains one of the default staple keywords
  return STAPLE_KEYWORDS.some((kw) => lower.includes(kw));
}

// Toggle user staple on/off for this device
function toggleUserStaple(name) {
  if (!name) return;
  const lower = name.toLowerCase().trim();
  if (!lower) return;

  const idx = userStaples.indexOf(lower);
  if (idx === -1) {
    userStaples.push(lower);
  } else {
    userStaples.splice(idx, 1);
  }
  saveState();
}

// Split a list into { staples, regular }, keeping the original index
function splitIngredientsByStaples(ingredients) {
  const staples = [];
  const regular = [];
  (ingredients || []).forEach((ing, index) => {
    if (!ing || !ing.name) return;
    const bucket = isStapleIngredient(ing.name) ? staples : regular;
    bucket.push({ ing, index }); // remember which ingredient it was
  });
  return { staples, regular };
}

        function tidyRecipeTitle(str) {
      if (!str) return "";
      let t = str.trim();
      // Strip trailing " - BBC Food" / " - BBC Good Food"
      t = t.replace(/\s*-\s*BBC\s*Food\s*$/i, "");
      t = t.replace(/\s*-\s*BBC\s*Good\s*Food\s*$/i, "");
      return t;
    }

    function parseServingsNumber(servingsText) {
      if (!servingsText) return null;
      // Look for the first number: "Serves 8-10" -> 8
      const m = servingsText.match(/(\d+)/);
      if (!m) return null;
      const n = parseInt(m[1], 10);
      return Number.isNaN(n) ? null : n;
    }

    // ---------- VERY SIMPLE PARSER FOR IMPORT ----------

function parseBbcIngredient(rawLine, ingredientNames) {
  const line = (rawLine || "").trim();
  if (!line) return null;

  // Normalise long-form units so we can match them
  let normLine = line
    .replace(/grams?/gi, "g")
    .replace(/millilitres?|milliliters?/gi, "ml")
    .replace(/litres?|liters?/gi, "l")
    .replace(/tablespoons?/gi, "tbsp")
    .replace(/teaspoons?/gi, "tsp");

  const lower = normLine.toLowerCase();

  // --- 1. Find the best matching ingredient name from ingredientNames ---
  let bestName = null;
  let bestIndex = -1;
  let bestLen = 0;

  (ingredientNames || []).forEach((name) => {
    const nLower = name.toLowerCase();
    const idx = lower.indexOf(nLower);
    if (idx !== -1 && nLower.length > bestLen) {
      bestName = name;
      bestIndex = idx;
      bestLen = nLower.length;
    }
  });

  // If we can‚Äôt find a clean name, fall back to the generic parser
  if (!bestName) {
    return parseIngredientLine(normLine);
  }

  const before = normLine.slice(0, bestIndex).trim(); // text before name
  const after  = normLine.slice(bestIndex + bestName.length).trim(); // text after

  let quantity = 0;
  let unit = "";

  // Only care about the *first* metric ‚Äì drop anything after a slash
  let qtyText = before;
  if (qtyText.includes("/")) {
    qtyText = qtyText.split("/")[0].trim(); // "1.2 l/2 pints" -> "1.2 l"
  }

  // --- 2. Pattern: "2 x 400g tins" -> 800 g ---
  let m = qtyText.match(
    /(\d+(?:\.\d+)?)\s*[x√ó]\s*(\d+(?:\.\d+)?)\s*(g|kg|ml|l)\b/i
  );
  if (m) {
    const count = parseFloat(m[1]);
    const size  = parseFloat(m[2]);
    let u       = m[3].toLowerCase();

    let baseQty = count * size; // e.g. 2 * 400 = 800

    if (u === "kg") {
      baseQty *= 1000;
      u = "g";
    } else if (u === "l") {
      baseQty *= 1000;
      u = "ml";
    }

    quantity = baseQty;
    unit     = u;
  } else {
    // --- 3. Metric stuck to the number, like "900g" or "150ml" ---
    let m2 = qtyText.match(/(\d+(?:\.\d+)?)(g|kg|ml|l)\b/i);
    if (m2) {
      quantity = parseFloat(m2[1]);
      unit = m2[2].toLowerCase();

      if (unit === "kg") {
        quantity *= 1000;
        unit = "g";
      } else if (unit === "l") {
        quantity *= 1000;
        unit = "ml";
      }
    } else {
      // --- 4. "number unit" with a space, like "2 tbsp" or "1.2 l" ---
      const numMatch  = qtyText.match(/(\d+(?:\.\d+)?)/);
      const unitMatch = qtyText.match(/\b(g|kg|ml|l|tsp|tbsp)\b/i);

      if (numMatch) {
        quantity = parseFloat(numMatch[1]);
      }
      if (unitMatch) {
        unit = unitMatch[1].toLowerCase();
        if (unit === "kg") {
          quantity *= 1000;
          unit = "g";
        } else if (unit === "l") {
          quantity *= 1000;
          unit = "ml";
        }
      }

      // --- 5. Wordy units like "cloves", "sticks", "tins" ---
      if (!unit && quantity > 0) {
        const unitWords = [
          "clove", "cloves",
          "stick", "sticks",
          "tin", "tins",
          "packet", "packets",
          "pack", "packs"
        ];

        if (after) {
          const firstWord = after
            .split(/[ ,()]/)
            .filter(Boolean)[0];
          if (firstWord && unitWords.includes(firstWord.toLowerCase())) {
            unit = firstWord.toLowerCase();
          }
        }
      }

      // No number at all (e.g. salt/pepper line) ‚Üí assume 1
      if (!numMatch) {
        quantity = 1;
      }
    }
  }

  return {
    name: titleCase(bestName),
    quantity,
    unit,
  };
}
    
    function parseIngredientLine(line) {
  let trimmed = line.trim();
  if (!trimmed) return null;

  // Normalise common long-form units to short ones
  let cleaned = trimmed
    .replace(/grams?/gi, "g")
    .replace(/millilitres?|milliliters?/gi, "ml")
    .replace(/litres?|liters?/gi, "l")
    .replace(/tablespoons?/gi, "tbsp")
    .replace(/teaspoons?/gi, "tsp");

  // Strip trailing notes after comma (e.g. ", sliced", ", finely chopped")
  const commaIndex = cleaned.indexOf(",");
  if (commaIndex !== -1) cleaned = cleaned.slice(0, commaIndex).trim();

  const parts = cleaned.split(/\s+/);
  if (!parts.length) return null;

  // Map lots of unit spellings ‚Üí short forms
  const unitMap = {
    g: "g",
    kg: "kg",
    ml: "ml",
    l: "l",

    tsp: "tsp",
    tbsp: "tbsp",

    pack: "pack",
    packs: "packs",

    clove: "clove",
    cloves: "cloves",

    stick: "stick",
    sticks: "sticks",
  };

  // Words we DON'T want to keep at the start of the ingredient name
  const noiseWords = new Set([
    "pint", "pints",
    "cup", "cups",
    "level", "heaped",
    "large", "small", "medium"
  ]);

  let quantity;
  let unit = "";
  let nameWords = [];

  const first = parts[0];

  // 1) Try "inline unit" in first token, e.g. "150ml", "225g"
  const inlineMatch = first.match(/^([\d.]+)([a-zA-Z]+)$/);
  if (inlineMatch) {
    quantity = parseFloat(inlineMatch[1]);
    if (isNaN(quantity) || quantity <= 0) {
      return { name: titleCase(trimmed), quantity: 1, unit: "" };
    }
    const unitRaw = inlineMatch[2].toLowerCase();
    const unitClean = unitRaw.replace(/[^a-z]/g, ""); // strip odd chars
    unit = unitMap[unitClean] || "";
    nameWords = parts.slice(1);
  } else {
    // 2) Normal case: first token is just the number, second is (maybe) the unit
    quantity = parseFloat(first);
    if (isNaN(quantity) || quantity <= 0) {
      // No leading number ‚Üí treat whole line as name
      return { name: titleCase(trimmed), quantity: 1, unit: "" };
    }

    if (parts.length === 1) {
      // Just "2" or "500" etc.
      return { name: "", quantity, unit: "" };
    }

    const secondRaw = parts[1].toLowerCase();
    const unitClean = secondRaw.replace(/[^a-z]/g, ""); // e.g. "l/2" ‚Üí "l"

    if (unitMap[unitClean]) {
      unit = unitMap[unitClean];
      nameWords = parts.slice(2);
    } else {
      unit = "";
      nameWords = parts.slice(1);
    }
  }

  // Strip leading noise words from the ingredient name
  while (nameWords.length && noiseWords.has(nameWords[0].toLowerCase())) {
    nameWords.shift();
  }

  return {
    name: titleCase(nameWords.join(" ")),
    quantity,
    unit,
  };
}

    // ---------- STATE ----------

    const STORAGE_KEY = "pantryApp_simple_v1";

    let inventory = [];
    let recipes = [];
    let mealPlan = [];
    let barcodeMap = {}; // barcode -> {name, baseQty, unit}

    let inventoryFilter = "";
    let editingInventoryKey = null;

    let currentRecipe = null;
    let editingRecipeId = null;
    let editingIngredientIndex = null;

    let lastImportedRecipeMeta = null; // { instructions: [...], sourceUrl, servingsText }

    function initDefaultMealPlan() {
      const days = [
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday",
        "Sunday",
      ];
      mealPlan = days.map((d) => ({
        dayId: d.toLowerCase(),
        dayLabel: d,
        recipeId: "",
        servings: 0,
      }));
    }

 function loadState() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) {
      initDefaultMealPlan();
      return;
    }
    const data = JSON.parse(raw);
    if (Array.isArray(data.inventory)) inventory = data.inventory;
    if (Array.isArray(data.recipes)) recipes = data.recipes;
    if (Array.isArray(data.mealPlan)) mealPlan = data.mealPlan;

    // user staples
    if (Array.isArray(data.userStaples)) {
      userStaples = data.userStaples
        .map((n) => String(n).toLowerCase().trim())
        .filter(Boolean);
    } else {
      userStaples = [];
    }

    // --- migrate barcodeMap into the new "array of names" shape ---
    barcodeMap = {};
    if (data.barcodeMap && typeof data.barcodeMap === "object") {
      Object.keys(data.barcodeMap).forEach((code) => {
        const entry = data.barcodeMap[code];

        if (Array.isArray(entry)) {
          // already new-style
          barcodeMap[code] = entry.slice();
        } else if (entry && typeof entry === "object" && entry.name) {
          // old-style { name, baseQty, unit }
          barcodeMap[code] = [titleCase(entry.name)];
        }
        // anything else is ignored
      });
    }

    if (!mealPlan || !mealPlan.length) initDefaultMealPlan();
  } catch {
    initDefaultMealPlan();
  }
}

function saveState() {
  try {
    localStorage.setItem(
      STORAGE_KEY,
      JSON.stringify({
        inventory,
        recipes,
        mealPlan,
        barcodeMap,
        userStaples      // ‚¨ÖÔ∏è persist user staples
      })
    );
  } catch (e) {
    console.error("Failed to save", e);
  }
}

    // ---------- INVENTORY ----------

    function upsertInventoryItem(name, quantity, unit) {
      const cleanName = titleCase(name.trim());
      const key = cleanName.toLowerCase();
      let item = inventory.find((i) => i.key === key);

      if (!item) {
        item = { key, name: cleanName, quantity, unit };
        normalizeInventoryItem(item);
        inventory.push(item);
      } else {
        const baseUnit = item.unit || unit;
        const converted = convertToUnit(quantity, unit, baseUnit);
        if (!item.unit && unit) item.unit = unit;
        item.quantity += converted;
        normalizeInventoryItem(item);
      }
    }

    function setInventoryItemExact(originalKey, name, quantity, unit) {
      const cleanName = titleCase(name.trim());
      const newKey = cleanName.toLowerCase();
      let item = inventory.find((i) => i.key === originalKey);

      if (!item) {
        item = { key: newKey, name: cleanName, quantity, unit };
        normalizeInventoryItem(item);
        inventory.push(item);
      } else {
        item.name = cleanName;
        item.key = newKey;
        item.quantity = quantity;
        item.unit = unit;
        normalizeInventoryItem(item);
      }
    }

    // Deduct a quantity of an ingredient from inventory by name.
// qtyBase is in baseUnit (g/ml/whatever chooseBaseUnit returned).
function deductInventoryForCooking(name, qtyBase, baseUnit) {
  if (!name || !qtyBase || qtyBase <= 0) return;

  const key = name.toLowerCase();
  const item = inventory.find((i) => i.name.toLowerCase() === key);
  if (!item) {
    // Caller handles "not found" confirmation
    return false;
  }

  // Decide a common base unit between ingredient + inventory
  const invUnit = item.unit || "";
  const base = baseUnit || chooseBaseUnit(invUnit);

  // Current inventory in base units
  let invQtyBase = convertToUnit(item.quantity, invUnit, base);

  // Deduct
  let newBase = invQtyBase - qtyBase;
  if (newBase <= 0.0001) {
    // Effectively used it all up ‚Üí remove item
    deleteInventoryItem(item.key);
  } else {
    // Convert back into the item's original unit
    const newQty = convertToUnit(newBase, base, invUnit || "");
    item.quantity = newQty;
    normalizeInventoryItem(item);
  }

  return true;
}

    function deleteInventoryItem(key) {
      inventory = inventory.filter((i) => i.key !== key);
    }

    function renderInventoryNameSuggestions() {
      const dl = document.getElementById("inv-name-list");
      if (!dl) return;
      dl.innerHTML = "";
      inventory
        .slice()
        .sort((a, b) => a.name.localeCompare(b.name))
        .forEach((item) => {
          const opt = document.createElement("option");
          opt.value = item.name;
          dl.appendChild(opt);
        });
    }

    function attachInventorySwipe(row, item) {
  let startX = 0;
  let startY = 0;
  let activeId = null;
  let swiping = false;

  function resetTransform() {
    row.style.transition = "transform 0.15s ease-out";
    row.style.transform = "translateX(0)";
    setTimeout(() => {
      row.style.transition = "";
    }, 160);
  }

  row.addEventListener("pointerdown", (e) => {
    activeId = e.pointerId;
    startX = e.clientX;
    startY = e.clientY;
    swiping = true;
    row.setPointerCapture(activeId);
  });

  row.addEventListener("pointermove", (e) => {
    if (!swiping || e.pointerId !== activeId) return;

    const dx = e.clientX - startX;
    const dy = e.clientY - startY;

    // If vertical movement dominates, treat it as scroll and cancel swipe
    if (Math.abs(dy) > Math.abs(dx)) {
      swiping = false;
      row.releasePointerCapture(activeId);
      resetTransform();
      return;
    }

    // Limit how far the row slides
    const clamped = Math.max(-80, Math.min(80, dx));
    row.style.transform = `translateX(${clamped}px)`;
  });

  function endSwipe(e) {
    if (!swiping || e.pointerId !== activeId) return;
    swiping = false;
    row.releasePointerCapture(activeId);

    const dx = e.clientX - startX;
    const threshold = 60; // how far you need to swipe

    resetTransform();

    if (dx > threshold) {
      // ‚û°Ô∏è swipe right ‚Üí edit
      startInventoryEdit(item.key);
    } else if (dx < -threshold) {
      // ‚¨ÖÔ∏è swipe left ‚Üí delete
      if (confirm(`Delete ${item.name} from inventory?`)) {
        deleteInventoryItem(item.key);
        if (editingInventoryKey === item.key) clearInventoryEditState();
        renderInventory();
        renderInventoryNameSuggestions();
        saveState();
      }
    }
  }

  row.addEventListener("pointerup", endSwipe);
  row.addEventListener("pointercancel", endSwipe);

  row.addEventListener("pointerleave", () => {
    if (!swiping) return;
    swiping = false;
    resetTransform();
  });
}

function formatItemNameForDisplay(str) {
  if (!str) return "";

  return str
    .toLowerCase()
    .split(/\s+/)  // split on any whitespace
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(" ");
}

function renderInventory() {
  const container = document.getElementById("inventory-list");
  if (!container) return;
  container.innerHTML = "";

  const filter = (inventoryFilter || "").toLowerCase();

  inventory
    .slice()
    .sort((a, b) => a.name.localeCompare(b.name))
    .forEach((item) => {
      if (filter && !item.name.toLowerCase().includes(filter)) return;

      const row = document.createElement("div");
      row.className = "inventory-item";

      // Left side: name + quantity on two lines
      const main = document.createElement("div");
      main.className = "inventory-item-main";

      const nameEl = document.createElement("div");
      nameEl.className = "inventory-item-name";
      nameEl.textContent = formatItemNameForDisplay(item.name);

      const qtyEl = document.createElement("div");
      qtyEl.className = "inventory-item-qty";
      qtyEl.textContent = formatQuantityWithUnit(
        item.quantity,
        item.unit || ""
      );

      main.appendChild(nameEl);
      main.appendChild(qtyEl);
      row.appendChild(main);

      // Right side: icon buttons
      const actions = document.createElement("div");
      actions.className = "inventory-actions";

      // Edit
     const editBtn = document.createElement("button");
editBtn.type = "button";
editBtn.className = "inventory-edit-btn";
editBtn.textContent = "Edit";
editBtn.addEventListener("click", () => {
  openAddInventoryItemDialog(item, {
    scannedBarcode: null,
    presetName: "",
  });
});

     // Delete
const delBtn = document.createElement("button");
delBtn.type = "button";
delBtn.className = "inventory-delete-button";
delBtn.title = "Delete";
delBtn.setAttribute("aria-label", "Delete item");
delBtn.textContent = "Delete";

delBtn.addEventListener("click", (e) => {
  e.stopPropagation();
  if (!confirm(`Delete ${item.name} from inventory?`)) return;

  deleteInventoryItem(item.key);
  if (editingInventoryKey === item.key) {
    clearInventoryEditState();
  }
  renderInventory();
  renderInventoryNameSuggestions();
  saveState();
});

      actions.appendChild(editBtn);
      actions.appendChild(delBtn);
      row.appendChild(actions);

      container.appendChild(row);
    });
}

    function startInventoryEdit(key) {
      const item = inventory.find((i) => i.key === key);
      if (!item) return;

      document.getElementById("inv-name").value = item.name;
      document.getElementById("inv-qty").value = item.quantity;
      document.getElementById("inv-unit").value = item.unit || "";

      document.getElementById("inventory-submit-btn").textContent =
        "Save changes";
      document
        .getElementById("inventory-cancel-edit")
        .classList.remove("hidden");
      editingInventoryKey = key;
    }

    function clearInventoryEditState() {
      document.getElementById("inv-name").value = "";
      document.getElementById("inv-qty").value = "1";
      document.getElementById("inv-unit").value = "";
      document.getElementById("inventory-submit-btn").textContent =
        "Add / Update";
      document
        .getElementById("inventory-cancel-edit")
        .classList.add("hidden");
      editingInventoryKey = null;
    }

        // ---------- BARCODE ‚Üí ITEM MAPPINGS (SIMPLE NAMES ONLY) ----------

function openAddInventoryItemDialog(existingItem = null, opts = {}) {
  const { scannedBarcode = null, presetName = "" } = opts || {};
  const isEditMode = !!existingItem;

  console.log("openAddInventoryItemDialog() called", {
    existingItem,
    scannedBarcode,
    presetName,
    isEditMode,
  });

  // Make sure the barcode map exists if we're in a barcode flow
  if (scannedBarcode) {
    window.barcodeMap = window.barcodeMap || {};
  }

  // Remove any previous overlay instantly (we only animate on close)
  const oldOverlay = document.getElementById("add-item-overlay");
  if (oldOverlay) oldOverlay.remove();

  // Overlay
  const overlay = document.createElement("div");
  overlay.id = "add-item-overlay";
  overlay.className = "barcode-scanner-overlay";

  // Panel
  const panel = document.createElement("div");
  panel.className = "barcode-scanner-panel add-item-panel";

  // Title
  const title = document.createElement("h2");
  title.textContent = isEditMode ? "Edit item" : "Add item";
  panel.appendChild(title);

  // ----- Item name row -----
  const nameRow = document.createElement("div");
  nameRow.className = "barcode-input-row";

  const nameLabel = document.createElement("label");
  nameLabel.textContent = "Item name";
  nameLabel.style.display = "block";

  const nameInput = document.createElement("input");
  nameInput.type = "text";
  nameInput.autocomplete = "off";
  nameInput.placeholder = "e.g. Beef mince";

  // Prefill priority: existingItem (edit) ‚Üí presetName (known barcode) ‚Üí blank
  if (existingItem) {
    nameInput.value = existingItem.name || "";
  } else if (presetName) {
    nameInput.value = presetName;
  } else {
    nameInput.value = "";
  }

  nameLabel.appendChild(nameInput);
  nameRow.appendChild(nameLabel);
  panel.appendChild(nameRow);

  // ----- Quantity row -----
  const qtyRow = document.createElement("div");
  qtyRow.className = "barcode-input-row";

  const qtyLabel = document.createElement("label");
  qtyLabel.textContent = "Quantity";
  qtyLabel.style.display = "block";

  const qtyInput = document.createElement("input");
  qtyInput.type = "number";
  qtyInput.inputMode = "decimal"; // iOS number keypad
  qtyInput.min = "0";
  qtyInput.step = "0.1";
  qtyInput.placeholder = "e.g. 500";

  if (existingItem && typeof existingItem.quantity === "number") {
    qtyInput.value = String(existingItem.quantity);
  } else {
    qtyInput.value = ""; // let placeholder show
  }

  qtyLabel.appendChild(qtyInput);
  qtyRow.appendChild(qtyLabel);
  panel.appendChild(qtyRow);

  // ----- Unit row -----
  const unitRow = document.createElement("div");
  unitRow.className = "barcode-input-row";

  const unitLabel = document.createElement("label");
  unitLabel.textContent = "Unit";
  unitLabel.style.display = "block";

  const unitSelect = document.createElement("select");
  const units = ["", "g", "kg", "ml", "l", "pack", "packs", "pcs"];

  units.forEach((u) => {
    const opt = document.createElement("option");
    opt.value = u;
    opt.textContent = u || "(none)";
    unitSelect.appendChild(opt);
  });

  if (existingItem && existingItem.unit) {
    unitSelect.value = existingItem.unit;
  }

  unitLabel.appendChild(unitSelect);
  unitRow.appendChild(unitLabel);
  panel.appendChild(unitRow);

  // ----- Buttons row -----
  const btnRow = document.createElement("div");
  btnRow.className = "barcode-scanner-actions";

  const cancelBtn = document.createElement("button");
  cancelBtn.type = "button";
  cancelBtn.className = "secondary";
  cancelBtn.textContent = "Cancel";
  cancelBtn.addEventListener("click", () => {
    animateCloseAddItemDialog(480);
  });

  const addBtn = document.createElement("button");
  addBtn.type = "button";
  addBtn.textContent = isEditMode ? "Save changes" : "Add item";
  addBtn.addEventListener("click", () => {
    const rawName = nameInput.value.trim();
    const qty = parseFloat(qtyInput.value || "0");
    const unit = unitSelect.value || "";

    if (!rawName) {
      alert("Please enter an item name.");
      nameInput.focus();
      return;
    }
    if (!qty || qty <= 0 || Number.isNaN(qty)) {
      alert("Please enter a valid quantity.");
      qtyInput.focus();
      return;
    }

    // üßº Normalise/capitalise name (all words)
    const name = titleCase ? titleCase(rawName) : rawName;

    if (isEditMode && existingItem) {
      // ‚úÖ TRUE EDIT: overwrite this specific row instead of merging
      const keyToUpdate = existingItem.key;
      const idx = inventory.findIndex((i) => i.key === keyToUpdate);

      if (idx !== -1) {
        inventory[idx] = {
          ...inventory[idx],
          name,
          quantity: qty,
          unit,
        };
      }
      // Note: no barcodeMap changes here; this came from Edit, not a scan
    } else {
      // ‚ûï NEW ITEM FLOW (manual add OR barcode add)
      upsertInventoryItem(name, qty, unit);

      // If this came from a barcode scan, update barcodeMap
      if (scannedBarcode) {
        const map = (window.barcodeMap = window.barcodeMap || {});
        let names = map[scannedBarcode];

        if (!names) {
          // First time we've seen this barcode
          map[scannedBarcode] = name;
        } else if (Array.isArray(names)) {
          // Already an array of names
          if (!names.includes(name)) names.push(name);
        } else {
          // Was a single string, convert to array if different
          if (names !== name) {
            map[scannedBarcode] = [names, name];
          }
        }
      }
    }

    renderInventory();
    renderInventoryNameSuggestions();
    saveState();

    animateCloseAddItemDialog(480);
  });

  btnRow.appendChild(cancelBtn);
  btnRow.appendChild(addBtn);
  panel.appendChild(btnRow);

  overlay.appendChild(panel);
  document.body.appendChild(overlay);

  // Smooth "pop" in
  requestAnimationFrame(() => {
    overlay.classList.add("is-visible");
    panel.classList.add("visible");
  });

  // Focus without page jump
  setTimeout(() => {
    if (nameInput.focus) {
      nameInput.focus({ preventScroll: true });
    }
  }, 40);

  // Tap outside to close
  overlay.addEventListener("click", (evt) => {
    if (evt.target === overlay) {
      animateCloseAddItemDialog(480);
    }
  });

  // Keyboard-aware positioning (only if helper exists)
  if (typeof attachAddItemKeyboardShim === "function") {
    attachAddItemKeyboardShim(panel);
  }
}

function animateCloseAddItemDialog(durationMs = 480) {
  const overlay = document.getElementById("add-item-overlay");
  if (!overlay) {
    console.log("No add-item-overlay to close");
    return;
  }

  // Fade out overlay + panel
  overlay.classList.remove("is-visible");

  const panel = overlay.querySelector(".add-item-panel");
  if (panel) {
    panel.classList.remove("visible");
  }

  // After animation, remove from DOM
  setTimeout(() => {
    const current = document.getElementById("add-item-overlay");
    if (current && current.parentNode) {
      current.parentNode.removeChild(current);
    }
  }, durationMs);
}

    // ---------- RECIPES ----------

function renderCurrentRecipeIngredients() {
  const ul = document.getElementById("current-recipe-ingredients");
  if (!ul) return;
  ul.innerHTML = "";

  if (!currentRecipe || !Array.isArray(currentRecipe.ingredients)) return;

  currentRecipe.ingredients.forEach((ing, index) => {
    const li = document.createElement("li");

    const textSpan = document.createElement("span");
    let label = ing.name || "";

    let q = ing.quantity;
    let u = ing.unit || "";

    // auto-compact to kg/l where appropriate
    if (q && q > 0) {
      ({ quantity: q, unit: u } = autoCompactQuantityUnit(q, u));

      const compactUnits = ["g", "kg", "ml", "l"];
      const unitLower = (u || "").toLowerCase();

      if (compactUnits.includes(unitLower)) {
        label += `: ${q}${unitLower}`;
      } else if (unitLower) {
        label += `: ${q} ${unitLower}`;
      } else {
        label += `: ${q}`;
      }
    }

    textSpan.textContent = label;
    li.appendChild(textSpan);

    const actions = document.createElement("div");
    actions.className = "table-actions";

    const editBtn = document.createElement("button");
    editBtn.type = "button";
    editBtn.className = "secondary";
    editBtn.textContent = "Edit";
    editBtn.addEventListener("click", () => startIngredientEdit(index));

    const delBtn = document.createElement("button");
    delBtn.type = "button";
    delBtn.className = "secondary";
    delBtn.textContent = "Delete";
    delBtn.addEventListener("click", () => {
      currentRecipe.ingredients.splice(index, 1);
      renderCurrentRecipeIngredients();
    });

    actions.appendChild(editBtn);
    actions.appendChild(delBtn);
    li.appendChild(actions);
    ul.appendChild(li);
  });
}

    function startIngredientEdit(index) {
      if (!currentRecipe || !currentRecipe.ingredients[index]) return;
      const ing = currentRecipe.ingredients[index];

      document.getElementById("ing-name").value = ing.name;
      document.getElementById("ing-qty").value = ing.quantity;
      document.getElementById("ing-unit").value = ing.unit;

      document.getElementById("ingredient-submit-btn").textContent =
        "Save ingredient";
      document
        .getElementById("cancel-ingredient-edit")
        .classList.remove("hidden");
      editingIngredientIndex = index;
    }

    function clearIngredientEditState() {
      document.getElementById("ing-name").value = "";
      document.getElementById("ing-qty").value = "1";
      document.getElementById("ing-unit").value = "";
      document.getElementById("ingredient-submit-btn").textContent =
        "Add ingredient";
      document
        .getElementById("cancel-ingredient-edit")
        .classList.add("hidden");
      editingIngredientIndex = null;
    }

    function clearRecipeEditState() {
      editingRecipeId = null;
      currentRecipe = null;
      document.getElementById("recipe-name").value = "";
      document.getElementById("recipe-servings").value = "2";
      document.getElementById("current-recipe-ingredients").innerHTML = "";
      document
        .getElementById("recipe-ingredients-section")
        .classList.add("hidden");
      document
        .getElementById("cancel-recipe-edit")
        .classList.add("hidden");
      clearIngredientEditState();
    }

        function renderRecipesList() {
  const container = document.getElementById("recipes-list");
  if (!container) return;
  container.innerHTML = "";

  if (!recipes.length) {
    container.textContent = "No recipes saved yet.";
    return;
  }

  const grid = document.createElement("div");
  grid.className = "recipe-grid";

  recipes.forEach((r) => {
    const card = document.createElement("article");
    card.className = "recipe-card";
    card.dataset.recipeId = r.id;

      // Thumbnail
    const thumb = document.createElement("div");
    thumb.className = "recipe-card-thumb";
    if (r.imageUrl) {
      const img = document.createElement("img");
      img.src = r.imageUrl;
      img.alt = r.name;
      thumb.appendChild(img);
    } else {
      const placeholder = document.createElement("div");
      placeholder.className = "recipe-card-placeholder";
      placeholder.textContent = (r.name || "R")
        .charAt(0)
        .toUpperCase();
      thumb.appendChild(placeholder);
    }

    // NEW: clicking the image/placeholder opens the detail view
    thumb.style.cursor = "pointer";
    thumb.addEventListener("click", () => openRecipeDetail(r.id));

    card.appendChild(thumb);

    // Body
    const body = document.createElement("div");
    body.className = "recipe-card-body";

    const title = document.createElement("h3");
    title.className = "recipe-card-title";
    title.textContent = r.name;
    body.appendChild(title);

    const meta = document.createElement("p");
    meta.className = "recipe-card-meta";
    meta.textContent = r.servings
      ? `Serves ${r.servings}`
      : "Servings not set";
    body.appendChild(meta);

    card.appendChild(body);

    // Footer buttons (Edit + Delete only)
    const footer = document.createElement("div");
    footer.className = "recipe-card-footer";

    const editBtn = document.createElement("button");
    editBtn.type = "button";
    editBtn.className = "secondary";
    editBtn.textContent = "Edit";
    editBtn.addEventListener("click", () => {
      startRecipeEdit(r.id);
    });

    const delBtn = document.createElement("button");
    delBtn.type = "button";
    delBtn.className = "secondary";
    delBtn.textContent = "Delete";
    delBtn.addEventListener("click", () => {
      if (confirm(`Delete recipe "${r.name}"?`)) {
        recipes = recipes.filter((x) => x.id !== r.id);
        mealPlan.forEach((entry) => {
          if (entry.recipeId === r.id) {
            entry.recipeId = "";
            entry.servings = 0;
          }
        });
        renderRecipesList();
        renderMealPlan();
        saveState();
      }
    });

    footer.appendChild(editBtn);
    footer.appendChild(delBtn);
    card.appendChild(footer);

    grid.appendChild(card);
  });

  container.appendChild(grid);

  // keep meal plan dropdowns in sync
  renderMealPlan();
}

// Simple long-press helper
function attachIngredientLongPress(li, recipeId, ingredientIndex, ingredientName) {
  let pressTimer = null;

  // ‚ùå Stop the browser selecting text on long-press
  li.style.userSelect = "none";
  li.style.webkitUserSelect = "none";

  const start = (event) => {
    event.preventDefault();
    if (pressTimer !== null) return;

    pressTimer = setTimeout(() => {
      pressTimer = null;
      openIngredientContextMenu(recipeId, ingredientIndex, ingredientName);
    }, 450); // ~0.45s long press
  };

  const cancel = () => {
    if (pressTimer !== null) {
      clearTimeout(pressTimer);
      pressTimer = null;
    }
  };

  li.addEventListener("pointerdown", start);
  li.addEventListener("pointerup", cancel);
  li.addEventListener("pointerleave", cancel);
  li.addEventListener("pointercancel", cancel);
}

// Small popup for "Staple / Edit / Delete"
function openIngredientContextMenu(recipeId, ingredientIndex, ingredientName) {
  const recipe = recipes.find((r) => r.id === recipeId);
  if (!recipe) return;

  const overlay = document.createElement("div");
  overlay.className = "recipe-detail-overlay"; // reuse dim background

  const panel = document.createElement("div");
  panel.className = "recipe-detail-panel";
  panel.style.maxWidth = "320px";

  const title = document.createElement("h3");
  title.textContent = ingredientName;
  panel.appendChild(title);

  // --- Staple toggle button ---
  const stapleBtn = document.createElement("button");
  stapleBtn.type = "button";

  const currentlyStaple = isStapleIngredient(ingredientName);
  stapleBtn.textContent = currentlyStaple
    ? "Remove from staples"
    : "Mark as staple";

  stapleBtn.addEventListener("click", () => {
    toggleUserStaple(ingredientName);
    overlay.remove();
    // Re-open the detail view so the ingredient jumps into / out of the staples section
    openRecipeDetail(recipeId);
  });

  // --- Edit ingredient button ---
  const editBtn = document.createElement("button");
  editBtn.type = "button";
  editBtn.className = "secondary";
  editBtn.textContent = "Edit ingredient";
  editBtn.addEventListener("click", () => {
    overlay.remove();
    showPage("page-recipes");
    startRecipeEdit(recipeId, ingredientIndex); // jump straight to that ingredient
  });

  // --- Delete ingredient button ---
  const deleteBtn = document.createElement("button");
  deleteBtn.type = "button";
  deleteBtn.className = "secondary";
  deleteBtn.textContent = "Delete ingredient";
  deleteBtn.addEventListener("click", () => {
    const ok = confirm(`Remove "${ingredientName}" from this recipe?`);
    if (!ok) return;

    if (
      Array.isArray(recipe.ingredients) &&
      ingredientIndex >= 0 &&
      ingredientIndex < recipe.ingredients.length
    ) {
      recipe.ingredients.splice(ingredientIndex, 1);
      saveState();
    }
    overlay.remove();
    openRecipeDetail(recipeId);
  });

  // --- Cancel button ---
  const closeBtn = document.createElement("button");
  closeBtn.type = "button";
  closeBtn.className = "secondary";
  closeBtn.textContent = "Cancel";
  closeBtn.addEventListener("click", () => overlay.remove());

  panel.appendChild(stapleBtn);
  panel.appendChild(editBtn);
  panel.appendChild(deleteBtn);
  panel.appendChild(closeBtn);

  overlay.appendChild(panel);

  // Close if you tap outside the panel
  overlay.addEventListener("click", (e) => {
    if (e.target === overlay) overlay.remove();
  });

  document.body.appendChild(overlay);
}

function openRecipeDetail(recipeId) {
  const recipe = recipes.find((r) => r.id === recipeId);
  if (!recipe) return;

  const recipeIdActual = recipe.id;

  // Work on a copy so we don't mutate the underlying recipe
  const ingForDisplay = (recipe.ingredients || []).slice();

  // If any ingredient mentions black pepper but none mentions salt,
  // add a synthetic "Salt" line (staple, shown as "to taste").
  const hasBlackPepper = ingForDisplay.some(
    (ing) => ing.name && ing.name.toLowerCase().includes("black pepper")
  );
  const hasAnySalt = ingForDisplay.some(
    (ing) => ing.name && ing.name.toLowerCase().includes("salt")
  );

  if (hasBlackPepper && !hasAnySalt) {
    ingForDisplay.push({
      name: "Salt",
      quantity: null,
      unit: ""
    });
  }

  const overlay = document.createElement("div");
  overlay.className = "recipe-detail-overlay";

  const panel = document.createElement("div");
  panel.className = "recipe-detail-panel";

  // Close button
  const closeBtn = document.createElement("button");
  closeBtn.type = "button";
  closeBtn.className = "recipe-detail-close";
  closeBtn.textContent = "Close";
  closeBtn.addEventListener("click", () => overlay.remove());
  panel.appendChild(closeBtn);

  // Title
  const title = document.createElement("h2");
  title.className = "recipe-detail-title";
  title.textContent = recipe.name;
  panel.appendChild(title);

  // Image
  if (recipe.imageUrl) {
    const imgWrap = document.createElement("div");
    imgWrap.className = "recipe-detail-image-wrap";
    const img = document.createElement("img");
    img.src = recipe.imageUrl;
    img.alt = recipe.name;
    imgWrap.appendChild(img);
    panel.appendChild(imgWrap);
  }

  // Meta
  const meta = document.createElement("p");
  meta.className = "recipe-detail-meta";
  meta.textContent = recipe.servings ? `Serves ${recipe.servings}` : "";
  panel.appendChild(meta);

  // ---- Ingredients section ----
  const ingTitle = document.createElement("h3");
  ingTitle.textContent = "Ingredients";
  panel.appendChild(ingTitle);

  // Use the indexed split so we know which ingredient to edit/delete
  const { staples, regular } = splitIngredientsByStaples(ingForDisplay);

  function addIngredientLi(ul, obj, isStapleList) {
    const { ing, index } = obj;
    const li = document.createElement("li");

    // Name
    const nameSpan = document.createElement("span");
    nameSpan.textContent = ing.name || "";
    li.appendChild(nameSpan);

    let q = ing.quantity;
    let u = ing.unit || "";
    const hasNumericQty = q && q > 0;

    if (hasNumericQty) {
      ({ quantity: q, unit: u } = autoCompactQuantityUnit(q, u));

      const compactUnits = ["g", "kg", "ml", "l"];
      const unitLower = (u || "").toLowerCase();
      const qtySpan = document.createElement("span");

      let label = ": ";
      if (compactUnits.includes(unitLower)) {
        label += `${q}${unitLower}`;
      } else if (unitLower) {
        label += `${q} ${unitLower}`;
      } else {
        label += `${q}`;
      }

      qtySpan.textContent = label;
      li.appendChild(qtySpan);
    } else if (isStapleList) {
      // No numeric quantity, and it's in the staples section ‚Üí "to taste" in italics
      const sep = document.createTextNode(": ");
      const em = document.createElement("em");
      em.textContent = "to taste";
      li.appendChild(sep);
      li.appendChild(em);
    }

    // Attach long-press menu (Staple / Edit / Delete)
    attachIngredientLongPress(li, recipeIdActual, index, ing.name);

    ul.appendChild(li);
  }

  // Non-staple ingredients
  const ingList = document.createElement("ul");
  ingList.className = "recipe-detail-ingredients";
  regular.forEach((obj) => addIngredientLi(ingList, obj, false));
  panel.appendChild(ingList);

  // Staples: "Make sure you have" (italic heading)
  if (staples.length) {
    const staplesTitle = document.createElement("h3");
    staplesTitle.innerHTML = "<em>Make sure you have</em>";
    panel.appendChild(staplesTitle);

    const staplesList = document.createElement("ul");
    staplesList.className = "recipe-detail-ingredients";
    staples.forEach((obj) => addIngredientLi(staplesList, obj, true));
    panel.appendChild(staplesList);
  }

  // ---- Method ----
  const instrTitle = document.createElement("h3");
  instrTitle.textContent = "Method";
  panel.appendChild(instrTitle);

  const instrList = document.createElement("ol");
  instrList.className = "recipe-detail-instructions";
  if (Array.isArray(recipe.instructions) && recipe.instructions.length) {
    recipe.instructions.forEach((step) => {
      const li = document.createElement("li");
      li.textContent = step;
      instrList.appendChild(li);
    });
  } else {
    const li = document.createElement("li");
    li.textContent = "No method stored yet.";
    instrList.appendChild(li);
  }
  panel.appendChild(instrList);

  // Source link (if we have it)
  if (recipe.sourceUrl) {
    const link = document.createElement("a");
    link.className = "recipe-detail-source";
    link.href = recipe.sourceUrl;
    link.target = "_blank";
    link.rel = "noopener noreferrer";
    link.textContent = "View original recipe on BBC";
    panel.appendChild(link);
  }

  overlay.appendChild(panel);
  document.body.appendChild(overlay);

  // Close if you tap the dim background
  overlay.addEventListener("click", (e) => {
    if (e.target === overlay) overlay.remove();
  });
}

    // ----- COOK MODE: tick ingredients to deduct from inventory -----

function openCookDialog(dayId) {
  const entry = mealPlan.find((d) => d.dayId === dayId);
  if (!entry || !entry.recipeId) {
    alert("No recipe selected for this day.");
    return;
  }

  const recipe = recipes.find((r) => r.id === entry.recipeId);
  if (!recipe) {
    alert("Recipe not found.");
    return;
  }
  if (!recipe.ingredients || !recipe.ingredients.length) {
    alert("This recipe has no ingredients saved yet.");
    return;
  }

  // Default servings = planned servings, or recipe base if 0
  const defaultServings =
    entry.servings && entry.servings > 0 ? entry.servings : recipe.servings || 1;

  // Build overlay
  const overlay = document.createElement("div");
  overlay.className = "recipe-detail-overlay cook-overlay";

  const panel = document.createElement("div");
  panel.className = "recipe-detail-panel";

  // Close button
  const closeBtn = document.createElement("button");
  closeBtn.type = "button";
  closeBtn.className = "recipe-detail-close";
  closeBtn.textContent = "Close";
  closeBtn.addEventListener("click", () => overlay.remove());
  panel.appendChild(closeBtn);

  // Title
  const title = document.createElement("h2");
  title.textContent = `Cook: ${recipe.name}`;
  panel.appendChild(title);

  // Servings chooser
  const servingsLabel = document.createElement("label");
  servingsLabel.textContent = "How many servings are you cooking?";
  servingsLabel.style.display = "block";

  const servingsInput = document.createElement("input");
  servingsInput.type = "number";
  servingsInput.min = "1";
  servingsInput.step = "1";
  servingsInput.value = String(defaultServings);
  servingsInput.style.marginTop = "0.5rem";

  servingsLabel.appendChild(servingsInput);
  panel.appendChild(servingsLabel);

  // Container for ingredient checklist
  const ingSection = document.createElement("div");
  ingSection.className = "subpanel";
  ingSection.style.marginTop = "1rem";

  const ingHeading = document.createElement("h3");
  ingHeading.textContent = "Ingredients to use";
  ingSection.appendChild(ingHeading);

  const ingHelp = document.createElement("p");
  ingHelp.textContent =
    "Tick each ingredient as you get it out. Ticking will deduct it from your inventory.";
  ingSection.appendChild(ingHelp);

  const ingList = document.createElement("ul");
  ingList.className = "recipe-detail-ingredients";
  ingSection.appendChild(ingList);

  panel.appendChild(ingSection);

  // Bottom buttons
  const footer = document.createElement("div");
  footer.className = "barcode-scanner-actions"; // reuse nice flex styling if you have it

  const cancelBtn = document.createElement("button");
  cancelBtn.type = "button";
  cancelBtn.className = "secondary";
  cancelBtn.textContent = "Cancel";
  cancelBtn.addEventListener("click", () => overlay.remove());

  const finishBtn = document.createElement("button");
  finishBtn.type = "button";
  finishBtn.textContent = "Finish cooking";

  footer.appendChild(cancelBtn);
  footer.appendChild(finishBtn);

  panel.appendChild(footer);
  overlay.appendChild(panel);
  document.body.appendChild(overlay);

  // Close by tapping dark background
  overlay.addEventListener("click", (e) => {
    if (e.target === overlay) overlay.remove();
  });

  // Helper to render scaled ingredient list
  function renderCookIngredients() {
    ingList.innerHTML = "";

    const cookServings = parseFloat(servingsInput.value || "0");
    if (!cookServings || cookServings <= 0) return;

        const baseServings = recipe.servings && recipe.servings > 0 ? recipe.servings : 1;
    const scale = cookServings / baseServings;

    recipe.ingredients.forEach((ing) => {
      // Skip cupboard staples ‚Äì you don't deduct salt / pepper / oil / nutmeg, etc.
      if (isStapleIngredient(ing.name)) {
        return;
      }

      const li = document.createElement("li");
    
      const row = document.createElement("div");
      row.style.display = "flex";
      row.style.alignItems = "center";
      row.style.gap = "0.5rem";

      const cb = document.createElement("input");
      cb.type = "checkbox";

      // Work out scaled quantity + baseUnit for deduction
      let q = ing.quantity || 0;
      let u = ing.unit || "";
      let scaledQty = q * scale;

      const baseUnit = chooseBaseUnit(u);
      const qtyBase = convertToUnit(scaledQty, u, baseUnit);

      // Nicely formatted label
      let displayQty = scaledQty;
      let displayUnit = u;

      if (displayQty && (u === "g" || u === "ml") && displayQty >= 1000) {
        displayQty = displayQty / 1000;
        displayUnit = u === "g" ? "kg" : "l";
      }

      const compactUnits = ["g", "kg", "ml", "l"];
      const niceNum = Number.isInteger(displayQty)
        ? String(displayQty)
        : (Math.round(displayQty * 10) / 10).toString();
      let qtyStr = "";
      if (displayQty > 0) {
        if (!displayUnit) {
          qtyStr = niceNum;
        } else if (compactUnits.includes(displayUnit)) {
          qtyStr = niceNum + displayUnit;
        } else {
          qtyStr = niceNum + " " + displayUnit;
        }
      }

      const labelSpan = document.createElement("span");
      labelSpan.textContent = qtyStr
        ? `${ing.name}: ${qtyStr}`
        : ing.name;

      // Attach metadata for deduction
      cb.dataset.ingName = ing.name;
      cb.dataset.qtyBase = String(qtyBase);
      cb.dataset.baseUnit = baseUnit || "";

      cb.addEventListener("change", () => {
        if (!cb.checked || cb.dataset.applied === "true") return;

        const name = cb.dataset.ingName;
        const qtyBaseNum = parseFloat(cb.dataset.qtyBase || "0");
        const base = cb.dataset.baseUnit || "";

        // Check exists in inventory first
        const invItem = inventory.find(
          (i) => i.name.toLowerCase() === name.toLowerCase()
        );

        if (!invItem) {
          const ok = confirm(
            `"${name}" is not currently in your inventory.\n\n` +
              "Did you forget to add it, or are you happy to continue without deducting anything?"
          );
          if (!ok) {
            cb.checked = false;
            return;
          }
          // If they are happy ‚Üí do nothing to inventory, just mark as applied
          cb.dataset.applied = "true";
          cb.disabled = true;
          return;
        }

        // Deduct from inventory
        const success = deductInventoryForCooking(name, qtyBaseNum, base);
        if (!success) {
          alert("Could not update inventory for " + name);
          cb.checked = false;
          return;
        }

        cb.dataset.applied = "true";
        cb.disabled = true;

        renderInventory();
        saveState();
      });

      row.appendChild(cb);
      row.appendChild(labelSpan);
      li.appendChild(row);
      ingList.appendChild(li);
    });
  }

  // Initial render
  renderCookIngredients();

  // If servings change, regenerate checklist
  servingsInput.addEventListener("change", () => {
    const val = parseFloat(servingsInput.value || "0");
    if (!val || val <= 0) {
      servingsInput.value = "1";
    }
    renderCookIngredients();
  });

  // Finish cooking: warn if some ingredients not ticked
  finishBtn.addEventListener("click", () => {
    const unchecked = Array.from(
      ingList.querySelectorAll('input[type="checkbox"]:not(:checked)')
    ).map((cb) => cb.dataset.ingName);

    if (unchecked.length) {
      const ok = confirm(
        "You haven't ticked these ingredients:\n\n" +
          unchecked.map((n) => "‚Ä¢ " + n).join("\n") +
          "\n\nIs that because you didn't use them or couldn't buy them?"
      );
      if (!ok) return;
      // We don't change inventory here ‚Äì it's just a safety check
    }

    overlay.remove();
  });
}

  function startRecipeEdit(id, ingredientIndexToEdit) {
  const recipe = recipes.find((r) => r.id === id);
  if (!recipe) return;

  editingRecipeId = id;
  currentRecipe = {
    id: recipe.id,
    name: recipe.name,
    servings: recipe.servings,
    ingredients: recipe.ingredients.map((ing) => ({
      name: ing.name,
      quantity: ing.quantity,
      unit: ing.unit,
    })),
  };

  document.getElementById("recipe-name").value = currentRecipe.name;
  document.getElementById("recipe-servings").value =
    currentRecipe.servings;

  document
    .getElementById("recipe-ingredients-section")
    .classList.remove("hidden");
  document
    .getElementById("cancel-recipe-edit")
    .classList.remove("hidden");

  renderCurrentRecipeIngredients();

  // If we came from the long-press popup, drop straight into that ingredient
  if (
    typeof ingredientIndexToEdit === "number" &&
    ingredientIndexToEdit >= 0 &&
    ingredientIndexToEdit < currentRecipe.ingredients.length
  ) {
    startIngredientEdit(ingredientIndexToEdit);
  } else {
    clearIngredientEditState();
  }
}

    // ---------- MEAL PLAN ----------

    function renderMealPlan() {
      const container = document.getElementById("meal-plan-container");
      if (!container) return;
      container.innerHTML = "";

      if (!mealPlan || !mealPlan.length) initDefaultMealPlan();

      const validIds = new Set(recipes.map((r) => r.id));
      mealPlan.forEach((entry) => {
        if (entry.recipeId && !validIds.has(entry.recipeId)) {
          entry.recipeId = "";
          entry.servings = 0;
        }
      });

      mealPlan.forEach((entry) => {
        const row = document.createElement("div");
        row.className = "subpanel";

        const label = document.createElement("h3");
        label.textContent = entry.dayLabel;
        row.appendChild(label);

        const recipeLabel = document.createElement("label");
        recipeLabel.textContent = "Recipe";

        const select = document.createElement("select");
        select.dataset.dayId = entry.dayId;

        const defaultOpt = document.createElement("option");
        defaultOpt.value = "";
        defaultOpt.textContent = "(no meal selected)";
        select.appendChild(defaultOpt);

        recipes
          .slice()
          .sort((a, b) => a.name.localeCompare(b.name))
          .forEach((recipe) => {
            const opt = document.createElement("option");
            opt.value = recipe.id;
            opt.textContent = `${recipe.name} (serves ${recipe.servings})`;
            select.appendChild(opt);
          });

        select.value = entry.recipeId || "";
        select.addEventListener("change", (e) => {
         const id = e.target.dataset.dayId;
         const planEntry = mealPlan.find((p) => p.dayId === id);
         if (!planEntry) return;
         planEntry.recipeId = e.target.value;
         if (!planEntry.recipeId) {
          planEntry.servings = 0;
          const sInput = document.querySelector(
            `input[data-day-id="${id}"]`
          );
          if (sInput) sInput.value = "0";
        }
        saveState();
        updateCookBtnState();
      });

        recipeLabel.appendChild(select);
        row.appendChild(recipeLabel);

        const servingsLabel = document.createElement("label");
        servingsLabel.textContent = "Planned servings";

        const servingsInput = document.createElement("input");
        servingsInput.type = "number";
        servingsInput.min = "0";
        servingsInput.step = "1";
        servingsInput.dataset.dayId = entry.dayId;
        servingsInput.value =
          entry.servings && entry.servings > 0 ? entry.servings : "0";

        servingsInput.addEventListener("change", (e) => {
  const id = e.target.dataset.dayId;
  const planEntry = mealPlan.find((p) => p.dayId === id);
  if (!planEntry) return;
  let val = parseFloat(e.target.value || "0");
  if (isNaN(val) || val < 0) val = 0;
  planEntry.servings = val;
  e.target.value = val === 0 ? "0" : String(val);
  saveState();
  updateCookBtnState();
});

        servingsLabel.appendChild(servingsInput);
        row.appendChild(servingsLabel);

                // "I'm cooking this" button
        const cookBtn = document.createElement("button");
        cookBtn.type = "button";
        cookBtn.textContent = "I'm cooking this";
        cookBtn.className = "secondary";
        cookBtn.style.marginTop = "0.5rem";

        // Enable only if recipe + servings selected
        function updateCookBtnState() {
          const hasRecipe = !!entry.recipeId;
          const hasServings = entry.servings && entry.servings > 0;
          cookBtn.disabled = !(hasRecipe && hasServings);
        }

        cookBtn.addEventListener("click", () => {
          openCookDialog(entry.dayId);
        });

        updateCookBtnState();
        row.appendChild(cookBtn);

        container.appendChild(row);
      });
    }

    // ---------- SHOPPING LIST ----------
function roundUpForShopping(quantity, unit) {
  if (!quantity || quantity <= 0) return 0;
  unit = (unit || "").toLowerCase();

  // g / ml ‚Üí round up to nearest 50
  if (unit === "g" || unit === "ml") {
    return Math.ceil(quantity / 50) * 50; // e.g. 241.7 ‚Üí 250
  }

  // kg / l ‚Üí round up to nearest 0.1
  if (unit === "kg" || unit === "l") {
    return Math.ceil(quantity * 10) / 10; // e.g. 1.21 ‚Üí 1.3
  }

  // tsp / tbsp ‚Üí round up to nearest 0.5
  if (
    unit === "tsp" ||
    unit === "teaspoon" ||
    unit === "teaspoons" ||
    unit === "tbsp" ||
    unit === "tablespoon" ||
    unit === "tablespoons"
  ) {
    return Math.ceil(quantity * 2) / 2; // e.g. 0.42 ‚Üí 0.5
  }

  // cloves / sticks / packs / pieces ‚Üí round to whole items
  if (
    unit === "clove" ||
    unit === "cloves" ||
    unit === "stick" ||
    unit === "sticks" ||
    unit === "pack" ||
    unit === "packs" ||
    unit === "pc" ||
    unit === "pcs" ||
    unit === "piece" ||
    unit === "pieces"
  ) {
    return Math.ceil(quantity);
  }

  // Fallback: round up to 1 decimal place
  return Math.ceil(quantity * 10) / 10;
}
    function generateShoppingList() {
  const required = {};

  // Work out how much is needed for all planned meals
  mealPlan.forEach((entry) => {
    if (!entry.recipeId) return;
    const plannedServings = parseFloat(entry.servings || "0");
    if (plannedServings <= 0) return;

    const recipe = recipes.find((r) => r.id === entry.recipeId);
    if (!recipe) return;

    const scale = plannedServings / recipe.servings;

          recipe.ingredients.forEach((ing) => {
      // Skip cupboard staples (salt, pepper, oil, nutmeg, etc.)
      if (isStapleIngredient(ing.name)) {
        return;
      }

      // Skip ingredients that don't have a usable quantity
      if (!ing.quantity || ing.quantity <= 0) {
        return;
      }

      const key = ing.name.toLowerCase();
      const ingUnit = ing.unit || "";
      const baseUnit = required[key]
        ? required[key].baseUnit
        : chooseBaseUnit(ingUnit); // g/kg -> g, ml/l -> ml, else itself

      if (!required[key]) {
        required[key] = {
          name: ing.name,
          quantityBase: 0,
          baseUnit,
        };
      }

      const qtyScaled = ing.quantity * scale;
      const qtyInBase = convertToUnit(qtyScaled, ingUnit, required[key].baseUnit);
      required[key].quantityBase += qtyInBase;
    });
  });

  const tbody = document.querySelector("#shopping-table tbody");
  if (!tbody) return;
  tbody.innerHTML = "";

  // Helper to make numbers look tidy
  function formatNumberNice(n) {
    if (Number.isInteger(n)) return String(n);
    const oneDp = Math.round(n * 10) / 10;
    if (Number.isInteger(oneDp * 10)) return oneDp.toString();
    return (Math.round(n * 100) / 100).toString();
  }

  Object.keys(required).forEach((key) => {
    const need = required[key];
    const baseUnit = need.baseUnit;
    let requiredBase = need.quantityBase;

    // Work out what we already have in inventory (in the same base unit)
    let invQtyBase = 0;
    const invItem = inventory.find((i) => i.name.toLowerCase() === key);
    if (invItem && baseUnit) {
      invQtyBase = convertToUnit(invItem.quantity, invItem.unit || "", baseUnit);
    } else if (invItem && !baseUnit) {
      invQtyBase = invItem.quantity;
    }

    let toBuyBase = Math.max(0, requiredBase - invQtyBase);
    if (toBuyBase <= 1e-9) return; // nothing to buy ‚Üí skip row

    // Decide how to *display* that quantity
    let displayQty = toBuyBase;
    let displayUnit = baseUnit;

    // Rule we want:
    //  - if < 1000g/ml -> stay in g/ml
    //  - if >= 1000g/ml -> convert to kg/L
    if (baseUnit === "g") {
      if (displayQty >= 1000) {
        displayQty = displayQty / 1000;
        displayUnit = "kg";
      } else {
        displayUnit = "g";
      }
    } else if (baseUnit === "ml") {
      if (displayQty >= 1000) {
        displayQty = displayQty / 1000;
        displayUnit = "l";
      } else {
        displayUnit = "ml";
      }
    }
        // Round up to sensible shopping amounts
    displayQty = roundUpForShopping(displayQty, displayUnit);

    // Build a nice string like "500g" or "1.5kg" or "2 packs"
    let qtyStr;
    if (!displayUnit) {
      qtyStr = formatNumberNice(displayQty);
    } else {
      const smallUnits = ["g", "kg", "ml", "l"];
      const nStr = formatNumberNice(displayQty);
      if (smallUnits.includes(displayUnit)) {
        qtyStr = nStr + displayUnit;
      } else {
        qtyStr = nStr + " " + displayUnit.toLowerCase();
      }
    }

    // Create table row
    const tr = document.createElement("tr");
    tr.dataset.itemName = need.name;
    tr.dataset.buyQty = String(displayQty);
    tr.dataset.buyUnit = displayUnit || "";

    const tdCheck = document.createElement("td");
    const cb = document.createElement("input");
    cb.type = "checkbox";
    cb.className = "shopping-bought";
    tdCheck.appendChild(cb);

    const tdName = document.createElement("td");
    tdName.textContent = need.name;

    const tdBuy = document.createElement("td");
    // Convert tiny kg / L amounts back to g / ml for display
let fixedQtyStr = qtyStr;
const match = qtyStr.match(/^(\d+(?:\.\d+)?)\s*(kg|KG|l|L)$/); // e.g. "0.5kg", "0.75L"

if (match) {
  let value = parseFloat(match[1]);
  const unit = match[2].toLowerCase();

  // helper to make the number look neat
  const tidy = (n) =>
    Number.isInteger(n) ? String(n) : (Math.round(n * 100) / 100).toString();

  if (unit === "kg" && value < 1) {
    // e.g. 0.5kg -> 500g
    const grams = value * 1000;
    fixedQtyStr = tidy(grams) + "g";
  } else if (unit === "l" && value < 1) {
    // e.g. 0.75L -> 750ml
    const ml = value * 1000;
    fixedQtyStr = tidy(ml) + "ml";
  }
}

tdBuy.textContent = fixedQtyStr;

    tr.appendChild(tdCheck);
    tr.appendChild(tdName);
    tr.appendChild(tdBuy);
    tbody.appendChild(tr);
  });

  // When you tick items, add them into inventory
  const checkboxes = tbody.querySelectorAll(".shopping-bought");
  checkboxes.forEach((cb) => {
    cb.addEventListener("change", () => {
      const tr = cb.closest("tr");
      if (!tr) return;
      if (!cb.checked || tr.dataset.applied === "true") return;

      const name = tr.dataset.itemName;
      const qty = parseFloat(tr.dataset.buyQty || "0");
      const unit = tr.dataset.buyUnit || "";
      if (!name || !qty || qty <= 0) return;

      upsertInventoryItem(name, qty, unit);
      tr.dataset.applied = "true";

      renderInventory();
      renderInventoryNameSuggestions();
      saveState();
    });
  });
}

// ----- BARCODE GLOBALS -----
let activeBarcodeReader = null;
let barcodeScanHandled = false;
let scanSessionId = 0;

// make sure we have a barcode map object
window.barcodeMap = window.barcodeMap || {};

// Stop ZXing + camera stream safely
function stopBarcodeReader() {
  try {
    if (activeBarcodeReader && typeof activeBarcodeReader.reset === "function") {
      activeBarcodeReader.reset();
    }
  } catch (err) {
    console.error("Error resetting barcode reader:", err);
  }
  activeBarcodeReader = null;

  const video = document.getElementById("barcode-video");
  if (video && video.srcObject) {
    try {
      video.srcObject.getTracks().forEach((t) => t.stop());
    } catch (err) {
      console.error("Error stopping video tracks:", err);
    }
    video.srcObject = null;
  }
}
// Close overlay + stop scanning
function closeBarcodeScannerOverlay() {
  barcodeScanHandled = true;          // guard so callback ignores further reads
  stopBarcodeReader();

  const overlay = document.getElementById("barcode-scanner-overlay");
  if (overlay && overlay.parentNode) {
    overlay.parentNode.removeChild(overlay);
  }
}

function openBarcodeScanner() {
  if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
    alert("Camera access is not supported on this device / browser.");
    return;
  }

  // New scan session
  scanSessionId++;
  const thisSession = scanSessionId;
  barcodeScanHandled = false;

  // Clean up any previous reader/overlay
  stopBarcodeReader();
  const oldOverlay = document.getElementById("barcode-scanner-overlay");
  if (oldOverlay) oldOverlay.remove();

  // Build overlay
  const overlay = document.createElement("div");
  overlay.id = "barcode-scanner-overlay";
  overlay.className = "barcode-scanner-overlay";

  const panel = document.createElement("div");
  panel.className = "barcode-scanner-panel";

  const title = document.createElement("h2");
  title.textContent = "Scan barcode";
  panel.appendChild(title);

  const video = document.createElement("video");
  video.id = "barcode-video";
  video.autoplay = true;
  video.playsInline = true;
  panel.appendChild(video);

  const btnRow = document.createElement("div");
  btnRow.className = "barcode-scanner-actions";

  const cancelBtn = document.createElement("button");
  cancelBtn.type = "button";
  cancelBtn.textContent = "Cancel";
  cancelBtn.className = "secondary";
  cancelBtn.addEventListener("click", () => {
    closeBarcodeScannerOverlay();
  });

  btnRow.appendChild(cancelBtn);
  panel.appendChild(btnRow);
  overlay.appendChild(panel);

  // Tap dark background to cancel
  overlay.addEventListener("click", (e) => {
    if (e.target === overlay) {
      closeBarcodeScannerOverlay();
    }
  });

  document.body.appendChild(overlay);

  // Start ZXing
  const ZX = window.ZXingBrowser || window.ZXing;
  if (!ZX || !ZX.BrowserMultiFormatReader) {
    alert("Barcode scanner library not loaded.");
    return;
  }

  activeBarcodeReader = new ZX.BrowserMultiFormatReader();

  activeBarcodeReader.decodeFromVideoDevice(
    null,
    "barcode-video",
    (result, err) => {
      // Ignore if:
      //  - this is an old session
      //  - we've already handled a scan
      if (thisSession !== scanSessionId || barcodeScanHandled) return;

      if (!result || !result.text) return;

      const code = result.text.trim();
      if (!code) return;

      console.log("Barcode scanned:", code);

      barcodeScanHandled = true;
      closeBarcodeScannerOverlay();   // stop camera + remove overlay
      handleBarcodeCode(code);        // open your add-item flow ONCE
    }
  );
}

function handleBarcodeCode(barcode) {
  if (!barcode) return;

  const map = (window.barcodeMap = window.barcodeMap || {});
  const entry = map[barcode];

  // üÜï Case 1: brand new barcode ‚Äì no mapping yet
  if (!entry) {
    openAddInventoryItemDialog(null, {
      scannedBarcode: barcode,
      presetName: "",
    });
    return;
  }

  // Normalise entry to an array of names
  let names = Array.isArray(entry) ? entry.slice() : [entry];

  // Clean duplicates / blanks
  names = [...new Set(names.filter(Boolean))];

  // üßæ Case 2: exactly one known name
  if (names.length === 1) {
    const name = names[0];

    // ‚ùå Do NOT pass existing item here ‚Äì treat as a *new* entry,
    //     just with the name pre-filled.
    openAddInventoryItemDialog(null, {
      scannedBarcode: barcode,
      presetName: name,
    });
    return;
  }

  // üìã Case 3: multiple possible names ‚Üí show picker
  openBarcodeNamePicker(barcode, names);
}

function openBarcodeNamePicker(barcode, names) {
  // Normalise the list (turn single string ‚Üí array)
  if (!Array.isArray(names)) {
    names = names ? [names] : [];
  }

  // No names ‚Üí treat as new barcode
  if (names.length === 0) {
    openAddInventoryItemDialog(null, {
      scannedBarcode: barcode,
      presetName: name,
    });
    return;
  }

  // Only one ‚Üí open dialog prefilled
  if (names.length === 1) {
    const name = names[0];

    // Try to locate this item in your inventory
    const existing =
      inventory.find(
        (i) => i.name && i.name.toLowerCase() === name.toLowerCase()
      ) || null;

    openAddInventoryItemDialog(existing, {
      scannedBarcode: barcode,
      presetName: name,
    });
    return;
  }

  // Multiple names ‚Üí show picker
  const oldOverlay = document.getElementById("barcode-choice-overlay");
  if (oldOverlay) oldOverlay.remove();

  const overlay = document.createElement("div");
  overlay.id = "barcode-choice-overlay";
  overlay.className = "optional-overlay";

  const modal = document.createElement("div");
  modal.className = "optional-modal";

  // Title
  const title = document.createElement("h3");
  title.textContent = "Which item is this?";
  modal.appendChild(title);

  // Description
  const desc = document.createElement("p");
  desc.textContent =
    "This barcode is linked to multiple items. Choose one, or tap Something else to add another.";
  modal.appendChild(desc);

  // --- Buttons for each known name ---
  names.forEach((name) => {
    const btn = document.createElement("button");
    btn.type = "button";
    btn.textContent = name;
    btn.className = "inventory-edit-btn"; // your nice pill style
    btn.style.display = "block";
    btn.style.marginTop = "0.4rem";

    btn.addEventListener("click", () => {
      overlay.remove();

      const existing =
        inventory.find(
          (i) => i.name && i.name.toLowerCase() === name.toLowerCase()
        ) || null;

      openAddInventoryItemDialog(existing, {
        scannedBarcode: barcode,
        presetName: name,
      });
    });

    modal.appendChild(btn);
  });

  // --- Something else button ---
  const otherBtn = document.createElement("button");
  otherBtn.type = "button";
  otherBtn.textContent = "Something else‚Ä¶";
  otherBtn.className = "secondary";
  otherBtn.style.marginTop = "0.8rem";

  otherBtn.addEventListener("click", () => {
    overlay.remove();
    openAddInventoryItemDialog(null, {
      scannedBarcode: barcode, // <-- CRITICAL so new item is added to barcodeMap
      presetName: "",
    });
  });

  modal.appendChild(otherBtn);

  // --- Cancel button ---
  const cancelBtn = document.createElement("button");
  cancelBtn.type = "button";
  cancelBtn.textContent = "Cancel";
  cancelBtn.className = "secondary";
  cancelBtn.style.marginTop = "0.5rem";

  cancelBtn.addEventListener("click", () => overlay.remove());

  modal.appendChild(cancelBtn);

  // Close picker when tapping background
  overlay.addEventListener("click", (evt) => {
    if (evt.target === overlay) overlay.remove();
  });

  overlay.appendChild(modal);
  document.body.appendChild(overlay);
}

function attachAddItemKeyboardShim(panel) {
  if (!window.visualViewport) return;

  const vv = window.visualViewport;
  const baseHeight = window.innerHeight;
  let lastOffset = 0;

  function setOffset(px) {
    if (px === lastOffset) return;
    lastOffset = px;
    panel.style.setProperty("--offset-y", px + "px");
  }

  function onResize() {
    // Approx keyboard height = how much shorter the viewport is
    const keyboardHeight = Math.max(0, baseHeight - vv.height);

    // Treat tiny changes as "no keyboard"
    if (keyboardHeight < 80) {
      setOffset(0);
      return;
    }

    // Move panel up by about 60% of keyboard height,
    // but never more than 25% of the screen height.
    const maxShift = baseHeight * 0.25;
    const desired = -Math.min(maxShift, keyboardHeight * 0.6);

    setOffset(desired);
  }

  vv.addEventListener("resize", onResize);

  // Run once in case keyboard is already open
  onResize();
}

    // ---------- NAVIGATION ----------

    function showPage(pageId) {
      const pages = document.querySelectorAll(".page");
      const navButtons = document.querySelectorAll(".app-nav button");

      pages.forEach((page) => {
        if (!page) return;
        page.classList.toggle("hidden", page.id !== pageId);
      });

      navButtons.forEach((btn) => {
        if (!btn) return;
        const controls = btn.getAttribute("aria-controls");
        btn.setAttribute(
          "aria-selected",
          controls === pageId ? "true" : "false"
        );
      });
    }

    // ---------- INIT ----------

 document.addEventListener("DOMContentLoaded", () => {
  loadState();

  // ----- NAV / MENU -----
  const menuToggle = document.getElementById("menu-toggle");
  const appNav = document.getElementById("app-nav");

  function closeMenu() {
    if (appNav) appNav.classList.remove("nav-open");
    if (menuToggle) menuToggle.setAttribute("aria-expanded", "false");
  }

  if (menuToggle && appNav) {
    menuToggle.addEventListener("click", () => {
      const isOpen = appNav.classList.toggle("nav-open");
      menuToggle.setAttribute("aria-expanded", isOpen ? "true" : "false");
    });
  }

  const navInventory = document.getElementById("nav-inventory");
  const navRecipes   = document.getElementById("nav-recipes");
  const navMealplan  = document.getElementById("nav-mealplan");
  const navShopping  = document.getElementById("nav-shopping");

  if (navInventory) {
    navInventory.addEventListener("click", () => {
      showPage("page-inventory");
      closeMenu();
    });
  }

  if (navRecipes) {
    navRecipes.addEventListener("click", () => {
      showPage("page-recipes");
      closeMenu();
    });
  }

  if (navMealplan) {
    navMealplan.addEventListener("click", () => {
      showPage("page-mealplan");
      closeMenu();
    });
  }

  if (navShopping) {
    navShopping.addEventListener("click", () => {
      showPage("page-shopping");
      closeMenu();
    });
  }

  showPage("page-inventory");

  // === INVENTORY EVENTS ===
  const addInventoryBtn = document.getElementById("add-inventory-item-btn");
  const realScanBtn     = document.getElementById("real-scan-btn");

  // Add Item ‚Üí opens the Add Item overlay dialog
  if (addInventoryBtn) {
    addInventoryBtn.addEventListener("click", () => {
      console.log("Add item button clicked");

      // extra debug so we SEE what the browser thinks this is
      console.log("typeof window.openAddInventoryItemDialog =",
        typeof window.openAddInventoryItemDialog
      );

      if (typeof window.openAddInventoryItemDialog !== "function") {
        console.error("openAddInventoryItemDialog is not a function:", window.openAddInventoryItemDialog);
        alert("Add item dialog is not available (JS error) ‚Äì check console.");
        return;
      }

      window.openAddInventoryItemDialog();
    });
  } else {
    console.warn("No #add-inventory-item-btn found in DOM");
  }

  // Scan barcode ‚Üí opens camera scanner
  if (realScanBtn) {
    realScanBtn.addEventListener("click", () => {
      openBarcodeScanner();
    });
  } else {
    console.warn("No #real-scan-btn found in DOM");
  }
  
    // ----- RECIPES BUTTONS -----
  const addRecipeBtn = document.getElementById("add-recipe-btn");
  const recipeForm   = document.getElementById("recipe-form");

  if (addRecipeBtn && recipeForm) {
    addRecipeBtn.addEventListener("click", () => {
      // show the legacy inline editor form
      recipeForm.classList.remove("hidden");

      const nameInput = document.getElementById("recipe-name");
      if (nameInput) {
        nameInput.focus();
      }
    });
  }

  // ----- RECIPES -----
  const startRecipeBtn       = document.getElementById("start-recipe");
  const ingSection           = document.getElementById("recipe-ingredients-section");
  const cancelRecipeEditBtn  = document.getElementById("cancel-recipe-edit");
  const importBtn            = document.getElementById("import-ingredients-btn");
  const ingForm              = document.getElementById("ingredient-form");
  const cancelIngEditBtn     = document.getElementById("cancel-ingredient-edit");
  const saveRecipeBtn        = document.getElementById("save-recipe");

  if (startRecipeBtn && ingSection && cancelRecipeEditBtn) {
    startRecipeBtn.addEventListener("click", () => {
      const nameEl     = document.getElementById("recipe-name");
      const servingsEl = document.getElementById("recipe-servings");

      const name = nameEl ? nameEl.value.trim() : "";
      const servings = servingsEl
        ? parseFloat(servingsEl.value || "0")
        : 0;

      if (!name || servings <= 0) {
        alert("Please enter a recipe name and servings.");
        return;
      }

      if (!currentRecipe || !editingRecipeId) {
        currentRecipe = {
          id: editingRecipeId || String(Date.now()),
          name: titleCase(name),
          servings,
          ingredients: [],
        };
      } else {
        currentRecipe.name     = titleCase(name);
        currentRecipe.servings = servings;
      }

      ingSection.classList.remove("hidden");
      renderCurrentRecipeIngredients();

      if (editingRecipeId) {
        cancelRecipeEditBtn.classList.remove("hidden");
      } else {
        cancelRecipeEditBtn.classList.add("hidden");
      }
      clearIngredientEditState();
    });
  }

  if (cancelRecipeEditBtn) {
    cancelRecipeEditBtn.addEventListener("click", () => {
      clearRecipeEditState();
    });
  }

  if (ingForm) {
    ingForm.addEventListener("submit", (e) => {
      e.preventDefault();
      if (!currentRecipe) {
        alert("Start a recipe first.");
        return;
      }

      const nameEl = document.getElementById("ing-name");
      const qtyEl  = document.getElementById("ing-qty");
      const unitEl = document.getElementById("ing-unit");

      const name = nameEl ? nameEl.value.trim() : "";
      const qty  = qtyEl  ? parseFloat(qtyEl.value || "0") : 0;
      const unit = unitEl ? unitEl.value.trim() : "";

      if (!name || qty <= 0) {
        alert("Please enter a valid ingredient name & quantity.");
        return;
      }

      const cleanName = titleCase(name);

      if (editingIngredientIndex !== null) {
        currentRecipe.ingredients[editingIngredientIndex] = {
          name: cleanName,
          quantity: qty,
          unit,
        };
        clearIngredientEditState();
      } else {
        currentRecipe.ingredients.push({
          name: cleanName,
          quantity: qty,
          unit,
        });
      }

      renderCurrentRecipeIngredients();
    });
  }

  if (cancelIngEditBtn) {
    cancelIngEditBtn.addEventListener("click", () => {
      clearIngredientEditState();
    });
  }

  // Import ingredients from textarea (BBC-aware parser)
  if (importBtn) {
    importBtn.addEventListener("click", () => {
      if (!currentRecipe) {
        alert(
          "Start a recipe first (name + servings, then 'Start new recipe')."
        );
        return;
      }

      const textarea = document.getElementById("import-text");
      const raw = textarea ? textarea.value : "";
      const lines = raw
        .split(/\r?\n/)
        .map((l) => l.trim())
        .filter(Boolean);

      let imported = 0;

      const bbcNames =
        lastImportedRecipeMeta &&
        Array.isArray(lastImportedRecipeMeta.ingredientNames) &&
        lastImportedRecipeMeta.ingredientNames.length
          ? lastImportedRecipeMeta.ingredientNames
          : null;

      lines.forEach((line) => {
        let parsed;
        if (bbcNames) {
          parsed = parseBbcIngredient(line, bbcNames);
        } else {
          parsed = parseIngredientLine(line);
        }

        if (!parsed || !parsed.name) return;

        if (parsed.quantity !== null && parsed.quantity !== undefined) {
          if (Number.isNaN(parsed.quantity) || parsed.quantity <= 0) return;
        }

        currentRecipe.ingredients.push(parsed);
        imported++;
      });

      renderCurrentRecipeIngredients();
      if (imported) {
        alert(`Imported ${imported} ingredient(s).`);
        if (textarea) textarea.value = "";
      } else {
        alert("No valid ingredients found.");
      }
    });
  }

  if (saveRecipeBtn) {
    saveRecipeBtn.addEventListener("click", () => {
      if (!currentRecipe) {
        alert("No recipe in progress.");
        return;
      }
      if (
        !currentRecipe.ingredients ||
        !currentRecipe.ingredients.length
      ) {
        alert("Add at least one ingredient.");
        return;
      }

      if (
        lastImportedRecipeMeta &&
        Array.isArray(lastImportedRecipeMeta.instructions) &&
        (!currentRecipe.instructions ||
          !currentRecipe.instructions.length)
      ) {
        currentRecipe.instructions =
          lastImportedRecipeMeta.instructions.slice();
      }

      if (lastImportedRecipeMeta) {
        if (!currentRecipe.imageUrl && lastImportedRecipeMeta.image) {
          currentRecipe.imageUrl = lastImportedRecipeMeta.image;
        }
        if (
          !currentRecipe.sourceUrl &&
          lastImportedRecipeMeta.sourceUrl
        ) {
          currentRecipe.sourceUrl = lastImportedRecipeMeta.sourceUrl;
        }
      }

      if (editingRecipeId) {
        const idx = recipes.findIndex((r) => r.id === editingRecipeId);
        if (idx !== -1) {
          recipes[idx] = {
            id: editingRecipeId,
            name: currentRecipe.name,
            servings: currentRecipe.servings,
            ingredients: currentRecipe.ingredients,
            instructions: currentRecipe.instructions || [],
            imageUrl: currentRecipe.imageUrl || "",
            sourceUrl: currentRecipe.sourceUrl || "",
          };
        }
      } else {
        recipes.push(currentRecipe);
      }

      clearRecipeEditState();
      renderRecipesList();
      saveState();
    });
  }

  // ----- BBC IMPORT -----
  const recipeImportUrlInput = document.getElementById("recipe-import-url");
  const recipeImageFetchBtn  = document.getElementById("recipe-fetch-image");
  const recipeImportStatus   = document.getElementById("recipe-import-status");
  const recipeImagePreview   = document.getElementById("recipe-image-preview");
  const recipeImportTextarea = document.getElementById("import-text");
  const recipeClearBtn       = document.getElementById("recipe-clear-import");

  if (
    recipeImportUrlInput &&
    recipeImageFetchBtn &&
    recipeImportStatus &&
    recipeImagePreview &&
    recipeImportTextarea
  ) {
    if (recipeClearBtn) {
      recipeClearBtn.addEventListener("click", () => {
        recipeImportUrlInput.value = "";
        recipeImportStatus.textContent = "";
        recipeImportStatus.classList.remove("error");

        recipeImagePreview.style.display = "none";
        recipeImagePreview.src = "";

        recipeImportTextarea.value = "";
        lastImportedRecipeMeta = null;
      });
    }

    recipeImageFetchBtn.addEventListener("click", async () => {
      const rawUrl = recipeImportUrlInput.value.trim();
      if (!rawUrl) {
        recipeImportStatus.textContent = "Please paste a recipe URL first.";
        recipeImportStatus.classList.add("error");
        recipeImagePreview.style.display = "none";
        return;
      }

      recipeImportStatus.textContent = "Fetching recipe‚Ä¶";
      recipeImportStatus.classList.remove("error");
      recipeImagePreview.style.display = "none";
      lastImportedRecipeMeta = null;

      try {
        const endpoint = WORKER_BASE + "?url=" + encodeURIComponent(rawUrl);
        const res = await fetch(endpoint);
        if (!res.ok) {
          throw new Error("Proxy returned " + res.status);
        }
        const data = await res.json();

        if (!data || data.ok === false) {
          recipeImportStatus.textContent =
            (data && data.error) || "Recipe not found on that page.";
          recipeImportStatus.classList.add("error");
          recipeImagePreview.style.display = "none";
          return;
        }

        if (data.image) {
          recipeImagePreview.src = data.image;
          recipeImagePreview.style.display = "block";
        } else {
          recipeImagePreview.style.display = "none";
        }

        const titleInput = document.getElementById("recipe-name");
        if (titleInput && !titleInput.value.trim() && data.title) {
          titleInput.value = tidyRecipeTitle(data.title);
        }

        const servingsInput = document.getElementById("recipe-servings");
        if (servingsInput && data.servings) {
          const currentVal = servingsInput.value.trim();
          if (!currentVal || currentVal === "2") {
            const parsed = parseServingsNumber(data.servings);
            if (parsed && parsed > 0) {
              servingsInput.value = String(parsed);
            }
          }
        }

        if (Array.isArray(data.ingredients) && data.ingredients.length) {
          recipeImportTextarea.value = data.ingredients.join("\n");
        }

        const ingredientNames = Array.isArray(data.ingredientNames)
          ? data.ingredientNames
          : [];

        if (Array.isArray(data.instructions) && data.instructions.length) {
          lastImportedRecipeMeta = {
            instructions: data.instructions.slice(),
            sourceUrl: data.source || rawUrl,
            servingsText: data.servings || "",
            image: data.image || "",
            title: data.title || "",
            ingredientNames
          };
        } else {
          lastImportedRecipeMeta = {
            instructions: [],
            sourceUrl: data.source || rawUrl,
            servingsText: data.servings || "",
            image: data.image || "",
            title: data.title || "",
            ingredientNames
          };
        }

        recipeImportStatus.textContent =
          "Recipe info loaded. Review, then click 'Import ingredients'.";
        recipeImportStatus.classList.remove("error");
      } catch (err) {
        console.error(err);
        recipeImportStatus.textContent = "Could not fetch recipe.";
        recipeImportStatus.classList.add("error");
        recipeImagePreview.style.display = "none";
        lastImportedRecipeMeta = null;
      }
    });
  }

  // ----- MEAL PLAN & SHOPPING -----
  const generateShoppingBtn = document.getElementById("generate-shopping-list");
  if (generateShoppingBtn) {
    generateShoppingBtn.addEventListener("click", () => {
      generateShoppingList();
      showPage("page-shopping");
    });
  }

  // ----- INITIAL RENDERS -----
  renderInventory();
  renderInventoryNameSuggestions();
  renderRecipesList();
  renderMealPlan();
});

    // Keep service worker registration small & safe
    if ("serviceWorker" in navigator) {
      navigator.serviceWorker
        .register("./sw.js")
        .catch(() => {});
    }
  </script>
</body>
</html>