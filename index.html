<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="color-scheme" content="dark light" />
  <title>Pantry App</title>

  <!-- Use your existing dark / modern CSS file -->
  <link rel="stylesheet" href="styles.css?v=21" />

  <!-- PWA bits (keep for your phone shortcut) -->
  <link rel="manifest" href="manifest.json" />
  <meta name="theme-color" content="#ff7a00" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <link rel="apple-touch-icon" href="icons/icon-192.png" />
</head>
<body>
  <!-- TOP BAR -->
  <header class="top-bar">
    <button
      id="menu-toggle"
      class="menu-toggle"
      aria-label="Navigation"
      aria-controls="app-nav"
      aria-expanded="false"
      type="button"
    >
      ‚ò∞
    </button>
    <span class="top-bar-title">Pantry App</span>
  </header>

  <!-- NAV BAR (kept simple & always visible) -->
  <nav
    id="app-nav"
    class="app-nav"
    role="tablist"
    aria-label="Pantry navigation"
  >
    <button
      id="nav-inventory"
      role="tab"
      aria-selected="true"
      aria-controls="page-inventory"
      type="button"
    >
      Inventory
    </button>
    <button
      id="nav-recipes"
      role="tab"
      aria-selected="false"
      aria-controls="page-recipes"
      type="button"
    >
      Recipes
    </button>
    <button
      id="nav-mealplan"
      role="tab"
      aria-selected="false"
      aria-controls="page-mealplan"
      type="button"
    >
      Meal plan
    </button>
    <button
      id="nav-shopping"
      role="tab"
      aria-selected="false"
      aria-controls="page-shopping"
      type="button"
    >
      Shopping list
    </button>
  </nav>

  <!-- PAGE 1: INVENTORY -->
  <main id="page-inventory" class="page" role="tabpanel" aria-labelledby="nav-inventory">
    <div class="inventory-controls">
      <label>
        Search inventory
        <input id="inventory-search" type="text" placeholder="Type to filter items..." />
      </label>
    </div>

    <section class="panel">
      <h2>Inventory</h2>

      <div class="barcode-tools">
        <button id="fake-scan-btn" type="button" class="secondary">
          Fake barcode scan
        </button>
      </div>

      <form id="inventory-form">
        <label>
          Item name
          <input id="inv-name" type="text" list="inv-name-list" required />
          <datalist id="inv-name-list"></datalist>
        </label>

        <div class="grid-2">
          <label>
            Quantity
            <input id="inv-qty" type="number" min="0" step="0.1" value="1" required />
          </label>
          <label>
            Unit
            <select id="inv-unit">
              <option value="">(none)</option>
              <option value="g">g</option>
              <option value="kg">kg</option>
              <option value="ml">ml</option>
              <option value="l">l</option>
              <option value="pack">pack</option>
              <option value="packs">packs</option>
              <option value="pcs">pcs</option>
            </select>
          </label>
        </div>

        <div class="form-actions">
          <button id="inventory-submit-btn" type="submit">Add / Update</button>
          <button id="inventory-cancel-edit" type="button" class="secondary hidden">
            Cancel edit
          </button>
        </div>
      </form>

      <div id="inventory-list" class="inventory-list"></div>
    </section>
  </main>

  <!-- PAGE 2: RECIPES -->
  <section
    id="page-recipes"
    class="page hidden"
    role="tabpanel"
    aria-labelledby="nav-recipes"
  >
    <section class="panel">
      <h2>Recipes</h2>

      <form id="recipe-form">
        <label>
          Recipe name
          <input id="recipe-name" type="text" required />
        </label>
        <label>
          Servings (base recipe)
          <input id="recipe-servings" type="number" value="2" min="1" required />
        </label>
        <div class="form-actions">
          <button id="start-recipe" type="button">Start new recipe</button>
          <button id="cancel-recipe-edit" type="button" class="secondary hidden">
            Cancel edit
          </button>
        </div>
      </form>

      <div id="recipe-ingredients-section" class="subpanel hidden">
        <h3>Ingredients for current recipe</h3>

        <form id="ingredient-form">
          <label>
            Ingredient name
            <input id="ing-name" type="text" required />
          </label>
          <div class="grid-2">
            <label>
              Quantity
              <input id="ing-qty" type="number" value="1" min="0" step="0.1" required />
            </label>
            <label>
              Unit
              <input id="ing-unit" type="text" placeholder="g, ml, pcs..." />
            </label>
          </div>
          <div class="form-actions">
            <button id="ingredient-submit-btn" type="submit">
              Add ingredient
            </button>
            <button id="cancel-ingredient-edit" type="button" class="secondary hidden">
              Cancel ingredient edit
            </button>
          </div>
        </form>

        <ul id="current-recipe-ingredients"></ul>

        <button id="save-recipe" type="button">Save recipe</button>

        <div class="subpanel">
          <h3>Quick import from text</h3>
          <p>
            Paste one ingredient per line, e.g.
            ‚Äú500g beef mince‚Äù or ‚Äú4 sticks celery‚Äù.
          </p>
          <label>
            Ingredients text
            <textarea
              id="import-text"
              rows="6"
              placeholder="Example:
500g beef mince
4 sticks celery
1 onion, chopped"
            ></textarea>
          </label>
          <button id="import-ingredients-btn" type="button">
            Import into current recipe
          </button>
        </div>
      </div>
    </section>

    <section class="panel">
      <h2>Saved recipes</h2>
      <p>Recipes you create here can be used on the Meal plan page.</p>
      <div id="recipes-list"></div>
    </section>
  </section>

  <!-- PAGE 3: MEAL PLAN -->
  <section
    id="page-mealplan"
    class="page hidden"
    role="tabpanel"
    aria-labelledby="nav-mealplan"
  >
    <section class="panel">
      <h2>Meal plan</h2>
      <p>Select meals for each day and how many portions you‚Äôll cook.</p>
      <div id="meal-plan-container"></div>
      <button id="generate-shopping-list" type="button">
        Generate shopping list
      </button>
    </section>
  </section>

  <!-- PAGE 4: SHOPPING LIST -->
  <section
    id="page-shopping"
    class="page hidden"
    role="tabpanel"
    aria-labelledby="nav-shopping"
  >
    <section class="panel">
      <h2>Shopping list</h2>
      <p>This list is based on your weekly meal plan and current inventory.</p>
      <table id="shopping-table">
        <thead>
          <tr>
            <th>‚úì</th>
            <th>Item</th>
            <th>To buy</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </section>
  </section>

  <!-- =============== JAVASCRIPT =============== -->
  <script>
    // ---------- UTILITIES ----------

    function titleCase(str) {
      return str
        .toLowerCase()
        .split(" ")
        .filter(Boolean)
        .map((w) => w.charAt(0).toUpperCase() + w.slice(1))
        .join(" ");
    }

    function convertToUnit(quantity, fromUnit, toUnit) {
      if (!fromUnit || !toUnit) return quantity;
      if (fromUnit === toUnit) return quantity;
      if (fromUnit === "g" && toUnit === "kg") return quantity / 1000;
      if (fromUnit === "kg" && toUnit === "g") return quantity * 1000;
      if (fromUnit === "ml" && toUnit === "l") return quantity / 1000;
      if (fromUnit === "l" && toUnit === "ml") return quantity * 1000;
      return quantity;
    }

    function normalizeInventoryItem(item) {
      if (item.unit === "g" && item.quantity >= 1000) {
        item.quantity = item.quantity / 1000;
        item.unit = "kg";
      } else if (item.unit === "ml" && item.quantity >= 1000) {
        item.quantity = item.quantity / 1000;
        item.unit = "l";
      }
    }

    function chooseBaseUnit(unit) {
      if (unit === "kg" || unit === "g") return "g";
      if (unit === "l" || unit === "ml") return "ml";
      return unit || "";
    }

    function formatQuantityWithUnit(quantity, unit) {
      if (!unit) return String(quantity);
      const compact = ["g", "kg", "ml", "l"];
      const isCompact = compact.includes(unit);
      const nStr = Number.isInteger(quantity)
        ? String(quantity)
        : quantity.toString();
      return isCompact ? nStr + unit : nStr + " " + unit.toLowerCase();
    }

    // ---------- VERY SIMPLE PARSER FOR IMPORT ----------

    function parseIngredientLine(line) {
      let trimmed = line.trim();
      if (!trimmed) return null;

      // Strip trailing notes after comma
      const commaIndex = trimmed.indexOf(",");
      if (commaIndex !== -1) trimmed = trimmed.slice(0, commaIndex).trim();

      // Try: "500g beef mince" or "2 tbsp olive oil"
      const parts = trimmed.split(/\s+/);
      if (!parts.length) return null;

      const qty = parseFloat(parts[0]);
      if (isNaN(qty) || qty <= 0) {
        return { name: titleCase(trimmed), quantity: 1, unit: "" };
      }

      if (parts.length === 1) {
        return { name: "", quantity: qty, unit: "" };
      }

      let unit = "";
      let nameWords = [];

      // If second word looks like a unit
      const knownUnit = parts[1].toLowerCase();
      const unitMap = {
        g: "g",
        kg: "kg",
        ml: "ml",
        l: "l",
        tsp: "tsp",
        teaspoon: "tsp",
        teaspoons: "tsp",
        tbsp: "tbsp",
        tablespoon: "tbsp",
        tablespoons: "tbsp",
        pack: "pack",
        packs: "packs",
        clove: "clove",
        cloves: "cloves",
        stick: "stick",
        sticks: "sticks",
      };

      if (unitMap[knownUnit]) {
        unit = unitMap[knownUnit];
        nameWords = parts.slice(2);
      } else {
        // otherwise treat everything after qty as name
        unit = "";
        nameWords = parts.slice(1);
      }

      return {
        name: titleCase(nameWords.join(" ")),
        quantity: qty,
        unit: unit,
      };
    }

    // ---------- STATE ----------

    const STORAGE_KEY = "pantryApp_simple_v1";

    let inventory = [];
    let recipes = [];
    let mealPlan = [];
    let barcodeMap = {}; // barcode -> {name, baseQty, unit}

    let inventoryFilter = "";
    let editingInventoryKey = null;

    let currentRecipe = null;
    let editingRecipeId = null;
    let editingIngredientIndex = null;

    function initDefaultMealPlan() {
      const days = [
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday",
        "Sunday",
      ];
      mealPlan = days.map((d) => ({
        dayId: d.toLowerCase(),
        dayLabel: d,
        recipeId: "",
        servings: 0,
      }));
    }

    function loadState() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) {
          initDefaultMealPlan();
          return;
        }
        const data = JSON.parse(raw);
        if (Array.isArray(data.inventory)) inventory = data.inventory;
        if (Array.isArray(data.recipes)) recipes = data.recipes;
        if (Array.isArray(data.mealPlan)) mealPlan = data.mealPlan;
        if (data.barcodeMap && typeof data.barcodeMap === "object") {
          barcodeMap = data.barcodeMap;
        }
        if (!mealPlan || !mealPlan.length) initDefaultMealPlan();
      } catch {
        initDefaultMealPlan();
      }
    }

    function saveState() {
      try {
        localStorage.setItem(
          STORAGE_KEY,
          JSON.stringify({ inventory, recipes, mealPlan, barcodeMap })
        );
      } catch (e) {
        console.error("Failed to save", e);
      }
    }

    // ---------- INVENTORY ----------

    function upsertInventoryItem(name, quantity, unit) {
      const cleanName = titleCase(name.trim());
      const key = cleanName.toLowerCase();
      let item = inventory.find((i) => i.key === key);

      if (!item) {
        item = { key, name: cleanName, quantity, unit };
        normalizeInventoryItem(item);
        inventory.push(item);
      } else {
        const baseUnit = item.unit || unit;
        const converted = convertToUnit(quantity, unit, baseUnit);
        if (!item.unit && unit) item.unit = unit;
        item.quantity += converted;
        normalizeInventoryItem(item);
      }
    }

    function setInventoryItemExact(originalKey, name, quantity, unit) {
      const cleanName = titleCase(name.trim());
      const newKey = cleanName.toLowerCase();
      let item = inventory.find((i) => i.key === originalKey);

      if (!item) {
        item = { key: newKey, name: cleanName, quantity, unit };
        normalizeInventoryItem(item);
        inventory.push(item);
      } else {
        item.name = cleanName;
        item.key = newKey;
        item.quantity = quantity;
        item.unit = unit;
        normalizeInventoryItem(item);
      }
    }

    function deleteInventoryItem(key) {
      inventory = inventory.filter((i) => i.key !== key);
    }

    function renderInventoryNameSuggestions() {
      const dl = document.getElementById("inv-name-list");
      if (!dl) return;
      dl.innerHTML = "";
      inventory
        .slice()
        .sort((a, b) => a.name.localeCompare(b.name))
        .forEach((item) => {
          const opt = document.createElement("option");
          opt.value = item.name;
          dl.appendChild(opt);
        });
    }

    function renderInventory() {
      const container = document.getElementById("inventory-list");
      if (!container) return;
      container.innerHTML = "";

      const filter = (inventoryFilter || "").toLowerCase();

      inventory
        .slice()
        .sort((a, b) => a.name.localeCompare(b.name))
        .forEach((item) => {
          if (filter && !item.name.toLowerCase().includes(filter)) return;

          const row = document.createElement("div");
          row.className = "inventory-item";

          const text = document.createElement("span");
          text.className = "inventory-item-text";
          text.textContent =
            item.name +
            " - " +
            formatQuantityWithUnit(item.quantity, item.unit || "");
          row.appendChild(text);

          const actions = document.createElement("div");
          actions.className = "inventory-actions";

          const editBtn = document.createElement("button");
          editBtn.type = "button";
          editBtn.textContent = "‚úé";
          editBtn.title = "Edit";
          editBtn.addEventListener("click", () => startInventoryEdit(item.key));

          const delBtn = document.createElement("button");
          delBtn.type = "button";
          delBtn.textContent = "üóë";
          delBtn.title = "Delete";
          delBtn.addEventListener("click", () => {
            if (confirm(`Delete ${item.name} from inventory?`)) {
              deleteInventoryItem(item.key);
              if (editingInventoryKey === item.key) clearInventoryEditState();
              renderInventory();
              renderInventoryNameSuggestions();
              saveState();
            }
          });

          actions.appendChild(editBtn);
          actions.appendChild(delBtn);
          row.appendChild(actions);

          container.appendChild(row);
        });
    }

    function startInventoryEdit(key) {
      const item = inventory.find((i) => i.key === key);
      if (!item) return;

      document.getElementById("inv-name").value = item.name;
      document.getElementById("inv-qty").value = item.quantity;
      document.getElementById("inv-unit").value = item.unit || "";

      document.getElementById("inventory-submit-btn").textContent =
        "Save changes";
      document
        .getElementById("inventory-cancel-edit")
        .classList.remove("hidden");
      editingInventoryKey = key;
    }

    function clearInventoryEditState() {
      document.getElementById("inv-name").value = "";
      document.getElementById("inv-qty").value = "1";
      document.getElementById("inv-unit").value = "";
      document.getElementById("inventory-submit-btn").textContent =
        "Add / Update";
      document
        .getElementById("inventory-cancel-edit")
        .classList.add("hidden");
      editingInventoryKey = null;
    }

    // ---------- FAKE BARCODE (SIMPLE) ----------

    function handleFakeBarcodeScan() {
      let code = prompt("Fake barcode scan: enter a code.", "");
      if (!code) return;
      code = String(code).trim();
      if (!code) return;

      const existing = barcodeMap[code];

      if (existing) {
        const answer = confirm(
          `Barcode ${code} is ${existing.name}.\nIs that correct?`
        );
        if (!answer) {
          // treat as new item
          createBarcodeMapping(code);
          return;
        }

        const defaultQty =
          existing.baseQty && existing.baseQty > 0
            ? String(existing.baseQty)
            : "1";
        const unitText = existing.unit ? " in " + existing.unit : "";
        const qtyStr = prompt(
          `How much did you buy${unitText}?`,
          defaultQty
        );
        if (!qtyStr) return;
        const qty = parseFloat(qtyStr);
        if (isNaN(qty) || qty <= 0) return;

        upsertInventoryItem(existing.name, qty, existing.unit || "");
        renderInventory();
        renderInventoryNameSuggestions();
        saveState();
        alert(
          "Added " +
            formatQuantityWithUnit(qty, existing.unit || "") +
            " of " +
            existing.name
        );
        return;
      }

      // new barcode
      createBarcodeMapping(code);
    }

    function createBarcodeMapping(code) {
      let name = prompt("What is this item called?", "");
      if (!name) return;
      const cleanName = titleCase(name);

      let baseQtyStr = prompt(
        `For one 'typical' amount of ${cleanName}, what quantity? (e.g. 500 for 500g)`,
        "500"
      );
      if (!baseQtyStr) return;
      const baseQty = parseFloat(baseQtyStr);
      if (isNaN(baseQty) || baseQty <= 0) return;

      let unit = prompt(
        "What is the unit? (e.g. g, kg, ml, l, pack, pcs)",
        "g"
      );
      unit = (unit || "").trim();

      barcodeMap[code] = {
        name: cleanName,
        baseQty: baseQty,
        unit: unit,
      };

      let nowQtyStr = prompt(
        `How much did you buy now in ${unit || "units"}?`,
        String(baseQty)
      );
      if (!nowQtyStr) {
        saveState();
        return;
      }
      const nowQty = parseFloat(nowQtyStr);
      if (isNaN(nowQty) || nowQty <= 0) {
        saveState();
        return;
      }

      upsertInventoryItem(cleanName, nowQty, unit);
      renderInventory();
      renderInventoryNameSuggestions();
      saveState();
      alert(
        "Added " + formatQuantityWithUnit(nowQty, unit) + " of " + cleanName
      );
    }

    // ---------- RECIPES ----------

    function renderCurrentRecipeIngredients() {
      const ul = document.getElementById("current-recipe-ingredients");
      if (!ul) return;
      ul.innerHTML = "";

      if (!currentRecipe || !Array.isArray(currentRecipe.ingredients)) return;

      currentRecipe.ingredients.forEach((ing, index) => {
        const li = document.createElement("li");

        const textSpan = document.createElement("span");
        textSpan.textContent =
          ing.name + ": " + ing.quantity + " " + (ing.unit || "");
        li.appendChild(textSpan);

        const actions = document.createElement("div");
        actions.className = "table-actions";

        const editBtn = document.createElement("button");
        editBtn.type = "button";
        editBtn.className = "secondary";
        editBtn.textContent = "Edit";
        editBtn.addEventListener("click", () => startIngredientEdit(index));

        const delBtn = document.createElement("button");
        delBtn.type = "button";
        delBtn.className = "secondary";
        delBtn.textContent = "Delete";
        delBtn.addEventListener("click", () => {
          currentRecipe.ingredients.splice(index, 1);
          renderCurrentRecipeIngredients();
        });

        actions.appendChild(editBtn);
        actions.appendChild(delBtn);
        li.appendChild(actions);
        ul.appendChild(li);
      });
    }

    function startIngredientEdit(index) {
      if (!currentRecipe || !currentRecipe.ingredients[index]) return;
      const ing = currentRecipe.ingredients[index];

      document.getElementById("ing-name").value = ing.name;
      document.getElementById("ing-qty").value = ing.quantity;
      document.getElementById("ing-unit").value = ing.unit;

      document.getElementById("ingredient-submit-btn").textContent =
        "Save ingredient";
      document
        .getElementById("cancel-ingredient-edit")
        .classList.remove("hidden");
      editingIngredientIndex = index;
    }

    function clearIngredientEditState() {
      document.getElementById("ing-name").value = "";
      document.getElementById("ing-qty").value = "1";
      document.getElementById("ing-unit").value = "";
      document.getElementById("ingredient-submit-btn").textContent =
        "Add ingredient";
      document
        .getElementById("cancel-ingredient-edit")
        .classList.add("hidden");
      editingIngredientIndex = null;
    }

    function clearRecipeEditState() {
      editingRecipeId = null;
      currentRecipe = null;
      document.getElementById("recipe-name").value = "";
      document.getElementById("recipe-servings").value = "2";
      document.getElementById("current-recipe-ingredients").innerHTML = "";
      document
        .getElementById("recipe-ingredients-section")
        .classList.add("hidden");
      document
        .getElementById("cancel-recipe-edit")
        .classList.add("hidden");
      clearIngredientEditState();
    }

    function renderRecipesList() {
      const container = document.getElementById("recipes-list");
      if (!container) return;
      container.innerHTML = "";

      if (!recipes.length) {
        container.textContent = "No recipes saved yet.";
        return;
      }

      recipes.forEach((r) => {
        const wrapper = document.createElement("div");
        wrapper.className = "subpanel";

        const header = document.createElement("div");
        header.className = "recipe-header";

        const title = document.createElement("h3");
        title.textContent = `${r.name} (serves ${r.servings})`;

        const actions = document.createElement("div");
        actions.className = "table-actions";

        const editBtn = document.createElement("button");
        editBtn.type = "button";
        editBtn.className = "secondary";
        editBtn.textContent = "Edit";
        editBtn.addEventListener("click", () => {
          startRecipeEdit(r.id);
        });

        const delBtn = document.createElement("button");
        delBtn.type = "button";
        delBtn.className = "secondary";
        delBtn.textContent = "Delete";
        delBtn.addEventListener("click", () => {
          if (confirm(`Delete recipe "${r.name}"?`)) {
            recipes = recipes.filter((x) => x.id !== r.id);
            mealPlan.forEach((entry) => {
              if (entry.recipeId === r.id) {
                entry.recipeId = "";
                entry.servings = 0;
              }
            });
            renderRecipesList();
            renderMealPlan();
            saveState();
          }
        });

        actions.appendChild(editBtn);
        actions.appendChild(delBtn);
        header.appendChild(title);
        header.appendChild(actions);
        wrapper.appendChild(header);

        const ul = document.createElement("ul");
        r.ingredients.forEach((ing) => {
          const li = document.createElement("li");
          li.textContent =
            ing.name + ": " + ing.quantity + " " + (ing.unit || "");
          ul.appendChild(li);
        });
        wrapper.appendChild(ul);

        container.appendChild(wrapper);
      });

      renderMealPlan();
    }

    function startRecipeEdit(id) {
      const recipe = recipes.find((r) => r.id === id);
      if (!recipe) return;

      editingRecipeId = id;
      currentRecipe = {
        id: recipe.id,
        name: recipe.name,
        servings: recipe.servings,
        ingredients: recipe.ingredients.map((ing) => ({
          name: ing.name,
          quantity: ing.quantity,
          unit: ing.unit,
        })),
      };

      document.getElementById("recipe-name").value = currentRecipe.name;
      document.getElementById("recipe-servings").value =
        currentRecipe.servings;

      document
        .getElementById("recipe-ingredients-section")
        .classList.remove("hidden");
      document
        .getElementById("cancel-recipe-edit")
        .classList.remove("hidden");

      renderCurrentRecipeIngredients();
      clearIngredientEditState();
    }

    // ---------- MEAL PLAN ----------

    function renderMealPlan() {
      const container = document.getElementById("meal-plan-container");
      if (!container) return;
      container.innerHTML = "";

      if (!mealPlan || !mealPlan.length) initDefaultMealPlan();

      const validIds = new Set(recipes.map((r) => r.id));
      mealPlan.forEach((entry) => {
        if (entry.recipeId && !validIds.has(entry.recipeId)) {
          entry.recipeId = "";
          entry.servings = 0;
        }
      });

      mealPlan.forEach((entry) => {
        const row = document.createElement("div");
        row.className = "subpanel";

        const label = document.createElement("h3");
        label.textContent = entry.dayLabel;
        row.appendChild(label);

        const recipeLabel = document.createElement("label");
        recipeLabel.textContent = "Recipe";

        const select = document.createElement("select");
        select.dataset.dayId = entry.dayId;

        const defaultOpt = document.createElement("option");
        defaultOpt.value = "";
        defaultOpt.textContent = "(no meal selected)";
        select.appendChild(defaultOpt);

        recipes
          .slice()
          .sort((a, b) => a.name.localeCompare(b.name))
          .forEach((recipe) => {
            const opt = document.createElement("option");
            opt.value = recipe.id;
            opt.textContent = `${recipe.name} (serves ${recipe.servings})`;
            select.appendChild(opt);
          });

        select.value = entry.recipeId || "";
        select.addEventListener("change", (e) => {
          const id = e.target.dataset.dayId;
          const planEntry = mealPlan.find((p) => p.dayId === id);
          if (!planEntry) return;
          planEntry.recipeId = e.target.value;
          if (!planEntry.recipeId) {
            planEntry.servings = 0;
            const sInput = document.querySelector(
              `input[data-day-id="${id}"]`
            );
            if (sInput) sInput.value = "0";
          }
          saveState();
        });

        recipeLabel.appendChild(select);
        row.appendChild(recipeLabel);

        const servingsLabel = document.createElement("label");
        servingsLabel.textContent = "Planned servings";

        const servingsInput = document.createElement("input");
        servingsInput.type = "number";
        servingsInput.min = "0";
        servingsInput.step = "1";
        servingsInput.dataset.dayId = entry.dayId;
        servingsInput.value =
          entry.servings && entry.servings > 0 ? entry.servings : "0";

        servingsInput.addEventListener("change", (e) => {
          const id = e.target.dataset.dayId;
          const planEntry = mealPlan.find((p) => p.dayId === id);
          if (!planEntry) return;
          let val = parseFloat(e.target.value || "0");
          if (isNaN(val) || val < 0) val = 0;
          planEntry.servings = val;
          e.target.value = val === 0 ? "0" : String(val);
          saveState();
        });

        servingsLabel.appendChild(servingsInput);
        row.appendChild(servingsLabel);

        container.appendChild(row);
      });
    }

    // ---------- SHOPPING LIST ----------

    function generateShoppingList() {
  const required = {};

  // Work out how much is needed for all planned meals
  mealPlan.forEach((entry) => {
    if (!entry.recipeId) return;
    const plannedServings = parseFloat(entry.servings || "0");
    if (plannedServings <= 0) return;

    const recipe = recipes.find((r) => r.id === entry.recipeId);
    if (!recipe) return;

    const scale = plannedServings / recipe.servings;

    recipe.ingredients.forEach((ing) => {
      const key = ing.name.toLowerCase();
      const ingUnit = ing.unit || "";
      const baseUnit = required[key]
        ? required[key].baseUnit
        : chooseBaseUnit(ingUnit); // g/kg -> g, ml/l -> ml, else itself

      if (!required[key]) {
        required[key] = {
          name: ing.name,
          quantityBase: 0,
          baseUnit,
        };
      }

      const qtyScaled = ing.quantity * scale;
      const qtyInBase = convertToUnit(qtyScaled, ingUnit, required[key].baseUnit);
      required[key].quantityBase += qtyInBase;
    });
  });

  const tbody = document.querySelector("#shopping-table tbody");
  if (!tbody) return;
  tbody.innerHTML = "";

  // Helper to make numbers look tidy
  function formatNumberNice(n) {
    if (Number.isInteger(n)) return String(n);
    const oneDp = Math.round(n * 10) / 10;
    if (Number.isInteger(oneDp * 10)) return oneDp.toString();
    return (Math.round(n * 100) / 100).toString();
  }

  Object.keys(required).forEach((key) => {
    const need = required[key];
    const baseUnit = need.baseUnit;
    let requiredBase = need.quantityBase;

    // Work out what we already have in inventory (in the same base unit)
    let invQtyBase = 0;
    const invItem = inventory.find((i) => i.name.toLowerCase() === key);
    if (invItem && baseUnit) {
      invQtyBase = convertToUnit(invItem.quantity, invItem.unit || "", baseUnit);
    } else if (invItem && !baseUnit) {
      invQtyBase = invItem.quantity;
    }

    let toBuyBase = Math.max(0, requiredBase - invQtyBase);
    if (toBuyBase <= 1e-9) return; // nothing to buy ‚Üí skip row

    // Decide how to *display* that quantity
    let displayQty = toBuyBase;
    let displayUnit = baseUnit;

    // Rule we want:
    //  - if < 1000g/ml -> stay in g/ml
    //  - if >= 1000g/ml -> convert to kg/L
    if (baseUnit === "g") {
      if (displayQty >= 1000) {
        displayQty = displayQty / 1000;
        displayUnit = "kg";
      } else {
        displayUnit = "g";
      }
    } else if (baseUnit === "ml") {
      if (displayQty >= 1000) {
        displayQty = displayQty / 1000;
        displayUnit = "l";
      } else {
        displayUnit = "ml";
      }
    }

    // Build a nice string like "500g" or "1.5kg" or "2 packs"
    let qtyStr;
    if (!displayUnit) {
      qtyStr = formatNumberNice(displayQty);
    } else {
      const smallUnits = ["g", "kg", "ml", "l"];
      const nStr = formatNumberNice(displayQty);
      if (smallUnits.includes(displayUnit)) {
        qtyStr = nStr + displayUnit;
      } else {
        qtyStr = nStr + " " + displayUnit.toLowerCase();
      }
    }

    // Create table row
    const tr = document.createElement("tr");
    tr.dataset.itemName = need.name;
    tr.dataset.buyQty = String(displayQty);
    tr.dataset.buyUnit = displayUnit || "";

    const tdCheck = document.createElement("td");
    const cb = document.createElement("input");
    cb.type = "checkbox";
    cb.className = "shopping-bought";
    tdCheck.appendChild(cb);

    const tdName = document.createElement("td");
    tdName.textContent = need.name;

    const tdBuy = document.createElement("td");
    // Convert tiny kg / L amounts back to g / ml for display
let fixedQtyStr = qtyStr;
const match = qtyStr.match(/^(\d+(?:\.\d+)?)\s*(kg|KG|l|L)$/); // e.g. "0.5kg", "0.75L"

if (match) {
  let value = parseFloat(match[1]);
  const unit = match[2].toLowerCase();

  // helper to make the number look neat
  const tidy = (n) =>
    Number.isInteger(n) ? String(n) : (Math.round(n * 100) / 100).toString();

  if (unit === "kg" && value < 1) {
    // e.g. 0.5kg -> 500g
    const grams = value * 1000;
    fixedQtyStr = tidy(grams) + "g";
  } else if (unit === "l" && value < 1) {
    // e.g. 0.75L -> 750ml
    const ml = value * 1000;
    fixedQtyStr = tidy(ml) + "ml";
  }
}

tdBuy.textContent = fixedQtyStr;

    tr.appendChild(tdCheck);
    tr.appendChild(tdName);
    tr.appendChild(tdBuy);
    tbody.appendChild(tr);
  });

  // When you tick items, add them into inventory
  const checkboxes = tbody.querySelectorAll(".shopping-bought");
  checkboxes.forEach((cb) => {
    cb.addEventListener("change", () => {
      const tr = cb.closest("tr");
      if (!tr) return;
      if (!cb.checked || tr.dataset.applied === "true") return;

      const name = tr.dataset.itemName;
      const qty = parseFloat(tr.dataset.buyQty || "0");
      const unit = tr.dataset.buyUnit || "";
      if (!name || !qty || qty <= 0) return;

      upsertInventoryItem(name, qty, unit);
      tr.dataset.applied = "true";

      renderInventory();
      renderInventoryNameSuggestions();
      saveState();
    });
  });
}

    // ---------- NAVIGATION ----------

    function showPage(pageId) {
      const pages = document.querySelectorAll(".page");
      const navButtons = document.querySelectorAll(".app-nav button");

      pages.forEach((page) => {
        if (!page) return;
        page.classList.toggle("hidden", page.id !== pageId);
      });

      navButtons.forEach((btn) => {
        if (!btn) return;
        const controls = btn.getAttribute("aria-controls");
        btn.setAttribute(
          "aria-selected",
          controls === pageId ? "true" : "false"
        );
      });
    }

    // ---------- INIT ----------

    document.addEventListener("DOMContentLoaded", () => {
      loadState();
        const menuToggle = document.getElementById("menu-toggle");
  const appNav = document.getElementById("app-nav");

  if (menuToggle && appNav) {
    menuToggle.addEventListener("click", () => {
      const isOpen = appNav.classList.toggle("nav-open");
      menuToggle.setAttribute("aria-expanded", isOpen ? "true" : "false");
    });
  }

        // Nav
  document
    .getElementById("nav-inventory")
    .addEventListener("click", () => {
      showPage("page-inventory");
      if (appNav) appNav.classList.remove("nav-open");
      if (menuToggle) menuToggle.setAttribute("aria-expanded", "false");
    });

  document
    .getElementById("nav-recipes")
    .addEventListener("click", () => {
      showPage("page-recipes");
      if (appNav) appNav.classList.remove("nav-open");
      if (menuToggle) menuToggle.setAttribute("aria-expanded", "false");
    });

  document
    .getElementById("nav-mealplan")
    .addEventListener("click", () => {
      showPage("page-mealplan");
      if (appNav) appNav.classList.remove("nav-open");
      if (menuToggle) menuToggle.setAttribute("aria-expanded", "false");
    });

  document
    .getElementById("nav-shopping")
    .addEventListener("click", () => {
      showPage("page-shopping");
      if (appNav) appNav.classList.remove("nav-open");
      if (menuToggle) menuToggle.setAttribute("aria-expanded", "false");
    });

  showPage("page-inventory");

      // Inventory events
      const invForm = document.getElementById("inventory-form");
      const searchInput =
        document.getElementById("inventory-search");
      const cancelInvEditBtn =
        document.getElementById("inventory-cancel-edit");
      const fakeScanBtn = document.getElementById("fake-scan-btn");

      invForm.addEventListener("submit", (e) => {
        e.preventDefault();
        const name =
          document.getElementById("inv-name").value.trim();
        const qty = parseFloat(
          document.getElementById("inv-qty").value || "0"
        );
        const unit =
          document.getElementById("inv-unit").value || "";

        if (!name || qty <= 0) {
          alert("Please enter a valid name and quantity.");
          return;
        }

        if (editingInventoryKey) {
          setInventoryItemExact(
            editingInventoryKey,
            name,
            qty,
            unit
          );
          clearInventoryEditState();
        } else {
          upsertInventoryItem(name, qty, unit);
          document.getElementById("inv-name").value = "";
          document.getElementById("inv-qty").value = "1";
          document.getElementById("inv-unit").value = "";
        }

        renderInventory();
        renderInventoryNameSuggestions();
        saveState();
      });

      cancelInvEditBtn.addEventListener("click", () => {
        clearInventoryEditState();
      });

      searchInput.addEventListener("input", () => {
        inventoryFilter = searchInput.value || "";
        renderInventory();
      });

      fakeScanBtn.addEventListener("click", () => {
        handleFakeBarcodeScan();
      });

      // Recipes events
      const startRecipeBtn = document.getElementById("start-recipe");
      const ingSection = document.getElementById(
        "recipe-ingredients-section"
      );
      const cancelRecipeEditBtn =
        document.getElementById("cancel-recipe-edit");
      const importBtn = document.getElementById(
        "import-ingredients-btn"
      );

      startRecipeBtn.addEventListener("click", () => {
        const name =
          document.getElementById("recipe-name").value.trim();
        const servings = parseFloat(
          document.getElementById("recipe-servings").value || "0"
        );
        if (!name || servings <= 0) {
          alert("Please enter a recipe name and servings.");
          return;
        }

        if (!currentRecipe || !editingRecipeId) {
          currentRecipe = {
            id: editingRecipeId || String(Date.now()),
            name: titleCase(name),
            servings,
            ingredients: [],
          };
        } else {
          currentRecipe.name = titleCase(name);
          currentRecipe.servings = servings;
        }

        ingSection.classList.remove("hidden");
        renderCurrentRecipeIngredients();
        if (editingRecipeId) {
          cancelRecipeEditBtn.classList.remove("hidden");
        } else {
          cancelRecipeEditBtn.classList.add("hidden");
        }
        clearIngredientEditState();
      });

      cancelRecipeEditBtn.addEventListener("click", () => {
        clearRecipeEditState();
      });

      const ingForm = document.getElementById("ingredient-form");
      ingForm.addEventListener("submit", (e) => {
        e.preventDefault();
        if (!currentRecipe) {
          alert("Start a recipe first.");
          return;
        }

        const name =
          document.getElementById("ing-name").value.trim();
        const qty = parseFloat(
          document.getElementById("ing-qty").value || "0"
        );
        const unit =
          document.getElementById("ing-unit").value.trim();

        if (!name || qty <= 0) {
          alert("Please enter a valid ingredient name & quantity.");
          return;
        }

        const cleanName = titleCase(name);

        if (editingIngredientIndex !== null) {
          currentRecipe.ingredients[editingIngredientIndex] = {
            name: cleanName,
            quantity: qty,
            unit,
          };
          clearIngredientEditState();
        } else {
          currentRecipe.ingredients.push({
            name: cleanName,
            quantity: qty,
            unit,
          });
        }

        renderCurrentRecipeIngredients();
      });

      document
        .getElementById("cancel-ingredient-edit")
        .addEventListener("click", () => {
          clearIngredientEditState();
        });

      importBtn.addEventListener("click", () => {
        if (!currentRecipe) {
          alert(
            "Start a recipe first (name + servings, then 'Start new recipe')."
          );
          return;
        }

        const textarea =
          document.getElementById("import-text");
        const raw = textarea.value || "";
        const lines = raw.split(/\r?\n/);

        let imported = 0;

        lines.forEach((line) => {
          const parsed = parseIngredientLine(line);
          if (!parsed || !parsed.name || parsed.quantity <= 0) {
            return;
          }
          currentRecipe.ingredients.push(parsed);
          imported++;
        });

        renderCurrentRecipeIngredients();
        if (imported) {
          alert(`Imported ${imported} ingredient(s).`);
          textarea.value = "";
        } else {
          alert("No valid ingredients found.");
        }
      });

      document
        .getElementById("save-recipe")
        .addEventListener("click", () => {
          if (!currentRecipe) {
            alert("No recipe in progress.");
            return;
          }
          if (
            !currentRecipe.ingredients ||
            !currentRecipe.ingredients.length
          ) {
            alert("Add at least one ingredient.");
            return;
          }

          if (editingRecipeId) {
            const idx = recipes.findIndex(
              (r) => r.id === editingRecipeId
            );
            if (idx !== -1) {
              recipes[idx] = {
                id: editingRecipeId,
                name: currentRecipe.name,
                servings: currentRecipe.servings,
                ingredients: currentRecipe.ingredients,
              };
            }
          } else {
            recipes.push(currentRecipe);
          }

          clearRecipeEditState();
          renderRecipesList();
          saveState();
        });

      // Meal plan & shopping
      document
        .getElementById("generate-shopping-list")
        .addEventListener("click", () => {
          generateShoppingList();
          showPage("page-shopping");
        });

      // Initial renders
      renderInventory();
      renderInventoryNameSuggestions();
      renderRecipesList();
      renderMealPlan();
    });

    // Keep service worker registration small & safe
    if ("serviceWorker" in navigator) {
      navigator.serviceWorker
        .register("./sw.js")
        .catch(() => {});
    }
  </script>
</body>
</html>