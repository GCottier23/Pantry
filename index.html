<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport"
  content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover"/>
  <meta name="color-scheme" content="dark light" />
  <title>Pantry App</title>

  <link rel="stylesheet" href="styles.css?v=23"/>

  <!-- PWA -->
  <link rel="apple-touch-icon" sizes="180x180" href="icon-180.png">
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#ff7a00">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
</head>

<body>

  <!-- TOP BAR -->
  <header class="top-bar">
    <span class="top-bar-title">Pantry App</span>
  </header>

  <!-- NAVIGATION BUTTONS -->
  <nav id="app-nav" class="app-nav" role="tablist" aria-label="Pantry navigation">
    <button id="nav-inventory" aria-controls="page-inventory" aria-selected="true" type="button">Inventory</button>
    <button id="nav-recipes" aria-controls="page-recipes" aria-selected="false" type="button">Recipes</button>
    <button id="nav-mealplan" aria-controls="page-mealplan" aria-selected="false" type="button">Meal plan</button>
    <button id="nav-shopping" aria-controls="page-shopping" aria-selected="false" type="button">Shopping list</button>
  </nav>

 <!-- ======================================= -->
<!-- PAGE 1 ‚Äì INVENTORY                      -->
<!-- ======================================= -->
<main id="page-inventory" class="page" role="tabpanel" aria-labelledby="nav-inventory">

  <!-- Panel 1: Inventory title + buttons -->
  <section class="panel">
    <h2>Inventory</h2>

    <div class="primary-pair-row">
      <button id="add-inventory-item-btn" class="primary-pill">Add Item</button>
      <button id="real-scan-btn" class="primary-pill">Scan barcode</button>
    </div>
  </section>

  <!-- Panel 2: Inventory list -->
  <section class="panel">
    <div id="inventory-list" class="inventory-list"></div>
  </section>

</main>

  <!-- ======================================= -->
  <!-- PAGE 2 ‚Äì RECIPES                        -->
  <!-- ======================================= -->
  <section id="page-recipes" class="page hidden" role="tabpanel" aria-labelledby="nav-recipes">
    <section class="panel">
      <h2>Recipes</h2>

    <div class="primary-pair-row">
  <button id="add-recipe-btn" class="primary-pill">Add Recipe</button>
  <button id="import-recipe-btn" class="primary-pill">Import Recipe</button>
</div>

      <div id="recipe-import-card" class="recipe-import card hidden">
        <h2>Import from BBC Food</h2>

        <p>Paste a BBC link and tap "Fetch image".</p>

        <div class="recipe-import-row">
          <input type="url" id="recipe-import-url" placeholder="https://www.bbc.co.uk/food/recipes/..." />
          <button id="recipe-fetch-image" type="button">Fetch image</button>
          <button id="recipe-clear-import" type="button" class="secondary">Clear</button>
        </div>

        <p id="recipe-import-status" class="import-status"></p>

        <div class="recipe-image-preview-wrapper">
          <img id="recipe-image-preview" class="recipe-image-preview" alt="Recipe preview" style="display:none;">
        </div>
      </div>

      <!-- Legacy inline recipe editor -- stays hidden -->
      <form id="recipe-form" class="hidden">
        <label>Recipe name <input id="recipe-name" type="text"></label>
        <label>Servings <input id="recipe-servings" type="number" value="2" min="1"></label>

        <div class="form-actions">
          <button id="start-recipe" type="button">Start new recipe</button>
          <button id="cancel-recipe-edit" type="button" class="secondary hidden">Cancel</button>
        </div>
      </form>

      <div id="recipe-ingredients-section" class="subpanel hidden">
        <h3>Ingredients for current recipe</h3>

        <form id="ingredient-form">
          <label>Ingredient name <input id="ing-name" type="text"></label>

          <div class="grid-2">
            <label>Quantity <input id="ing-qty" type="number" value="1" min="0" step="0.1"></label>
            <label>Unit <input id="ing-unit" type="text" placeholder="g, ml, pcs‚Ä¶"></label>
          </div>

          <div class="form-actions">
            <button type="submit">Add ingredient</button>
            <button id="cancel-ingredient-edit" type="button" class="secondary hidden">Cancel</button>
          </div>
        </form>

        <ul id="current-recipe-ingredients"></ul>

        <button id="save-recipe" type="button">Save recipe</button>

        <div class="subpanel">
          <h3>Quick import from text</h3>
          <textarea id="import-text" rows="6"></textarea>
          <button id="import-ingredients-btn" type="button">Import into current recipe</button>
        </div>
      </div>

    </section>

    <section class="panel">
      <h2>Saved recipes</h2>
      <p>These can be used in your meal plan.</p>
      <div id="recipes-list"></div>
    </section>

  </section>

  <!-- ======================================= -->
  <!-- PAGE 3 ‚Äì MEAL PLAN                      -->
  <!-- ======================================= -->
  <section id="page-mealplan" class="page hidden">
 <div class="panel">
  <h2>Meal plan</h2>

<div class="primary-pair-row">
  <button id="mealplan-pick-week" class="primary-pill">Pick week</button>
  <button id="mealplan-generate-list"
          class="primary-pill ios-green-button">
    Generate list
  </button>
</div>
</div>

  <div id="mealplan-days">

    <!-- TEMP PREVIEW ‚Äî Monday -->
<article class="mealplan-day-card">
  <header class="mealplan-day-header">
    <div>
      <div class="mealplan-day-name">Monday</div>
      <div class="mealplan-day-date">24 Nov</div>
    </div>
  </header>

  <!-- Breakfast -->
  <div class="mealplan-slot">
    <div class="mealplan-slot-label">Breakfast</div>
    <button type="button" class="mealplan-slot-button">Add recipe</button>
  </div>

  <!-- Lunch -->
  <div class="mealplan-slot">
    <div class="mealplan-slot-label">Lunch</div>
    <button type="button" class="mealplan-slot-button">Add recipe</button>
  </div>

  <!-- Dinner -->
  <div class="mealplan-slot">
    <div class="mealplan-slot-label">Dinner</div>
    <button type="button" class="mealplan-slot-button">Add recipe</button>
  </div>
</article>

    <!-- TEMP PREVIEW ‚Äî Copy/paste for other days if you want -->
  </div>
</section>

  <!-- ======================================= -->
  <!-- PAGE 4 ‚Äì SHOPPING LIST                  -->
  <!-- ======================================= -->
  <section id="page-shopping" class="page hidden" role="tabpanel" aria-labelledby="nav-shopping">
    <section class="panel">
      <h2>Shopping list</h2>
      <p>Based on your meal plan & inventory.</p>

      <table id="shopping-table">
        <thead>
          <tr>
            <th>‚úì</th>
            <th>Item</th>
            <th>To buy</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </section>
  </section>

<!-- Barcode scanner library (UMD build, exposes global ZXingBrowser) -->
<script src="https://unpkg.com/@zxing/browser@latest/umd/zxing-browser.min.js"></script>

  <!-- =============== JAVASCRIPT =============== -->
  <script>
    const WORKER_BASE = "https://icy-rain-e28c.gaz-cottier23.workers.dev";

    // ==========================================
    //          GENERAL/RECIPE HELPERS   
    // ==========================================  
    
    // ========= TEXT / FORMATTING ==============

function titleCase(str) {
      return str
        .toLowerCase()
        .split(" ")
        .filter(Boolean)
        .map((w) => w.charAt(0).toUpperCase() + w.slice(1))
        .join(" ");
    }

function tidyRecipeTitle(str) {
      if (!str) return "";
      let t = str.trim();
      // Strip trailing " - BBC Food" / " - BBC Good Food"
      t = t.replace(/\s*-\s*BBC\s*Food\s*$/i, "");
      t = t.replace(/\s*-\s*BBC\s*Good\s*Food\s*$/i, "");
      return t;
    }

function parseServingsNumber(servingsText) {
      if (!servingsText) return null;
      // Look for the first number: "Serves 8-10" -> 8
      const m = servingsText.match(/(\d+)/);
      if (!m) return null;
      const n = parseInt(m[1], 10);
      return Number.isNaN(n) ? null : n;
    }

    // ========= UNITS . QUANTITIES ==============

function convertToUnit(qty, fromUnit, toUnit) {
      const n = Number(qty);
      if (!Number.isFinite(n)) return 0;

      const from = (fromUnit || "").toLowerCase();
      const to   = (toUnit   || "").toLowerCase();

      // If no target unit, just return the raw quantity
      if (!to) return n;

      // Same unit ‚Äì no conversion needed
      if (from === to) return n;

      // ----- WEIGHT -----
      if (from === "g" && to === "kg") return n / 1000;
      if (from === "kg" && to === "g") return n * 1000;

      // ----- VOLUME -----
      if (from === "ml" && to === "l") return n / 1000;
      if (from === "l" && to === "ml") return n * 1000;

      // ----- WINE BOTTLES ‚Üî ml (750ml per bottle) -----
      if (from === "bottle"  && to === "ml") return n * 750;
      if (from === "bottles" && to === "ml") return n * 750;
      if (from === "ml" && to === "bottle")  return n / 750;
      if (from === "ml" && to === "bottles") return n / 750;

      // Unknown conversion ‚Äì just treat as equivalent units
      return n;
    } 

function chooseBaseUnit(unit, name) {
  const u = (unit || "").toLowerCase();
  const lowerName = (name || "").toLowerCase();

  // Weight: always aggregate in grams
  if (u === "g" || u === "kg") {
    return "g";
  }

  // Volume: always aggregate in millilitres
  if (u === "ml" || u === "l") {
    return "ml";
  }

  // Wine bottles ‚Üí treat as ml internally (750ml per bottle)
  if ((u === "bottle" || u === "bottles") && lowerName.includes("wine")) {
    return "ml";
  }

  // Everything else ‚Äì stay as whatever unit we have (tsp, tbsp, pack, etc.)
  return u || "";
}
  
function formatQuantityWithUnit(q, unit) {
  if (q == null || Number.isNaN(q)) return "";

  let qty = Number(q);
  let unitLower = (unit || "").toLowerCase();

  const compactUnits = ["g", "kg", "ml", "l"];

  // Compact only g/kg/ml/l ‚Äì leave bottles, sticks, cloves alone
  if (
    compactUnits.includes(unitLower) &&
    typeof autoCompactQuantityUnit === "function"
  ) {
    const compacted = autoCompactQuantityUnit(qty, unitLower);
    if (compacted && typeof compacted === "object") {
      qty = compacted.quantity;
      unitLower = (compacted.unit || "").toLowerCase();
    }
  }

  const niceQty =
    typeof formatQuantityForDisplay === "function"
      ? formatQuantityForDisplay(qty)
      : qty;

  let label = "";

  if (unitLower === "l") {
    // litres get spelled out, and pluralised
    const word =
      typeof pluraliseUnit === "function"
        ? pluraliseUnit("l", qty)
        : qty === 1
        ? "litre"
        : "litres";
    label = `${niceQty} ${word}`;
  } else if (["g", "kg", "ml"].includes(unitLower)) {
    // compact small units
    label = `${niceQty}${unitLower}`;
  } else if (unitLower) {
    // everything else (bottle, stick, clove, sprig‚Ä¶)
    const word =
      typeof pluraliseUnit === "function"
        ? pluraliseUnit(unitLower, qty)
        : qty === 1
        ? unitLower
        : unitLower + "s";
    label = `${niceQty} ${word}`;
  } else {
    // no unit ‚Äì just the number
    label = `${niceQty}`;
  }

  return label;
}

function autoCompactQuantityUnit(q, unit) {

  if (q == null || Number.isNaN(q)) return { quantity: q, unit };

  const u = (unit || "").toLowerCase();

  // --- Convert ml ‚Üí litres when >= 1000ml ---
  if (u === "ml") {
    if (q >= 1000) {
      const litres = q / 1000;
      return { quantity: litres, unit: "l" };  // ‚Üê IMPORTANT: keep "l"
    } else {
      return { quantity: q, unit: "ml" };
    }
  }

  // --- Convert g ‚Üí kg when >= 1000g ---
  if (u === "g") {
    if (q >= 1000) {
      const kg = q / 1000;
      return { quantity: kg, unit: "kg" };
    } else {
      return { quantity: q, unit: "g" };
    }
  }

  // Otherwise no change
  return { quantity: q, unit };
}

// ========= STAPLES + UNIT LOGIC ==============

const UNIT_DEFS = {
  g:      { singular: "g",      plural: "g" },
  kg:     { singular: "kg",     plural: "kg" },
  ml:     { singular: "ml",     plural: "ml" },
  l:      { singular: "litre",  plural: "litres" },

  tsp:    { singular: "tsp",    plural: "tsp" },
  tbsp:   { singular: "tbsp",   plural: "tbsp" },

  stick:  { singular: "stick",  plural: "sticks" },
  clove:  { singular: "clove",  plural: "cloves" },
  sprig:  { singular: "sprig",  plural: "sprigs" },
  bottle: { singular: "bottle", plural: "bottles" },
  pack:   { singular: "pack",   plural: "packs" },
  jar:    { singular: "jar",    plural: "jars" },

};

function normaliseUnit(unit) {
  if (!unit) return "";
  let u = String(unit).toLowerCase().trim();

  // Exact match?
  if (UNIT_DEFS[u]) return u;

  // Litres variations
  if (u === "litre" || u === "litres") return "l";

  // Try chopping common plural endings
  if (u.endsWith("es")) {
    const maybe = u.slice(0, -2); // e.g. "cloves" -> "clov"
    if (UNIT_DEFS[maybe]) return maybe;
  }
  if (u.endsWith("s")) {
    const maybe = u.slice(0, -1); // e.g. "sticks" -> "stick"
    if (UNIT_DEFS[maybe]) return maybe;
  }

  return u; // fallback ‚Äì unknown unit, leave as-is
}

function pluraliseUnit(unit, quantity) {
  const key = normaliseUnit(unit);
  const def = UNIT_DEFS[key];
  const q = Number(quantity || 0);

  // If we don't recognise this unit, fall back to a simple "add s"
  if (!def) {
    const raw = unit || "";
    if (!raw) return "";          // no unit at all
    if (q === 1) return raw;      // singular
    return raw.endsWith("s") ? raw : raw + "s";
  }

  // Known unit ‚Üí use the singular/plural text from UNIT_DEFS
  return q === 1 ? def.singular : def.plural;
}

const DEFAULT_STAPLE_KEYWORDS = [
    "salt",
    "sea salt",
    "black pepper",
    "olive oil",
    "vegetable oil",
    "sunflower oil",
    "cooking oil",
    "nutmeg",
    "stock cube",
    "stock cubes",
    "soy sauce"
  ];

function isStapleIngredient(name) {
  if (!name) return false;

  const lower = name.toLowerCase().trim();

  // 1) User-marked staples (from long-press ‚ÄúMark as staple‚Äù)
  if (Array.isArray(window.userStaples)) {
    if (window.userStaples.includes(lower)) {
      return true;
    }
  }

  // 2) Always-in-cupboard list, if you have one
  if (Array.isArray(window.ALWAYS_IN_CUPBOARD)) {
    if (window.ALWAYS_IN_CUPBOARD.includes(lower)) {
      return true;
    }
  }

  // Normalise ingredient name into words
  const words = lower
    .replace(/[^a-z0-9]+/g, " ")
    .trim()
    .split(/\s+/);

  const normalised = " " + words.join(" ") + " ";

  // Match keywords as whole words / phrases
  return DEFAULT_STAPLE_KEYWORDS.some((rawKw) => {
    const kw = rawKw.toLowerCase().trim();
    const parts = kw.split(/\s+/);

    if (parts.length === 1) {
      // Single-word staple ‚Üí must match whole word
      return words.includes(kw);
    } else {
      // Multi-word staple ‚Üí full phrase, e.g. "black pepper"
      return normalised.includes(" " + kw + " ");
    }
  });
}

function toggleUserStaple(name) {
  if (!name) return;
  const lower = name.toLowerCase().trim();
  if (!lower) return;

  // make sure array exists
  if (!Array.isArray(userStaples)) {
    userStaples = [];
  }

  const idx = userStaples.indexOf(lower);
  if (idx === -1) {
    userStaples.push(lower);
  } else {
    userStaples.splice(idx, 1);
  }
  saveState();
}

function splitIngredientsByStaples(ingredients) {
  const staples = [];
  const regular = [];

  (ingredients || []).forEach((ing, index) => {
    if (!ing || !ing.name) return;
    const bucket = isStapleIngredient(ing.name) ? staples : regular;
    bucket.push({ ing, index }); // remember which ingredient it was
  });

  return { staples, regular };
}

// ========= INGREDIENT PARSING ==============
    
function parseBbcIngredient(rawLine, ingredientNames) {
  const line = (rawLine || "").trim();
  if (!line) return null;

  // Normalise long-form units so we can match them
  let normLine = line
    .replace(/grams?/gi, "g")
    .replace(/millilitres?|milliliters?/gi, "ml")
    .replace(/litres?|liters?/gi, "l")
    .replace(/tablespoons?/gi, "tbsp")
    .replace(/teaspoons?/gi, "tsp");

  const lower = normLine.toLowerCase();

  // --- 1. Find the best matching ingredient name from ingredientNames ---
  let bestName = null;
  let bestIndex = -1;
  let bestLen = 0;

  (ingredientNames || []).forEach((name) => {
    const nLower = name.toLowerCase();
    const idx = lower.indexOf(nLower);
    if (idx !== -1 && nLower.length > bestLen) {
      bestName = name;
      bestIndex = idx;
      bestLen = nLower.length;
    }
  });

  // If we can‚Äôt find a clean name, fall back to the generic parser
  if (!bestName) {
    return parseIngredientLine(normLine);
  }

  const before = normLine.slice(0, bestIndex).trim(); // text before name
  const after  = normLine.slice(bestIndex + bestName.length).trim(); // text after

  let quantity = 0;
  let unit = "";

  // Only care about the *first* metric ‚Äì drop anything after a slash
  let qtyText = before;
  if (qtyText.includes("/")) {
    qtyText = qtyText.split("/")[0].trim(); // "1.2 l/2 pints" -> "1.2 l"
  }

  // --- 2. Pattern: "2 x 400g tins" -> 800 g ---
  let m = qtyText.match(
    /(\d+(?:\.\d+)?)\s*[x√ó]\s*(\d+(?:\.\d+)?)\s*(g|kg|ml|l)\b/i
  );
  if (m) {
    const count = parseFloat(m[1]);
    const size  = parseFloat(m[2]);
    let u       = m[3].toLowerCase();

    let baseQty = count * size; // e.g. 2 * 400 = 800

    if (u === "kg") {
      baseQty *= 1000;
      u = "g";
    } else if (u === "l") {
      baseQty *= 1000;
      u = "ml";
    }

    quantity = baseQty;
    unit     = u;
  } else {
    // --- 3. Metric stuck to the number, like "900g" or "150ml" ---
    let m2 = qtyText.match(/(\d+(?:\.\d+)?)(g|kg|ml|l)\b/i);
    if (m2) {
      quantity = parseFloat(m2[1]);
      unit = m2[2].toLowerCase();

      if (unit === "kg") {
        quantity *= 1000;
        unit = "g";
      } else if (unit === "l") {
        quantity *= 1000;
        unit = "ml";
      }
    } else {
      // --- 4. "number unit" with a space, like "2 tbsp" or "1.2 l" ---
      const numMatch  = qtyText.match(/(\d+(?:\.\d+)?)/);
      const unitMatch = qtyText.match(/\b(g|kg|ml|l|tsp|tbsp)\b/i);

      if (numMatch) {
        quantity = parseFloat(numMatch[1]);
      }
      if (unitMatch) {
        unit = unitMatch[1].toLowerCase();
        if (unit === "kg") {
          quantity *= 1000;
          unit = "g";
        } else if (unit === "l") {
          quantity *= 1000;
          unit = "ml";
        }
      }

      // --- 5. Wordy units like "cloves", "sticks", "tins" ---
      if (!unit && quantity > 0) {
        const unitWords = [
          "clove", "cloves",
          "stick", "sticks",
          "tin", "tins",
          "packet", "packets",
          "pack", "packs",
          "bottle", "bottles",
          "sprig", "sprigs"
        ];

        if (after) {
          const firstWord = after
            .split(/[ ,()]/)
            .filter(Boolean)[0];
          if (firstWord && unitWords.includes(firstWord.toLowerCase())) {
            unit = firstWord.toLowerCase();
          }
        }
      }

      // No number at all (e.g. salt/pepper line) ‚Üí assume 1
      if (!numMatch) {
        quantity = 1;
      }
    }
  }

  return {
    name: titleCase(bestName),
    quantity,
    unit,
  };
}
    
function parseIngredientLine(line) {
  let trimmed = line.trim();
  if (!trimmed) return null;

  // Normalise common long-form units to short ones
  let cleaned = trimmed
    .replace(/grams?/gi, "g")
    .replace(/millilitres?|milliliters?/gi, "ml")
    .replace(/litres?|liters?/gi, "l")
    .replace(/tablespoons?/gi, "tbsp")
    .replace(/teaspoons?/gi, "tsp");

  // Strip trailing notes after comma (e.g. ", sliced", ", finely chopped")
  const commaIndex = cleaned.indexOf(",");
  if (commaIndex !== -1) cleaned = cleaned.slice(0, commaIndex).trim();

  const parts = cleaned.split(/\s+/);
  if (!parts.length) return null;

  // Map lots of unit spellings ‚Üí short forms
  const unitMap = {
    g: "g",
    kg: "kg",
    ml: "ml",
    l: "l",

    tsp: "tsp",
    tbsp: "tbsp",

    pack: "pack",
    packs: "packs",

    clove: "clove",
    cloves: "cloves",

    stick: "stick",
    sticks: "sticks",
  };

  // Words we DON'T want to keep at the start of the ingredient name
  const noiseWords = new Set([
    "pint", "pints",
    "cup", "cups",
    "level", "heaped",
    "large", "small", "medium"
  ]);

  let quantity;
  let unit = "";
  let nameWords = [];

  const first = parts[0];

  // 1) Try "inline unit" in first token, e.g. "150ml", "225g"
  const inlineMatch = first.match(/^([\d.]+)([a-zA-Z]+)$/);
  if (inlineMatch) {
    quantity = parseFloat(inlineMatch[1]);
    if (isNaN(quantity) || quantity <= 0) {
      return { name: titleCase(trimmed), quantity: 1, unit: "" };
    }
    const unitRaw = inlineMatch[2].toLowerCase();
    const unitClean = unitRaw.replace(/[^a-z]/g, ""); // strip odd chars
    unit = unitMap[unitClean] || "";
    nameWords = parts.slice(1);
  } else {
    // 2) Normal case: first token is just the number, second is (maybe) the unit
    quantity = parseFloat(first);
    if (isNaN(quantity) || quantity <= 0) {
      // No leading number ‚Üí treat whole line as name
      return { name: titleCase(trimmed), quantity: 1, unit: "" };
    }

    if (parts.length === 1) {
      // Just "2" or "500" etc.
      return { name: "", quantity, unit: "" };
    }

    const secondRaw = parts[1].toLowerCase();
    const unitClean = secondRaw.replace(/[^a-z]/g, ""); // e.g. "l/2" ‚Üí "l"

    if (unitMap[unitClean]) {
      unit = unitMap[unitClean];
      nameWords = parts.slice(2);
    } else {
      unit = "";
      nameWords = parts.slice(1);
    }
  }

  // Strip leading noise words from the ingredient name
  while (nameWords.length && noiseWords.has(nameWords[0].toLowerCase())) {
    nameWords.shift();
  }

  return {
    name: titleCase(nameWords.join(" ")),
    quantity,
    unit,
  };
}

// ========= NUMERIC ROUND-UP HELPER ==============

function roundUpForShopping(qty, unit) {
  const n = Number(qty);
  const u = (unit || "").toLowerCase();

  if (!Number.isFinite(n) || n <= 0) {
    return 0;
  }

  // Units you buy in whole items (no decimals)
  const countUnits = [
    "",                 // no unit ‚Üí whole items (onions, limes, etc.)
    "bottle", "bottles",
    "pack", "packs",
    "jar", "jars",
    "tin", "tins",
    "can", "cans",
    "sprig", "sprigs",
    "bunch", "bunches",
    "loaf", "loaves",
    "bag", "bags"
  ];

  if (countUnits.includes(u)) {
    return Math.ceil(n);
  }

  // For your use-case: litres and kg should also be whole numbers (no 1.2L)
  if (u === "l" || u === "kg") {
    return Math.ceil(n);
  }

  // For g / ml we‚Äôre already aggregating in base units, whole numbers are fine
  if (u === "g" || u === "ml") {
    return Math.ceil(n);
  }

  // Fallback ‚Äì play safe and round up
  return Math.ceil(n);
}

function dedupeStaplesByName(staples) {
  const byName = new Map();

  (staples || []).forEach((obj) => {
    if (!obj || !obj.ing || !obj.ing.name) return;

    const key = obj.ing.name.toLowerCase().trim();
    if (!key) return;

    const existing = byName.get(key);
    if (!existing) {
      // First time we see this ingredient name ‚Üí keep this one
      byName.set(key, obj);
      return;
    }

    // If we already have one, decide which to keep.
    // Simple rule: prefer the one that actually has a numeric quantity.
    const hasQty = (x) =>
      x.ing.quantity !== null &&
      x.ing.quantity !== undefined &&
      !Number.isNaN(x.ing.quantity) &&
      x.ing.quantity > 0;

    if (!hasQty(existing) && hasQty(obj)) {
      byName.set(key, obj);
    }
    // otherwise keep the existing one
  });

  return Array.from(byName.values());
}   

// ---------- STATE ----------

const STORAGE_KEY = "pantryApp_simple_v1";

  let inventory = [];
  let recipes = [];
  let mealPlan = [];
  let barcodeMap = {}; // barcode -> {name, baseQty, unit}

  let inventoryFilter = "";
  let editingInventoryKey = null;

  let currentRecipe = null;
  let editingRecipeId = null;
  let editingIngredientIndex = null;

  let lastImportedRecipeMeta = null; // { instructions: [...], sourceUrl, servingsText }

function loadState() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);

    if (!raw) {
      // First run / nothing saved yet
      inventory    = [];
      recipes      = [];
      mealPlan     = [];
      userStaples  = [];
      barcodeMap   = {};
      window.barcodeMap = barcodeMap;   // keep in sync
      return;
    }

    const data = JSON.parse(raw);

    // Inventory
    if (Array.isArray(data.inventory)) {
      inventory = data.inventory;
    } else {
      inventory = [];
    }

    // Recipes
    if (Array.isArray(data.recipes)) {
      recipes = data.recipes;
    } else {
      recipes = [];
    }

    // Meal plan
    if (Array.isArray(data.mealPlan)) {
      mealPlan = data.mealPlan;
    } else {
      mealPlan = [];
    }

    // User staples (if you use this elsewhere)
    if (Array.isArray(data.userStaples)) {
      userStaples = data.userStaples;
    } else {
      userStaples = [];
    }

    // ‚≠ê Barcode map
    if (data.barcodeMap && typeof data.barcodeMap === "object") {
      barcodeMap = data.barcodeMap;
    } else {
      barcodeMap = {};
    }
    window.barcodeMap = barcodeMap;  // one canonical object

  } catch (e) {
    console.error("Failed to load state", e);

    // Fallback to completely clean defaults if anything goes wrong
    inventory    = [];
    recipes      = [];
    mealPlan     = [];
    userStaples  = [];
    barcodeMap   = {};
    window.barcodeMap = barcodeMap;
  }
}

function saveState() {
  try {
    // Make sure we have one canonical barcodeMap object
    const safeBarcodeMap = window.barcodeMap || barcodeMap || {};

    // Keep both globals in sync
    barcodeMap = safeBarcodeMap;
    window.barcodeMap = safeBarcodeMap;

    localStorage.setItem(
      STORAGE_KEY,
      JSON.stringify({
        inventory,
        recipes,
        mealPlan,
        barcodeMap: safeBarcodeMap,  // be explicit
        userStaples
      })
    );
  } catch (e) {
    console.error("Failed to save", e);
  }
}

    // ==========================================
    //          INVENTORY HELPERS
    // ==========================================  

function normalizeInventoryItem(item) {
      if (item.unit === "g" && item.quantity >= 1000) {
        item.quantity = item.quantity / 1000;
        item.unit = "kg";
      } else if (item.unit === "ml" && item.quantity >= 1000) {
        item.quantity = item.quantity / 1000;
        item.unit = "l";
      }
    }

function formatItemNameForDisplay(str) {
  if (!str) return "";

  return str
    .toLowerCase()
    .split(/\s+/)  // split on any whitespace
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(" ");
}

function renderInventoryNameSuggestions() {
      const dl = document.getElementById("inv-name-list");
      if (!dl) return;
      dl.innerHTML = "";
      inventory
        .slice()
        .sort((a, b) => a.name.localeCompare(b.name))
        .forEach((item) => {
          const opt = document.createElement("option");
          opt.value = item.name;
          dl.appendChild(opt);
        });
    }

function attachInventorySwipe(row, item) {
  let startX = 0;
  let startY = 0;
  let activeId = null;
  let swiping = false;

  function resetTransform() {
    row.style.transition = "transform 0.15s ease-out";
    row.style.transform = "translateX(0)";
    setTimeout(() => {
      row.style.transition = "";
    }, 160);
  }

  row.addEventListener("pointerdown", (e) => {
    activeId = e.pointerId;
    startX = e.clientX;
    startY = e.clientY;
    swiping = true;
    row.setPointerCapture(activeId);
  });

  row.addEventListener("pointermove", (e) => {
    if (!swiping || e.pointerId !== activeId) return;

    const dx = e.clientX - startX;
    const dy = e.clientY - startY;

    // If vertical movement dominates, treat it as scroll and cancel swipe
    if (Math.abs(dy) > Math.abs(dx)) {
      swiping = false;
      row.releasePointerCapture(activeId);
      resetTransform();
      return;
    }

    // Limit how far the row slides
    const clamped = Math.max(-80, Math.min(80, dx));
    row.style.transform = `translateX(${clamped}px)`;
  });

  function endSwipe(e) {
    if (!swiping || e.pointerId !== activeId) return;
    swiping = false;
    row.releasePointerCapture(activeId);

    const dx = e.clientX - startX;
    const threshold = 60; // how far you need to swipe

    resetTransform();

    if (dx > threshold) {
      // ‚û°Ô∏è swipe right ‚Üí edit
      startInventoryEdit(item.key);
    } else if (dx < -threshold) {
      // ‚¨ÖÔ∏è swipe left ‚Üí delete
      if (confirm(`Delete ${item.name} from inventory?`)) {
        deleteInventoryItem(item.key);
        if (editingInventoryKey === item.key) clearInventoryEditState();
        renderInventory();
        renderInventoryNameSuggestions();
        saveState();
      }
    }
  }

  row.addEventListener("pointerup", endSwipe);
  row.addEventListener("pointercancel", endSwipe);

  row.addEventListener("pointerleave", () => {
    if (!swiping) return;
    swiping = false;
    resetTransform();
  });
}

function attachAddItemKeyboardShim(panel) {
  const overlay = document.getElementById("add-item-overlay");
  if (!overlay || !window.visualViewport) return;

  const vv = window.visualViewport;

  function updateOffset() {
    // reset
    panel.style.setProperty("--offset-y", "0px");
    overlay.classList.remove("overlay-keyboard-up");

    const rect = panel.getBoundingClientRect();
    const vpHeight = vv.height;

    // How far below the visible viewport bottom is the panel?
    const overflow = rect.bottom - vpHeight;

    // If panel is fully visible plus a small margin, do nothing
    if (overflow <= 16) return;

    // Shift the panel up just enough so the bottom is 16px above keyboard
    let shift = - (overflow + 16);   // negative value = move up

    // üí° Clamp so it never jumps too far (e.g. max 140px up)
    const MAX_UP = 140;              // tweak if you want more/less lift
    if (Math.abs(shift) > MAX_UP) {
      shift = -MAX_UP;
    }

    panel.style.setProperty("--offset-y", shift + "px");
    overlay.classList.add("overlay-keyboard-up");
  }

  // Run when viewport changes (keyboard open/close, rotate, etc.)
  vv.addEventListener("resize", updateOffset);
  window.addEventListener("orientationchange", updateOffset);

  // Initial run once the panel has animated in
  setTimeout(updateOffset, 120);

  // Store cleanup so we can detach listeners when dialog closes
  overlay._keyboardCleanup = () => {
    vv.removeEventListener("resize", updateOffset);
    window.removeEventListener("orientationchange", updateOffset);
  };
}

// ==========================================
//          INVENTORY LOGIC
// ==========================================  

function upsertInventoryItem(name, quantity, unit) {
      const cleanName = titleCase(name.trim());
      const key = cleanName.toLowerCase();
      let item = inventory.find((i) => i.key === key);

      if (!item) {
        item = { key, name: cleanName, quantity, unit };
        normalizeInventoryItem(item);
        inventory.push(item);
      } else {
        const baseUnit = item.unit || unit;
        const converted = convertToUnit(quantity, unit, baseUnit);
        if (!item.unit && unit) item.unit = unit;
        item.quantity += converted;
        normalizeInventoryItem(item);
      }
    }

function setInventoryItemExact(originalKey, name, quantity, unit) {
      const cleanName = titleCase(name.trim());
      const newKey = cleanName.toLowerCase();
      let item = inventory.find((i) => i.key === originalKey);

      if (!item) {
        item = { key: newKey, name: cleanName, quantity, unit };
        normalizeInventoryItem(item);
        inventory.push(item);
      } else {
        item.name = cleanName;
        item.key = newKey;
        item.quantity = quantity;
        item.unit = unit;
        normalizeInventoryItem(item);
      }
    }

function deleteInventoryItem(key) {
      inventory = inventory.filter((i) => i.key !== key);
    }

function startInventoryEdit(key) {
      const item = inventory.find((i) => i.key === key);
      if (!item) return;

      document.getElementById("inv-name").value = item.name;
      document.getElementById("inv-qty").value = item.quantity;
      document.getElementById("inv-unit").value = item.unit || "";

      document.getElementById("inventory-submit-btn").textContent =
        "Save changes";
      document
        .getElementById("inventory-cancel-edit")
        .classList.remove("hidden");
      editingInventoryKey = key;
    }

function clearInventoryEditState() {
      document.getElementById("inv-name").value = "";
      document.getElementById("inv-qty").value = "1";
      document.getElementById("inv-unit").value = "";
      document.getElementById("inventory-submit-btn").textContent =
        "Add / Update";
      document
        .getElementById("inventory-cancel-edit")
        .classList.add("hidden");
      editingInventoryKey = null;
    }    
    
function renderInventory() {
  const container = document.getElementById("inventory-list");
  if (!container) return;
  container.innerHTML = "";

  const filter = (inventoryFilter || "").toLowerCase();

  inventory
    .slice()
    .sort((a, b) => a.name.localeCompare(b.name))
    .forEach((item) => {
      if (filter && !item.name.toLowerCase().includes(filter)) return;

      const row = document.createElement("div");
      row.className = "inventory-item";

      // Left side: name + quantity on two lines
      const main = document.createElement("div");
      main.className = "inventory-item-main";

      const nameEl = document.createElement("div");
      nameEl.className = "inventory-item-name";
      nameEl.textContent = formatItemNameForDisplay(item.name);

      const qtyEl = document.createElement("div");
      qtyEl.className = "inventory-item-qty";
      const q = item.quantity;
      const u = normaliseUnit(item.unit || "");
      const niceQty = formatQuantityForDisplay(q);
      const unitLabel = pluraliseUnit(u, q);

      qtyEl.textContent = unitLabel ? `${niceQty} ${unitLabel}` : niceQty;

      main.appendChild(nameEl);
      main.appendChild(qtyEl);
      row.appendChild(main);

      // Right side: icon buttons
      const actions = document.createElement("div");
      actions.className = "inventory-actions";

      // Edit
     const editBtn = document.createElement("button");
editBtn.type = "button";
editBtn.className = "inventory-edit-btn";
editBtn.textContent = "Edit";
editBtn.addEventListener("click", () => {
  openAddInventoryItemDialog(item, {
    scannedBarcode: null,
    presetName: "",
  });
});

     // Delete
const delBtn = document.createElement("button");
delBtn.type = "button";
delBtn.className = "inventory-delete-button";
delBtn.title = "Delete";
delBtn.setAttribute("aria-label", "Delete item");
delBtn.textContent = "Delete";

delBtn.addEventListener("click", (e) => {
  e.stopPropagation();
  if (!confirm(`Delete ${item.name} from inventory?`)) return;

  deleteInventoryItem(item.key);
  if (editingInventoryKey === item.key) {
    clearInventoryEditState();
  }
  renderInventory();
  renderInventoryNameSuggestions();
  saveState();
});

      actions.appendChild(editBtn);
      actions.appendChild(delBtn);
      row.appendChild(actions);

      container.appendChild(row);
    });
}    
    
function openAddInventoryItemDialog(existingItem = null, opts = {}) {
  const { scannedBarcode = null, presetName = "" } = opts || {};
  const isEditMode = !!existingItem;

  console.log("openAddInventoryItemDialog() called", {
    existingItem,
    scannedBarcode,
    presetName,
    isEditMode,
  });

  // Make sure the barcode map exists if we're in a barcode flow
  if (scannedBarcode) {
    window.barcodeMap = window.barcodeMap || {};
  }

  // Remove any previous overlay instantly (we only animate on close)
  const oldOverlay = document.getElementById("add-item-overlay");
  if (oldOverlay) oldOverlay.remove();

  // Overlay
  const overlay = document.createElement("div");
  overlay.id = "add-item-overlay";
  overlay.className = "barcode-scanner-overlay";

  // Panel
  const panel = document.createElement("div");
  panel.className = "barcode-scanner-panel add-item-panel";

  // Title
  const title = document.createElement("h2");
  title.textContent = isEditMode ? "Edit item" : "Add item";
  panel.appendChild(title);

  // ----- Item name row -----
  const nameRow = document.createElement("div");
  nameRow.className = "barcode-input-row";

  const nameLabel = document.createElement("label");
  nameLabel.textContent = "Item name";
  nameLabel.style.display = "block";

  const nameInput = document.createElement("input");
  nameInput.type = "text";
  nameInput.autocomplete = "off";
  nameInput.placeholder = "e.g. Beef mince";

  // Prefill priority: existingItem (edit) ‚Üí presetName (known barcode) ‚Üí blank
  if (existingItem) {
    nameInput.value = existingItem.name || "";
  } else if (presetName) {
    nameInput.value = presetName;
  } else {
    nameInput.value = "";
  }

  nameLabel.appendChild(nameInput);
  nameRow.appendChild(nameLabel);
  panel.appendChild(nameRow);

  // ----- Quantity row -----
  const qtyRow = document.createElement("div");
  qtyRow.className = "barcode-input-row";

  const qtyLabel = document.createElement("label");
  qtyLabel.textContent = "Quantity";
  qtyLabel.style.display = "block";

  const qtyInput = document.createElement("input");
  qtyInput.type = "number";
  qtyInput.inputMode = "decimal"; // iOS number keypad
  qtyInput.min = "0";
  qtyInput.step = "0.1";
  qtyInput.placeholder = "e.g. 500";

  if (existingItem && typeof existingItem.quantity === "number") {
    qtyInput.value = String(existingItem.quantity);
  } else {
    qtyInput.value = ""; // let placeholder show
  }

  qtyLabel.appendChild(qtyInput);
  qtyRow.appendChild(qtyLabel);
  panel.appendChild(qtyRow);

  // ----- Unit row -----
  const unitRow = document.createElement("div");
  unitRow.className = "barcode-input-row";

  const unitLabel = document.createElement("label");
  unitLabel.textContent = "Unit";
  unitLabel.style.display = "block";

   const unitSelect = document.createElement("select");

  // Build options from our central unit list
  const UNIT_OPTIONS = [
    "",              // (none)
    ...Object.keys(UNIT_DEFS),  // g, kg, ml, l, tsp, tbsp, stick, clove, etc.
    "pcs",           // any extras that aren't in UNIT_DEFS yet
  ];

  UNIT_OPTIONS.forEach((u) => {
    const opt = document.createElement("option");
    opt.value = u;
    opt.textContent = u || "(none)";
    unitSelect.appendChild(opt);
  });

  unitLabel.appendChild(unitSelect);
  unitRow.appendChild(unitLabel);
  panel.appendChild(unitRow);

  // ----- Buttons row -----
  const btnRow = document.createElement("div");
  btnRow.className = "barcode-scanner-actions";

  const cancelBtn = document.createElement("button");
  cancelBtn.type = "button";
  cancelBtn.className = "inventory-delete-button";
  cancelBtn.textContent = "Cancel";
  cancelBtn.addEventListener("click", () => {
    animateCloseAddItemDialog(480);
  });

  const addBtn = document.createElement("button");
  addBtn.type = "button";
  addBtn.className = "ios-green-button";
  addBtn.textContent = isEditMode ? "Save changes" : "Add item";
  addBtn.addEventListener("click", () => {
    const rawName = nameInput.value.trim();
    const qty = parseFloat(qtyInput.value || "0");
    const unit = unitSelect.value || "";

    if (!rawName) {
      alert("Please enter an item name.");
      nameInput.focus();
      return;
    }
    if (!qty || qty <= 0 || Number.isNaN(qty)) {
      alert("Please enter a valid quantity.");
      qtyInput.focus();
      return;
    }

    // üßº Normalise/capitalise name (all words)
    const name = titleCase ? titleCase(rawName) : rawName;

    if (isEditMode && existingItem) {
      // ‚úÖ TRUE EDIT: overwrite this specific row instead of merging
      const keyToUpdate = existingItem.key;
      const idx = inventory.findIndex((i) => i.key === keyToUpdate);

      if (idx !== -1) {
        inventory[idx] = {
          ...inventory[idx],
          name,
          quantity: qty,
          unit,
        };
      }
      // Note: no barcodeMap changes here; this came from Edit, not a scan
    } else {
      // ‚ûï NEW ITEM FLOW (manual add OR barcode add)
      upsertInventoryItem(name, qty, unit);

      // If this came from a barcode scan, update barcodeMap
      if (scannedBarcode) {
        const map = (window.barcodeMap = window.barcodeMap || {});
        let names = map[scannedBarcode];

        if (!names) {
          // First time we've seen this barcode
          map[scannedBarcode] = name;
        } else if (Array.isArray(names)) {
          // Already an array of names
          if (!names.includes(name)) names.push(name);
        } else {
          // Was a single string, convert to array if different
          if (names !== name) {
            map[scannedBarcode] = [names, name];
          }
        }
      }
    }

    renderInventory();
    renderInventoryNameSuggestions();
    saveState();

    animateCloseAddItemDialog(480);
  });

  btnRow.appendChild(cancelBtn);
  btnRow.appendChild(addBtn);
  panel.appendChild(btnRow);

  overlay.appendChild(panel);
  document.body.appendChild(overlay);

  // Smooth "pop" in
  requestAnimationFrame(() => {
    overlay.classList.add("is-visible");
    panel.classList.add("visible");
  });

  // Focus without page jump
  setTimeout(() => {
    if (nameInput.focus) {
      nameInput.focus({ preventScroll: true });
    }
  }, 40);

  // Tap outside to close
  overlay.addEventListener("click", (evt) => {
    if (evt.target === overlay) {
      animateCloseAddItemDialog(480);
    }
  });

  // Keyboard-aware positioning (only if helper exists)
  if (typeof attachAddItemKeyboardShim === "function") {
    attachAddItemKeyboardShim(panel);
  }
}

function animateCloseAddItemDialog(durationMs = 480) {
  const overlay = document.getElementById("add-item-overlay");
  if (!overlay) return;

  const panel = overlay.querySelector(".add-item-panel");
  if (panel) {
    panel.classList.remove("visible"); // reverse the open animation
  }

  // üëá clean up the keyboard shim listeners if present
  if (typeof overlay._keyboardCleanup === "function") {
    overlay._keyboardCleanup();
  }

  setTimeout(() => {
    if (overlay && overlay.parentNode) {
      overlay.parentNode.removeChild(overlay);
    }
  }, durationMs);
}

function initDefaultMealPlan() {
    const days = [
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday",
      "Sunday",
    ];
    mealPlan = days.map((d) => ({
      dayId: d.toLowerCase(),
      dayLabel: d,
      recipeId: "",
      servings: 0,
    }));
  }

function deductInventoryForCooking(name, qtyBase, baseUnit) {
  if (!name || !qtyBase || qtyBase <= 0) return;

  const key = name.toLowerCase();
  const item = inventory.find((i) => i.name.toLowerCase() === key);
  if (!item) {
    // Caller handles "not found" confirmation
    return false;
  }

  // Decide a common base unit between ingredient + inventory
  const invUnit = item.unit || "";
  const base = baseUnit || chooseBaseUnit(invUnit);

  // Current inventory in base units
  let invQtyBase = convertToUnit(item.quantity, invUnit, base);

  // Deduct
  let newBase = invQtyBase - qtyBase;
  if (newBase <= 0.0001) {
    // Effectively used it all up ‚Üí remove item
    deleteInventoryItem(item.key);
  } else {
    // Convert back into the item's original unit
    const newQty = convertToUnit(newBase, base, invUnit || "");
    item.quantity = newQty;
    normalizeInventoryItem(item);
  }

  return true;
}

function formatIngredientNameForDetail(ing) {
  if (!ing || !ing.name) return "";

  const name = ing.name;
  const lower = name.toLowerCase();

  // Any variety of potato ‚Üí just show "Potatoes"
  if (lower.includes("King Edward")) {
    return "Potatoes";
  }

  return name;
}

function normaliseFractions(str) {
  if (!str) return str;
  return str
    .replace(/¬º/g, "1/4")
    .replace(/¬Ω/g, "1/2")
    .replace(/¬æ/g, "3/4")
    .replace(/‚Öê/g, "1/7")
    .replace(/‚Öë/g, "1/9")
    .replace(/‚Öí/g, "1/10")
    .replace(/‚Öì/g, "1/3")
    .replace(/‚Öî/g, "2/3")
    .replace(/‚Öï/g, "1/5")
    .replace(/‚Öñ/g, "2/5")
    .replace(/‚Öó/g, "3/5")
    .replace(/‚Öò/g, "4/5")
    .replace(/‚Öô/g, "1/6")
    .replace(/‚Öö/g, "5/6")
    .replace(/‚Öõ/g, "1/8")
    .replace(/‚Öú/g, "3/8")
    .replace(/‚Öù/g, "5/8")
    .replace(/‚Öû/g, "7/8");
}

function parseLeadingFractionQuantity(text) {
  if (!text) return null;

  const s = typeof normaliseFractions === "function"
    ? normaliseFractions(String(text)).trim()
    : String(text).trim();

  // Mixed fraction, e.g. "1 1/4 onion"
  let m = s.match(/^(\d+)\s+(\d+)\/(\d+)/);
  if (m) {
    const whole = Number(m[1]);
    const num   = Number(m[2]);
    const den   = Number(m[3]) || 1;
    if (!Number.isNaN(whole) && !Number.isNaN(num) && den > 0) {
      return whole + num / den;      // 1.25
    }
  }

  // Simple fraction, e.g. "1/4 onion"
  m = s.match(/^(\d+)\/(\d+)/);
  if (m) {
    const num = Number(m[1]);
    const den = Number(m[2]) || 1;
    if (!Number.isNaN(num) && den > 0) {
      return num / den;              // 0.25
    }
  }

  return null;
}

function fractionToUnicode(num) {
  if (num == null || Number.isNaN(num)) return null;

  const whole = Math.floor(num);
  const frac = num - whole;

  // Map exact or close fractional values to unicode
  const map = [
    { value: 1/8,  char: "‚Öõ" },
    { value: 1/6,  char: "‚Öô" },
    { value: 1/5,  char: "‚Öï" },
    { value: 1/4,  char: "¬º" },
    { value: 1/3,  char: "‚Öì" },
    { value: 3/8,  char: "‚Öú" },
    { value: 1/2,  char: "¬Ω" },
    { value: 2/3,  char: "‚Öî" },
    { value: 3/4,  char: "¬æ" },
    { value: 4/5,  char: "‚Öò" },
    { value: 5/6,  char: "‚Öö" },
    { value: 5/8,  char: "‚Öù" },
    { value: 7/8,  char: "‚Öû" }
  ];

  // Find closest matching fraction within tiny tolerance
  const match = map.find(f => Math.abs(frac - f.value) < 0.01);

  if (!match) {
    // No special fraction ‚Üí return clean number
    return num.toString();
  }

  // If there's a whole number part
  if (whole > 0) {
    return whole + match.char;
  }

  // Pure fraction
  return match.char;
}

async function importRecipeFromUrl(url) {
  const rawUrl = (url || "").trim();
  if (!rawUrl) return;

  // Optional: if you still have a status element in the DOM, this will update it.
  const statusEl = document.getElementById("recipe-import-status");
  if (statusEl) {
    statusEl.textContent = "Fetching recipe‚Ä¶";
    statusEl.classList.remove("error");
  }

  try {
    const endpoint = WORKER_BASE + "?url=" + encodeURIComponent(rawUrl);
    const res = await fetch(endpoint);
    if (!res.ok) throw new Error("Proxy returned " + res.status);

    const data = await res.json();
    if (!data || data.ok === false) {
      if (statusEl) {
        statusEl.textContent =
          (data && data.error) || "Recipe not found on that page.";
        statusEl.classList.add("error");
      }
      return;
    }

    // Normalised parsed object
    const parsed = {
      sourceUrl: data.source || rawUrl,
      title: data.title || "",
      imageUrl: data.image || "",
      servingsText: data.servings || "",
      servingsNumber:
        typeof parseServingsNumber === "function"
          ? parseServingsNumber(data.servings || "")
          : null,
      ingredients: Array.isArray(data.ingredients) ? data.ingredients : [],
      ingredientNames: Array.isArray(data.ingredientNames)
        ? data.ingredientNames
        : [],
      instructions: Array.isArray(data.instructions)
        ? data.instructions
        : [],
    };

    // Keep around in case you use it anywhere else
    window.lastImportedRecipeMeta = {
      instructions: parsed.instructions.slice(),
      sourceUrl: parsed.sourceUrl,
      servingsText: parsed.servingsText,
      image: parsed.imageUrl,
      title: parsed.title,
      ingredientNames: parsed.ingredientNames.slice(),
    };

    if (statusEl) {
      statusEl.textContent = "Recipe info loaded ‚Äì review and import.";
      statusEl.classList.remove("error");
    }

    // üëâ Show your preview dialog
    openRecipeImportPreviewDialog(parsed);
  } catch (err) {
    console.error(err);
    if (statusEl) {
      statusEl.textContent = "Could not import recipe from URL.";
      statusEl.classList.add("error");
    }
  }
}

function openRecipeMetaDialog(existingRecipe = null) {
  console.log("openRecipeMetaDialog()", existingRecipe);

  // Track the image for this dialog (start from existing recipe if present)
  let workingImageUrl =
    existingRecipe && existingRecipe.imageUrl
      ? existingRecipe.imageUrl
      : "";

  // Remove any previous meta overlay
  const old = document.getElementById("recipe-meta-overlay");
  if (old) old.remove();

  // Overlay
  const overlay = document.createElement("div");
  overlay.id = "recipe-meta-overlay";
  overlay.className = "barcode-scanner-overlay"; // reuse nice dark scrim

  // Panel (reusing the same look as Add Item dialog)
  const panel = document.createElement("div");
  panel.className = "barcode-scanner-panel add-item-panel";

  // Title
  const title = document.createElement("h2");
  title.textContent = existingRecipe ? "Edit recipe" : "Add recipe";
  panel.appendChild(title);

  // ===============================
  //  Recipe name + Photo row
  // ===============================
  const nameRow = document.createElement("div");
  nameRow.className = "barcode-input-row";

  const nameLabel = document.createElement("label");
  nameLabel.textContent = "Recipe name";
  nameLabel.style.display = "block";

  // Wrapper for: [ text input with icon overlaid on the right ]
  const nameWrapper = document.createElement("div");
  nameWrapper.className = "recipe-name-with-photo";

  const nameInput = document.createElement("input");
  nameInput.type = "text";
  nameInput.autocomplete = "off";
  nameInput.placeholder = "e.g. Spaghetti Bolognese";
  nameInput.className = "recipe-name-input";

  // Prefill from existing recipe if editing
  if (existingRecipe && existingRecipe.name) {
    nameInput.value = existingRecipe.name;
  }

  // Hidden file input (camera / photo library)
  const photoInput = document.createElement("input");
  photoInput.type = "file";
  photoInput.accept = "image/*";
  photoInput.style.display = "none";

  // Thumbnail preview (under the field)
  const imagePreview = document.createElement("img");
  imagePreview.className = "recipe-meta-image-preview";

  if (workingImageUrl) {
    imagePreview.src = workingImageUrl;
    imagePreview.style.display = "block";
  } else {
    imagePreview.style.display = "none";
  }

 // Icon button that sits visually inside the input on the right
const photoBtn = document.createElement("button");
photoBtn.type = "button";
photoBtn.className = "recipe-photo-icon";
photoBtn.setAttribute("aria-label", "Add something");
photoBtn.textContent = "+";   // ‚¨ÖÔ∏è this line

  // Clicking the icon opens the file picker
  photoBtn.addEventListener("click", () => {
    photoInput.click();
  });

  // When a file is chosen, read as Data URL and show preview
  photoInput.addEventListener("change", (e) => {
    const file = e.target.files && e.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = () => {
      workingImageUrl = reader.result; // save image in our dialog state
      imagePreview.src = workingImageUrl;
      imagePreview.style.display = "block";
    };
    reader.readAsDataURL(file);
  });

  // Build the row
  nameWrapper.appendChild(nameInput);
  nameWrapper.appendChild(photoBtn);

  nameLabel.appendChild(nameWrapper);
  nameRow.appendChild(nameLabel);

  panel.appendChild(nameRow);
  panel.appendChild(photoInput);   // hidden input lives in the panel
  panel.appendChild(imagePreview); // thumbnail under the name row

  // ===============================
  //  Servings row
  // ===============================
  const servingsRow = document.createElement("div");
  servingsRow.className = "barcode-input-row";

  const servingsLabel = document.createElement("label");
  servingsLabel.textContent = "Servings";
  servingsLabel.style.display = "block";

  const servingsInput = document.createElement("input");
  servingsInput.type = "number";
  servingsInput.inputMode = "decimal";
  servingsInput.min = "1";
  servingsInput.step = "0.5";
  servingsInput.placeholder = "e.g. 4";
  servingsInput.value = existingRecipe
    ? String(existingRecipe.servings || "")
    : "";

  servingsLabel.appendChild(servingsInput);
  servingsRow.appendChild(servingsLabel);
  panel.appendChild(servingsRow);

  // ===============================
  //  Buttons row
  // ===============================
  const btnRow = document.createElement("div");
  btnRow.className = "barcode-scanner-actions";

  const cancelBtn = document.createElement("button");
  cancelBtn.type = "button";
  cancelBtn.className = "inventory-delete-button";
  cancelBtn.textContent = "Cancel";
  cancelBtn.addEventListener("click", () => {
    const ov = document.getElementById("recipe-meta-overlay");
    if (ov && ov.parentNode) ov.parentNode.removeChild(ov);
  });

  const nextBtn = document.createElement("button");
  nextBtn.type = "button";
  nextBtn.textContent = "Add ingredients";
  nextBtn.className = "ios-green-button";   // ‚Üê NEW
  nextBtn.addEventListener("click", () => {
    const rawName = nameInput.value.trim();
    const rawServings = servingsInput.value.trim();

    if (!rawName) {
      alert("Please enter a recipe name.");
      nameInput.focus();
      return;
    }

    const servingsNum = parseFloat(rawServings || "0");
    if (!servingsNum || servingsNum <= 0 || Number.isNaN(servingsNum)) {
      alert("Please enter how many servings this recipe makes.");
      servingsInput.focus();
      return;
    }

    // Normalise / title-case the name (reusing your helper)
    const cleanName =
      typeof titleCase === "function" ? titleCase(rawName) : rawName;

    // Initialise / update currentRecipe in memory
    const baseId = existingRecipe ? existingRecipe.id : String(Date.now());

    currentRecipe = {
      id: baseId,
      name: cleanName,
      servings: servingsNum,
      ingredients:
        existingRecipe && Array.isArray(existingRecipe.ingredients)
          ? existingRecipe.ingredients.slice()
          : [],
      instructions:
        existingRecipe && Array.isArray(existingRecipe.instructions)
          ? existingRecipe.instructions.slice()
          : [],
      imageUrl: workingImageUrl || "", // üîë use the chosen image here
      sourceUrl:
        existingRecipe && existingRecipe.sourceUrl
          ? existingRecipe.sourceUrl
          : "",
    };

    editingRecipeId = existingRecipe ? existingRecipe.id : null;

    // Close meta dialog and open ingredient dialog
    const ov = document.getElementById("recipe-meta-overlay");
    if (ov && ov.parentNode) ov.parentNode.removeChild(ov);

    openRecipeIngredientsDialog();
  });

  btnRow.appendChild(cancelBtn);
  btnRow.appendChild(nextBtn);
  panel.appendChild(btnRow);

  overlay.appendChild(panel);
  document.body.appendChild(overlay);

  // Animate in
  requestAnimationFrame(() => {
    panel.classList.add("visible");
  });

  // Focus name by default
  setTimeout(() => {
    if (nameInput.focus) nameInput.focus({ preventScroll: true });
  }, 40);

  // Tap outside ‚Üí close
  overlay.addEventListener("click", (e) => {
    if (e.target === overlay) {
      const ov = document.getElementById("recipe-meta-overlay");
      if (ov && ov.parentNode) ov.parentNode.removeChild(ov);
    }
  });
}

function openRecipeIngredientsDialog() {
  console.log("openRecipeIngredientsDialog()", currentRecipe);

  if (!currentRecipe) {
    alert("No recipe in progress. Start with 'Add recipe' first.");
    return;
  }

  // Remove any existing ingredient overlay
  const old = document.getElementById("recipe-ingredients-overlay");
  if (old) old.remove();

  const overlay = document.createElement("div");
  overlay.id = "recipe-ingredients-overlay";
  overlay.className = "barcode-scanner-overlay";

  const panel = document.createElement("div");
  panel.className = "barcode-scanner-panel add-item-panel";

  // Title
  const title = document.createElement("h2");
  title.textContent = `Ingredients for ${currentRecipe.name}`;
  panel.appendChild(title);

  // ---------------------------
  // Ingredient picker dropdown
  // ---------------------------
  const pickerRow = document.createElement("div");
  pickerRow.className = "barcode-input-row";

  const pickerLabel = document.createElement("label");
  pickerLabel.textContent = "Choose ingredient to edit";
  pickerLabel.style.display = "block";

  const pickerSelect = document.createElement("select");

  // First option = add new ingredient
  const optNew = document.createElement("option");
  optNew.value = "";
  optNew.textContent = "Add new ingredient‚Ä¶";
  pickerSelect.appendChild(optNew);

  // Existing ingredients
  if (Array.isArray(currentRecipe.ingredients)) {
    currentRecipe.ingredients.forEach((ing, index) => {
      const opt = document.createElement("option");
      opt.value = String(index);
      opt.textContent = ing.name || `Ingredient ${index + 1}`;
      pickerSelect.appendChild(opt);
    });
  }

  pickerLabel.appendChild(pickerSelect);
  pickerRow.appendChild(pickerLabel);
  panel.appendChild(pickerRow);

  // ---------------------------
  // Name / quantity / unit rows
  // ---------------------------

  // --- Ingredient name row ---
  const nameRow = document.createElement("div");
  nameRow.className = "barcode-input-row";

  const nameLabel = document.createElement("label");
  nameLabel.textContent = "Ingredient name";
  nameLabel.style.display = "block";

  const nameInput = document.createElement("input");
  nameInput.type = "text";
  nameInput.autocomplete = "off";
  nameInput.placeholder = "e.g. Beef mince";

  nameLabel.appendChild(nameInput);
  nameRow.appendChild(nameLabel);
  panel.appendChild(nameRow);

  // --- Quantity row ---
  const qtyRow = document.createElement("div");
  qtyRow.className = "barcode-input-row";

  const qtyLabel = document.createElement("label");
  qtyLabel.textContent = "Quantity";
  qtyLabel.style.display = "block";

  const qtyInput = document.createElement("input");
  qtyInput.type = "number";
  qtyInput.inputMode = "decimal";
  qtyInput.min = "0";
  qtyInput.step = "0.1";
  qtyInput.placeholder = "e.g. 500";

  qtyLabel.appendChild(qtyInput);
  qtyRow.appendChild(qtyLabel);
  panel.appendChild(qtyRow);

  // --- Unit row ---
  const unitRow = document.createElement("div");
  unitRow.className = "barcode-input-row";

  const unitLabel = document.createElement("label");
  unitLabel.textContent = "Unit";
  unitLabel.style.display = "block";

  const unitSelect = document.createElement("select");

  // First option = no unit
  const noneOpt = document.createElement("option");
  noneOpt.value = "";
  noneOpt.textContent = "(none)";
  unitSelect.appendChild(noneOpt);

  // Then every unit from your global UNIT_DEFS
  if (typeof UNIT_DEFS === "object") {
    Object.keys(UNIT_DEFS).forEach((key) => {
      const def = UNIT_DEFS[key]; // {singular, plural}
      const opt = document.createElement("option");
      opt.value = key;                 // e.g. "g", "ml", "sprig"
      opt.textContent = def.singular;  // e.g. "g", "ml", "sprig"
      unitSelect.appendChild(opt);
    });
  }

  unitLabel.appendChild(unitSelect);
  unitRow.appendChild(unitLabel);
  panel.appendChild(unitRow);

  // Track whether we‚Äôre editing an existing ingredient or adding a new one
  let editingIngredientIndex = null;

  // When user picks an ingredient from the dropdown
  pickerSelect.addEventListener("change", () => {
    const val = pickerSelect.value;

    if (val === "") {
      // New ingredient mode
      editingIngredientIndex = null;
      nameInput.value = "";
      qtyInput.value = "";
      unitSelect.value = "";
      return;
    }

    const idx = parseInt(val, 10);
    const ing = currentRecipe.ingredients[idx];
    if (!ing) return;

    editingIngredientIndex = idx;

    nameInput.value = ing.name || "";
    qtyInput.value =
      typeof ing.quantity === "number" && !Number.isNaN(ing.quantity)
        ? String(ing.quantity)
        : "";
    unitSelect.value = ing.unit || "";
  });

  // Helper to save/update the ingredient currently in the fields
  function saveIngredientFromFields() {
    const rawName = nameInput.value.trim();
    const rawQty = qtyInput.value.trim();
    const unit = unitSelect.value || "";

    // If totally empty ‚Üí treat as "nothing to save"
    if (!rawName && !rawQty) {
      return false;
    }

    if (!rawName) {
      alert("Please enter an ingredient name.");
      nameInput.focus();
      return false;
    }

    const qtyNum = parseFloat(rawQty || "0");
    if (!qtyNum || qtyNum <= 0 || Number.isNaN(qtyNum)) {
      alert("Please enter a valid quantity.");
      qtyInput.focus();
      return false;
    }

    const cleanName = typeof titleCase === "function"
      ? titleCase(rawName)
      : rawName;

    if (!Array.isArray(currentRecipe.ingredients)) {
      currentRecipe.ingredients = [];
    }

    if (editingIngredientIndex === null) {
      // Add new
      currentRecipe.ingredients.push({
        name: cleanName,
        quantity: qtyNum,
        unit,
      });
    } else {
      // Overwrite existing
      currentRecipe.ingredients[editingIngredientIndex] = {
        name: cleanName,
        quantity: qtyNum,
        unit,
      };
    }

    // Rebuild the dropdown so names stay in sync with edits
    while (pickerSelect.options.length > 1) {
      pickerSelect.remove(1);
    }
    currentRecipe.ingredients.forEach((ing, index) => {
      const opt = document.createElement("option");
      opt.value = String(index);
      opt.textContent = ing.name || `Ingredient ${index + 1}`;
      pickerSelect.appendChild(opt);
    });

    // Reset to "Add new" mode after saving
    editingIngredientIndex = null;
    pickerSelect.value = "";
    nameInput.value = "";
    qtyInput.value = "";
    unitSelect.value = "";

    return true;
  }

  // --- Buttons row ---
  const btnRow = document.createElement("div");
  btnRow.className = "barcode-scanner-actions";

  const cancelBtn = document.createElement("button");
  cancelBtn.type = "button";
  cancelBtn.className = "inventory-delete-button";
  cancelBtn.textContent = "Cancel";
  cancelBtn.addEventListener("click", () => {
    const ov = document.getElementById("recipe-ingredients-overlay");
    if (ov && ov.parentNode) ov.parentNode.removeChild(ov);
  });

  const nextBtn = document.createElement("button");
  nextBtn.type = "button";
  nextBtn.textContent = "Next";
  nextBtn.addEventListener("click", () => {
    if (!saveIngredientFromFields()) return;
    // cleared & reset inside helper
    nameInput.focus();
  });

  const submitBtn = document.createElement("button");
  submitBtn.type = "button";
  submitBtn.textContent = "Submit";
  submitBtn.addEventListener("click", () => {
    // Try to save the current fields if there‚Äôs anything in them
    const hasData =
      nameInput.value.trim() !== "" || qtyInput.value.trim() !== "";

    if (hasData) {
      if (!saveIngredientFromFields()) return;
    }

    if (
      !currentRecipe.ingredients ||
      !currentRecipe.ingredients.length
    ) {
      alert("Please add at least one ingredient.");
      return;
    }

    // Save / update in recipes[]
    if (editingRecipeId) {
      const idx = recipes.findIndex((r) => r.id === editingRecipeId);
      if (idx !== -1) {
        recipes[idx] = { ...currentRecipe, id: editingRecipeId };
      }
    } else {
      recipes.push({ ...currentRecipe });
    }

    renderRecipesList();
    saveState();

    currentRecipe = null;
    editingRecipeId = null;

    const ov = document.getElementById("recipe-ingredients-overlay");
    if (ov && ov.parentNode) ov.parentNode.removeChild(ov);
  });

  btnRow.appendChild(cancelBtn);
  btnRow.appendChild(nextBtn);
  btnRow.appendChild(submitBtn);
  panel.appendChild(btnRow);

  overlay.appendChild(panel);
  document.body.appendChild(overlay);

  // Animate in
  requestAnimationFrame(() => {
    panel.classList.add("visible");
  });

  setTimeout(() => {
    if (nameInput.focus) nameInput.focus({ preventScroll: true });
  }, 40);

  overlay.addEventListener("click", (e) => {
    if (e.target === overlay) {
      const ov = document.getElementById("recipe-ingredients-overlay");
      if (ov && ov.parentNode) ov.parentNode.removeChild(ov);
    }
  });
}

function normaliseUnitToken(token) {
  if (!token) return null;
  const t = token.toLowerCase();

  // You can extend this over time ‚Äì just add more synonyms
  if (["g", "gram", "grams"].includes(t)) return "g";
  if (["kg", "kilogram", "kilograms"].includes(t)) return "kg";
  if (["ml", "millilitre", "milliliter", "millilitres", "milliliters"].includes(t)) return "ml";
  if (["l", "litre", "liter", "litres", "liters"].includes(t)) return "l";

  if (["tsp", "tsps", "teaspoon", "teaspoons"].includes(t)) return "tsp";
  if (["tbsp", "tbsps", "tablespoon", "tablespoons"].includes(t)) return "tbsp";

  // Optional ‚Äúcount‚Äù style units ‚Äì these can match your smart defaults later too
  if (["sprig", "sprigs"].includes(t)) return "sprig";
  if (["bottle", "bottles"].includes(t)) return "bottle";
  if (["clove", "cloves"].includes(t)) return "clove";
  if (["slice", "slices"].includes(t)) return "slice";
  if (["pack", "packs", "packet", "packets"].includes(t)) return "pack";

  return null;
}

function fixMissingUnitFromLine(normLine, parsedIng) {
  if (!normLine || !parsedIng) return parsedIng;

  // If parser already found a unit, don't touch it
  if (parsedIng.unit) return parsedIng;

  const tokens = normLine.split(/\s+/).filter(Boolean);
  if (!tokens.length) return parsedIng;

  let unitIndex = -1;
  let unitNorm = "";

  // Find first token that looks like a unit
  for (let i = 0; i < tokens.length; i++) {
    const norm = normaliseUnitToken(tokens[i]);
    if (norm) {
      unitIndex = i;
      unitNorm = norm;
      break;
    }
  }

  // No recognisable unit word? Nothing to fix
  if (unitIndex === -1) return parsedIng;

  // Try to re-derive quantity from everything BEFORE the unit word
  let qty = parsedIng.quantity;
  const beforeUnit = tokens.slice(0, unitIndex).join(" ").trim();

  if ((!qty || Number.isNaN(qty) || qty <= 0) && beforeUnit) {
    let q = null;

    if (typeof parseLeadingFractionQuantity === "function") {
      q = parseLeadingFractionQuantity(beforeUnit);
    }

    // If fraction parser didn't find anything but there are digits,
    // fall back to parseFloat (handles things like "2", "1.5", etc.)
    if ((!q || !Number.isFinite(q)) && /\d/.test(beforeUnit)) {
      const pf = parseFloat(beforeUnit);
      if (Number.isFinite(pf) && pf > 0) {
        q = pf;
      }
    }

    if (Number.isFinite(q) && q > 0) {
      qty = q;
    }
  }

  // Everything AFTER the unit token becomes the name
   const afterUnit = tokens.slice(unitIndex + 1).join(" ").trim();

  // Prefer whatever name the parser already gave us
  let finalName = parsedIng.name;
  if (!finalName || !finalName.trim()) {
    // Only fall back to the tail of the line if we had no name at all
    const rawName = afterUnit || normLine;
    finalName = rawName;
  }

  return {
    ...parsedIng,
    quantity:
      qty != null && Number.isFinite(qty) && qty > 0 ? qty : parsedIng.quantity,
    unit: unitNorm || parsedIng.unit || "",
    name: finalName
  };
}

function openRecipeImportDialog() {
  // Kill old dialog
  const old = document.getElementById("recipe-import-overlay");
  if (old) old.remove();

  // Overlay
  const overlay = document.createElement("div");
  overlay.id = "recipe-import-overlay";
  overlay.className = "barcode-scanner-overlay";

  // Panel
  const panel = document.createElement("div");
  panel.className = "barcode-scanner-panel add-item-panel";

  // Title
  const title = document.createElement("h2");
  title.textContent = "Import recipe";
  panel.appendChild(title);

  // URL row
  const row = document.createElement("div");
  row.className = "barcode-input-row";

  const label = document.createElement("label");
  label.textContent = "Recipe URL";
  label.style.display = "block";

  const input = document.createElement("input");
  input.type = "url";
  input.placeholder = "Paste BBC Food URL‚Ä¶";
  input.autocomplete = "off";

  label.appendChild(input);
  row.appendChild(label);
  panel.appendChild(row);

  // Little "or" divider
  const orText = document.createElement("p");
  orText.textContent = "or";
  orText.style.textAlign = "center";
  orText.style.margin = "0.5rem 0 0.25rem";
  orText.style.fontSize = "0.8rem";
  orText.style.color = "var(--text-muted)";
  panel.appendChild(orText);

  // "Search BBC recipes" button (opens separate dialog)
  const searchRow = document.createElement("div");
  searchRow.className = "barcode-scanner-actions";

  const searchBtn = document.createElement("button");
  searchBtn.type = "button";
  searchBtn.textContent = "Search BBC recipes";
  searchBtn.className = "primary-pill";

  searchBtn.addEventListener("click", () => {
    closeRecipeImportDialog();
    openRecipeSearchDialog();        // ‚¨ÖÔ∏è we‚Äôll define this next
  });

  searchRow.appendChild(searchBtn);
  panel.appendChild(searchRow);

  // Buttons (Cancel + Import from URL)
  const btnRow = document.createElement("div");
  btnRow.className = "barcode-scanner-actions";

  const cancelBtn = document.createElement("button");
  cancelBtn.type = "button";
  cancelBtn.className = "inventory-delete-button"; // red pill
  cancelBtn.textContent = "Cancel";
  cancelBtn.addEventListener("click", () => {
    closeRecipeImportDialog();
  });

  const importBtn = document.createElement("button");
  importBtn.type = "button";
  importBtn.textContent = "Import from URL";
  importBtn.className = "ios-green-button";

  importBtn.addEventListener("click", async () => {
    const url = input.value.trim();
    if (!url) {
      alert("Please paste a recipe URL first.");
      input.focus();
      return;
    }

    try {
      console.log("Importing from URL:", url);
      // ‚¨áÔ∏è this should already exist and open your nice preview dialog
      if (typeof importRecipeFromUrl === "function") {
        await importRecipeFromUrl(url);
      } else {
        console.error("importRecipeFromUrl is not defined");
        alert("Import function is missing in JS.");
        return;
      }

      closeRecipeImportDialog();
    } catch (err) {
      console.error("Import failed:", err);
      alert("Could not import recipe from that URL.");
    }
  });

  btnRow.appendChild(cancelBtn);
  btnRow.appendChild(importBtn);
  panel.appendChild(btnRow);

  overlay.appendChild(panel);
  document.body.appendChild(overlay);

  requestAnimationFrame(() => panel.classList.add("visible"));

  // Focus URL input
  setTimeout(() => {
    if (input.focus) input.focus({ preventScroll: true });
  }, 40);
}

function closeRecipeImportDialog() {
  const overlay = document.getElementById("recipe-import-overlay");
  if (!overlay) return;

  const panel = overlay.querySelector(".add-item-panel");
  if (panel) panel.classList.remove("visible");

  setTimeout(() => overlay.remove(), 480);
}

function openRecipeSearchDialog() {
  // Kill any old search overlay
  const old = document.getElementById("recipe-search-overlay");
  if (old) old.remove();

  const overlay = document.createElement("div");
  overlay.id = "recipe-search-overlay";
  overlay.className = "barcode-scanner-overlay";

  const panel = document.createElement("div");
  panel.className = "barcode-scanner-panel add-item-panel";

  const title = document.createElement("h2");
  title.textContent = "Search BBC recipes";
  panel.appendChild(title);

  // --- Search input row ---
  const row = document.createElement("div");
  row.className = "barcode-input-row";

  const label = document.createElement("label");
  label.textContent = "Search term";
  label.style.display = "block";

  const input = document.createElement("input");
  input.type = "text";
  input.placeholder = "e.g. Lasagne";
  input.autocomplete = "off";

  label.appendChild(input);
  row.appendChild(label);
  panel.appendChild(row);

  // Status text: "Type a word and tap Search"
  const status = document.createElement("p");
  status.style.fontSize = "0.8rem";
  status.style.margin = "0.4rem 0 0";
  status.style.color = "var(--text-muted)";
  status.textContent = "Type a recipe name and tap Search.";
  panel.appendChild(status);

  // Results container
  const resultsWrap = document.createElement("div");
  resultsWrap.className = "recipe-search-results";
  panel.appendChild(resultsWrap);

  // --- Buttons row ---
  const btnRow = document.createElement("div");
  btnRow.className = "barcode-scanner-actions";

  const cancelBtn = document.createElement("button");
  cancelBtn.type = "button";
  cancelBtn.className = "inventory-delete-button";
  cancelBtn.textContent = "Cancel";
  cancelBtn.addEventListener("click", () => {
    closeRecipeSearchDialog();
  });

  const searchBtn = document.createElement("button");
  searchBtn.type = "button";
  searchBtn.textContent = "Search";
  searchBtn.className = "ios-green-button";

  btnRow.appendChild(cancelBtn);
  btnRow.appendChild(searchBtn);
  panel.appendChild(btnRow);

  overlay.appendChild(panel);
  document.body.appendChild(overlay);

  requestAnimationFrame(() => panel.classList.add("visible"));

  // Helper to actually run the search
    async function runSearch() {
    const q = input.value.trim();
    if (!q) {
      status.textContent = "Please enter a search term.";
      status.classList.add("error");
      return;
    }

    status.textContent = "Searching BBC Food‚Ä¶";
    status.classList.remove("error");
    resultsWrap.innerHTML = "";

    try {
      // ‚úÖ Use the same global constant as your other code
      if (typeof WORKER_BASE !== "string" || !WORKER_BASE) {
        console.error("WORKER_BASE is not defined or not a string");
        status.textContent = "Worker base URL is not configured.";
        status.classList.add("error");
        return;
      }

      const endpoint =
        WORKER_BASE + "?search=" + encodeURIComponent(q);

      const res = await fetch(endpoint);
      if (!res.ok) {
        throw new Error("Search worker returned " + res.status);
      }

      const data = await res.json();
      if (!data.ok || !Array.isArray(data.results) || !data.results.length) {
        status.textContent = "No recipes found for that search.";
        status.classList.add("error");
        return;
      }

      status.textContent = `Found ${data.results.length} recipe(s).`;
      status.classList.remove("error");

   // Render results as big cards
resultsWrap.innerHTML = "";

data.results.forEach((r) => {
  const rawTitle = r.title || "";
  const rawMeta  = r.servingsText || "";

  const decodedTitle = rawTitle
    .replace(/&lt;/g, "<")
    .replace(/&gt;/g, ">")
    .replace(/\s+/g, " ")
    .trim();

  const decodedMeta = rawMeta
    .replace(/&lt;/g, "<")
    .replace(/&gt;/g, ">")
    .replace(/\s+/g, " ")
    .trim();

  // ---- CLEAN TITLE ----
  let cleanTitle = decodedTitle;

  // Remove "Serves X" if BBC stuffed it inside the title
  const titleMatch = decodedTitle.match(/^(.*?)(?:\s+Serves\s+\d+(?:-\d+)?)/i);
  if (titleMatch) {
    cleanTitle = titleMatch[1].trim();
  }

  // Remove "... By Someone Name"
  cleanTitle = cleanTitle.replace(/\s+by\s+[\w\s'.-]+$/i, "").trim();

  // Remove trailing "Main Course"
  cleanTitle = cleanTitle.replace(/\s+Main Course$/i, "").trim();

  // ---- SERVINGS ----
  let shortServings = "";
  const serveMatch = (decodedMeta || decodedTitle)
    .match(/Serves\s+(\d+(?:-\d+)?)/i);

  if (serveMatch) {
    shortServings = `Serves ${serveMatch[1]}`;
  }

  // ---- ITEM OBJ ----
  const item = {
    title: cleanTitle,
    servingsText: shortServings,
    image: r.imageUrl || "",
    url: r.url
  };

  const card = makeSearchResultCard(item);
  resultsWrap.appendChild(card);
});

    } catch (err) {
      console.error("Search failed:", err);
      status.textContent = "Search failed. Please try again.";
      status.classList.add("error");
    }
  }

  // Wire up Search button + Enter key
  searchBtn.addEventListener("click", runSearch);
  input.addEventListener("keydown", (e) => {
    if (e.key === "Enter") {
      e.preventDefault();
      runSearch();
    }
  });

  // Focus search box
  setTimeout(() => {
    if (input.focus) input.focus({ preventScroll: true });
  }, 40);
}

function closeRecipeSearchDialog() {
  const overlay = document.getElementById("recipe-search-overlay");
  if (!overlay) return;
  const panel = overlay.querySelector(".add-item-panel");
  if (panel) panel.classList.remove("visible");
  setTimeout(() => overlay.remove(), 480);
}

function makeSearchResultCard(item) {
  const row = document.createElement("div");
  row.className = "recipe-search-card";

  // --- IMAGE ---
  const imgWrap = document.createElement("div");
  imgWrap.className = "recipe-search-card-image";

  if (item.image) {
    const img = document.createElement("img");
    img.src = item.image;
    img.alt = item.title || "Recipe image";
    imgWrap.appendChild(img);
  } else {
    // Fallback letter
    imgWrap.textContent = item.title
      ? item.title.charAt(0).toUpperCase()
      : "?";
  }

  // --- INFO ---
  const info = document.createElement("div");
  info.className = "recipe-search-card-info";

  const titleEl = document.createElement("div");
  titleEl.className = "recipe-search-card-title";
  titleEl.textContent = item.title || "(No title)";
  info.appendChild(titleEl);

  const servingsEl = document.createElement("div");
  servingsEl.className = "recipe-search-card-servings";
  servingsEl.textContent = item.servingsText || "";
  info.appendChild(servingsEl);

  row.appendChild(imgWrap);
  row.appendChild(info);

  // Click = close search, then import via URL (same flow as before)
  row.addEventListener("click", async () => {
    closeRecipeSearchDialog();

    try {
      if (typeof importRecipeFromUrl === "function") {
        await importRecipeFromUrl(item.url);
      } else {
        alert("Import function is missing in JS.");
      }
    } catch (e) {
      console.error("Import from search failed:", e);
      alert("Could not import that recipe.");
    }
  });

  return row;
}

function startIngredientEdit(index) {
      if (!currentRecipe || !currentRecipe.ingredients[index]) return;
      const ing = currentRecipe.ingredients[index];

      document.getElementById("ing-name").value = ing.name;
      document.getElementById("ing-qty").value = ing.quantity;
      document.getElementById("ing-unit").value = ing.unit;

      document.getElementById("ingredient-submit-btn").textContent =
        "Save ingredient";
      document
        .getElementById("cancel-ingredient-edit")
        .classList.remove("hidden");
      editingIngredientIndex = index;
    }

function clearIngredientEditState() {
      document.getElementById("ing-name").value = "";
      document.getElementById("ing-qty").value = "1";
      document.getElementById("ing-unit").value = "";
      document.getElementById("ingredient-submit-btn").textContent =
        "Add ingredient";
      document
        .getElementById("cancel-ingredient-edit")
        .classList.add("hidden");
      editingIngredientIndex = null;
    }

function clearRecipeEditState() {
      editingRecipeId = null;
      currentRecipe = null;
      document.getElementById("recipe-name").value = "";
      document.getElementById("recipe-servings").value = "2";
      document.getElementById("current-recipe-ingredients").innerHTML = "";
      document
        .getElementById("recipe-ingredients-section")
        .classList.add("hidden");
      document
        .getElementById("cancel-recipe-edit")
        .classList.add("hidden");
      clearIngredientEditState();
    }

function renderRecipesList() {
  const container = document.getElementById("recipes-list");
  if (!container) return;
  container.innerHTML = "";

  if (!recipes.length) {
    container.textContent = "No recipes saved yet.";
    return;
  }

  const grid = document.createElement("div");
  grid.className = "recipe-grid";

  recipes.forEach((r) => {
    const card = document.createElement("article");
    card.className = "recipe-card";
    card.dataset.recipeId = r.id;

    // Thumbnail
    const thumb = document.createElement("div");
    thumb.className = "recipe-card-thumb";
    if (r.imageUrl) {
      const img = document.createElement("img");
      img.src = r.imageUrl;
      img.alt = r.name;
      thumb.appendChild(img);
    } else {
      const placeholder = document.createElement("div");
      placeholder.className = "recipe-card-placeholder";
      placeholder.textContent = (r.name || "R").charAt(0).toUpperCase();
      thumb.appendChild(placeholder);
    }

    // Clicking image opens detail
    thumb.style.cursor = "pointer";
    thumb.addEventListener("click", () => openRecipeDetail(r.id));
    card.appendChild(thumb);

    // Body
    const body = document.createElement("div");
    body.className = "recipe-card-body";

    const title = document.createElement("h3");
    title.className = "recipe-card-title";
    title.textContent = r.name;
    body.appendChild(title);

    const meta = document.createElement("p");
    meta.className = "recipe-card-meta";
    meta.textContent = r.servings
      ? `Serves ${r.servings}`
      : "Servings not set";
    body.appendChild(meta);

    card.appendChild(body);

    // Footer buttons (Edit + Delete)
    const footer = document.createElement("div");
    footer.className = "recipe-card-footer";

    const editBtn = document.createElement("button");
    editBtn.type = "button";
    editBtn.textContent = "Edit";
    editBtn.className = "inventory-edit-btn";

    editBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      console.log("Edit recipe clicked:", r.id, r.name);
      openRecipeMetaDialog(r);
    });

    const delBtn = document.createElement("button");
delBtn.type = "button";
delBtn.className = "inventory-delete-button";   // üî¥ red pill style
delBtn.textContent = "Delete";
    delBtn.addEventListener("click", () => {
      if (confirm(`Delete recipe "${r.name}"?`)) {
        recipes = recipes.filter((x) => x.id !== r.id);
      normaliseMealPlan();
mealPlan.forEach((day) => {
  MEAL_SLOTS.forEach(({ key }) => {
    const slot = day[key];
    if (slot && slot.recipeId === r.id) {
      slot.recipeId = "";
      slot.servings = 0;
    }
  });
});
        renderRecipesList();
        renderMealPlan();
        saveState();
      }
    });

    footer.appendChild(editBtn);
    footer.appendChild(delBtn);
    card.appendChild(footer);

    grid.appendChild(card);
  });

  container.appendChild(grid);

  // keep meal plan dropdowns in sync
  renderMealPlan();
}

function attachIngredientLongPress(li, recipeId, ingredientIndex, ingredientName) {
  let pressTimer = null;

  // ‚ùå Stop the browser selecting text on long-press
  li.style.userSelect = "none";
  li.style.webkitUserSelect = "none";

  const start = (event) => {
    event.preventDefault();
    if (pressTimer !== null) return;

    pressTimer = setTimeout(() => {
      pressTimer = null;
      openIngredientContextMenu(recipeId, ingredientIndex, ingredientName);
    }, 450); // ~0.45s long press
  };

  const cancel = () => {
    if (pressTimer !== null) {
      clearTimeout(pressTimer);
      pressTimer = null;
    }
  };

  li.addEventListener("pointerdown", start);
  li.addEventListener("pointerup", cancel);
  li.addEventListener("pointerleave", cancel);
  li.addEventListener("pointercancel", cancel);
}

function openIngredientContextMenu(recipeId, ingredientIndex, ingredientName) {
  const recipe = recipes.find((r) => r.id === recipeId);
  if (!recipe) return;

  const overlay = document.createElement("div");
  overlay.className = "recipe-detail-overlay"; // reuse dim background

  const panel = document.createElement("div");
  panel.className = "recipe-detail-panel";
  panel.style.maxWidth = "320px";

  const title = document.createElement("h3");
  title.textContent = ingredientName;
  panel.appendChild(title);

  // --- Staple toggle button ---
  const stapleBtn = document.createElement("button");
  stapleBtn.type = "button";

  const currentlyStaple = isStapleIngredient(ingredientName);
  stapleBtn.textContent = currentlyStaple
    ? "Remove from staples"
    : "Mark as staple";

  stapleBtn.addEventListener("click", () => {
    toggleUserStaple(ingredientName);
    overlay.remove();
    // Re-open the detail view so the ingredient jumps into / out of the staples section
    openRecipeDetail(recipeId);
  });

  // --- Edit ingredient button ---
  const editBtn = document.createElement("button");
  editBtn.type = "button";
  editBtn.className = "secondary";
  editBtn.textContent = "Edit ingredient";
  editBtn.addEventListener("click", () => {
    overlay.remove();
    showPage("page-recipes");
    startRecipeEdit(recipeId, ingredientIndex); // jump straight to that ingredient
  });

  // --- Delete ingredient button ---
  const deleteBtn = document.createElement("button");
  deleteBtn.type = "button";
  deleteBtn.className = "secondary";
  deleteBtn.textContent = "Delete ingredient";
  deleteBtn.addEventListener("click", () => {
    const ok = confirm(`Remove "${ingredientName}" from this recipe?`);
    if (!ok) return;

    if (
      Array.isArray(recipe.ingredients) &&
      ingredientIndex >= 0 &&
      ingredientIndex < recipe.ingredients.length
    ) {
      recipe.ingredients.splice(ingredientIndex, 1);
      saveState();
    }
    overlay.remove();
    openRecipeDetail(recipeId);
  });

  // --- Cancel button ---
  const closeBtn = document.createElement("button");
  closeBtn.type = "button";
  closeBtn.className = "secondary";
  closeBtn.textContent = "Cancel";
  closeBtn.addEventListener("click", () => overlay.remove());

  panel.appendChild(stapleBtn);
  panel.appendChild(editBtn);
  panel.appendChild(deleteBtn);
  panel.appendChild(closeBtn);

  overlay.appendChild(panel);

  // Close if you tap outside the panel
  overlay.addEventListener("click", (e) => {
    if (e.target === overlay) overlay.remove();
  });

  document.body.appendChild(overlay);
}

function shouldHideQuantityForDisplay(ing) {
  if (!ing || !ing.name) return false;
  const nameLower = ing.name.toLowerCase().trim();

  // üîπ Ingredients where we never want to show a numeric "1"
  const ALWAYS_HIDE_QTY = [
    "burger bun",
    "burger buns",
    "buns",
    "burger seasoning",
    "seasoning",
    "black pepper"
  ];

  if (ALWAYS_HIDE_QTY.some((phrase) => nameLower.includes(phrase))) {
    return true;
  }

  // üîπ If the parser guessed quantity = 1, with no unit,
  //    and it's classed as a staple, hide the "1" too.
  if (
    (!ing.unit || ing.unit === "") &&
    ing.quantity === 1 &&
    typeof isStapleIngredient === "function" &&
    isStapleIngredient(ing.name)
  ) {
    return true;
  }

  return false;
}

function applySmartDefaultUnit(name, quantity, unit) {
  // If we already have a unit, don't touch it
  if (unit) return unit;

  const lowerName = (name || "").toLowerCase();
  const q = quantity != null ? Number(quantity) : null;
  if (!q || Number.isNaN(q) || q <= 0) return unit;

  if (lowerName.includes("wine")) {
    return q === 1 ? "bottle" : "bottles";
  }

  if (lowerName.includes("rosemary")) {
    return q === 1 ? "sprig" : "sprigs";
  }

  if (lowerName.includes("thyme")) {
    return q === 1 ? "sprig" : "sprigs";
  }

  return unit;
}

function openRecipeDetail(recipeId, options = {}) {
  const {
    targetServings = null,   // e.g. 10
    showCookCheckboxes = false
  } = options || {};

  const recipe = recipes.find((r) => r.id === recipeId);
  if (!recipe) return;

  // How much to scale ingredient quantities by
  const baseServings =
    recipe.servings && recipe.servings > 0 ? recipe.servings : 1;
  const scale =
    targetServings && targetServings > 0
      ? targetServings / baseServings
      : 1;

  try {
    const recipeIdActual = recipe.id;

    // Work on a copy so we don't mutate the underlying recipe
    // and apply scaling if needed (e.g. 5 ‚Üí 10 servings).
    const ingForDisplay = (recipe.ingredients || []).map((ing) => {
      if (!ing) return ing;
      const copy = { ...ing };

      if (
        scale !== 1 &&
        copy.quantity != null &&
        !Number.isNaN(copy.quantity) &&
        copy.quantity > 0
      ) {
        copy.quantity = copy.quantity * scale;
      }
      return copy;
    });

    // If any ingredient mentions black pepper but none mentions salt,
    // add a synthetic "Salt" line (staple, shown as "to taste").
    const hasBlackPepper = ingForDisplay.some(
      (ing) => ing.name && ing.name.toLowerCase().includes("black pepper")
    );
    const hasAnySalt = ingForDisplay.some(
      (ing) => ing.name && ing.name.toLowerCase().includes("salt")
    );

    if (hasBlackPepper && !hasAnySalt) {
      ingForDisplay.push({
        name: "Salt",
        quantity: null,
        unit: ""
      });
    }

    const overlay = document.createElement("div");
    overlay.className = "recipe-detail-overlay";

    const panel = document.createElement("div");
    panel.className = "recipe-detail-panel";

    // Close button
    const closeBtn = document.createElement("button");
    closeBtn.type = "button";
    closeBtn.className = "recipe-detail-close inventory-delete-button";
    closeBtn.textContent = "Close";
    closeBtn.addEventListener("click", () => overlay.remove());
    panel.appendChild(closeBtn);

    // Title
    const title = document.createElement("h2");
    title.className = "recipe-detail-title";
    title.textContent = recipe.name;
    panel.appendChild(title);

    // Image
    if (recipe.imageUrl) {
      const imgWrap = document.createElement("div");
      imgWrap.className = "recipe-detail-image-wrap";
      const img = document.createElement("img");
      img.src = recipe.imageUrl;
      img.alt = recipe.name;
      imgWrap.appendChild(img);
      panel.appendChild(imgWrap);
    }

    // Meta
    const meta = document.createElement("p");
    meta.className = "recipe-detail-meta";
    meta.textContent = recipe.servings ? `Serves ${recipe.servings}` : "";
    panel.appendChild(meta);

    // ---- Ingredients section ----
    const ingTitle = document.createElement("h3");
    ingTitle.textContent = "Ingredients";
    panel.appendChild(ingTitle);

    // Split by staples vs regular
    const split =
      typeof splitIngredientsByStaples === "function"
        ? splitIngredientsByStaples(ingForDisplay)
        : { staples: [], regular: ingForDisplay.map((ing, index) => ({ ing, index })) };

    let regular = split.regular || [];
    let staples = split.staples || [];

    // Optional: dedupe + merge staples (e.g. Butter in g + Butter in tbsp)
    if (typeof dedupeStaplesByName === "function") {
      staples = dedupeStaplesByName(staples);
    }

    // Sort staples:
    // 1) items with numeric quantity first (largest ‚Üí smallest),
    // 2) then no-quantity "to taste" items alphabetically
    staples.sort((a, b) => {
      const qaRaw = a.ing.quantity;
      const qbRaw = b.ing.quantity;

      const aHasQty = qaRaw !== null && qaRaw !== undefined && qaRaw > 0;
      const bHasQty = qbRaw !== null && qbRaw !== undefined && qbRaw > 0;

      if (aHasQty && bHasQty) return qbRaw - qaRaw;
      if (aHasQty && !bHasQty) return -1;
      if (!aHasQty && bHasQty) return 1;

      const nameA = (a.ing.name || "").toLowerCase();
      const nameB = (b.ing.name || "").toLowerCase();
      if (nameA < nameB) return -1;
      if (nameA > nameB) return 1;
      return 0;
    });

      function addIngredientLi(ul, obj, isStapleList) {
      const { ing, index } = obj;
      const li = document.createElement("li");

      // Optional checkbox for "cooking" mode
      let cookCheckbox = null;
      if (showCookCheckboxes) {
        cookCheckbox = document.createElement("input");
        cookCheckbox.type = "checkbox";
        cookCheckbox.className = "ingredient-cook-checkbox";
        cookCheckbox.style.marginRight = "0.5rem";

        cookCheckbox.addEventListener("change", () => {
          // For now just visually dim when ticked
          li.style.opacity = cookCheckbox.checked ? "0.5" : "";
        });

        li.appendChild(cookCheckbox);
      }

      const nameSpan = document.createElement("span");
      nameSpan.className = "ingredient-name";
      nameSpan.textContent =
        typeof formatIngredientNameForDetail === "function"
          ? formatIngredientNameForDetail(ing)
          : (ing.name || "");
      li.appendChild(nameSpan);

      let q = ing.quantity;
      let u = ing.unit || "";

      // Should we hide the quantity entirely for display?
      const hideQty =
        typeof shouldHideQuantityForDisplay === "function"
          ? shouldHideQuantityForDisplay(ing)
          : false;

      const hasNumericQty =
        q != null &&
        !Number.isNaN(q) &&
        q > 0 &&
        !hideQty;

    if (hasNumericQty) {
  const compactUnits = ["g", "kg", "ml", "l"];
  let unitLower = (u || "").toLowerCase();

  // Keep auto-compacting (e.g. 1200ml ‚Üí 1.2l)
  if (
    compactUnits.includes(unitLower) &&
    typeof autoCompactQuantityUnit === "function"
  ) {
    ({ quantity: q, unit: u } = autoCompactQuantityUnit(q, u));
    unitLower = (u || "").toLowerCase();
  }

  const qtySpan = document.createElement("span");
  qtySpan.className = "ingredient-qty";

const niceQty =
  typeof formatQuantityForDisplay === "function"
    ? formatQuantityForDisplay(q)
    : q;

const canonicalUnit = typeof normaliseUnit === "function"
  ? normaliseUnit(u)
  : unitLower;

const unitLabel = typeof pluraliseUnit === "function"
  ? pluraliseUnit(canonicalUnit, q)
  : (canonicalUnit || "");

// ‚¨áÔ∏è NEW: units that should be shown without a space
const COMPACT_UNITS = ["g", "kg", "ml"];

let label;
if (!unitLabel) {
  label = niceQty;                           // "2"  (Onions carries plural)
} else if (COMPACT_UNITS.includes(canonicalUnit)) {
  label = `${niceQty}${unitLabel}`;          // "650g", "2tbsp"
} else {
  label = `${niceQty} ${unitLabel}`;         // "1 litre", "4 sprigs", "2 bottles"
}

  qtySpan.textContent = label;
  li.appendChild(qtySpan);
} else if (isStapleList) {
  // No numeric qty but in staples ‚Üí "to taste"
  const qtySpan = document.createElement("span");
  qtySpan.className = "ingredient-qty";

  const em = document.createElement("em");
  em.textContent = "to taste";
  qtySpan.appendChild(em);

  li.appendChild(qtySpan);
}
      // If not staple and no qty ‚Üí just the name

      // Long-press menu
      if (typeof attachIngredientLongPress === "function") {
        attachIngredientLongPress(li, recipeIdActual, index, ing.name);
      }

      ul.appendChild(li);
    }

    // Non-staple ingredients
    const ingList = document.createElement("ul");
    ingList.className = "recipe-detail-ingredients";
    regular.forEach((obj) => addIngredientLi(ingList, obj, false));
    panel.appendChild(ingList);

    // Staples: "Make sure you have"
    if (staples.length) {
      const staplesTitle = document.createElement("h3");
      staplesTitle.innerHTML = "<em>Make sure you have</em>";
      panel.appendChild(staplesTitle);

      const staplesList = document.createElement("ul");
      staplesList.className = "recipe-detail-ingredients staples";
      staples.forEach((obj) => addIngredientLi(staplesList, obj, true));
      panel.appendChild(staplesList);
    }

    // ---- Method ----
    const instrTitle = document.createElement("h3");
    instrTitle.textContent = "Method";
    panel.appendChild(instrTitle);

    const instrList = document.createElement("ol");
    instrList.className = "recipe-detail-instructions";
    if (Array.isArray(recipe.instructions) && recipe.instructions.length) {
      recipe.instructions.forEach((step) => {
        const li = document.createElement("li");
        li.textContent = step;
        instrList.appendChild(li);
      });
    } else {
      const li = document.createElement("li");
      li.textContent = "No method stored yet.";
      instrList.appendChild(li);
    }
    panel.appendChild(instrList);

    // Source link (if we have it)
    if (recipe.sourceUrl) {
      const link = document.createElement("a");
      link.className = "recipe-detail-source";
      link.href = recipe.sourceUrl;
      link.target = "_blank";
      link.rel = "noopener noreferrer";
      link.textContent = "View original recipe on BBC";
      panel.appendChild(link);
    }

    overlay.appendChild(panel);
    document.body.appendChild(overlay);

    // Close if you tap the dim background
    overlay.addEventListener("click", (e) => {
      if (e.target === overlay) overlay.remove();
    });
  } catch (err) {
    console.error("openRecipeDetail error:", err);
    alert("There was a problem opening this recipe. Check the console for details.");
  }
}

// Can be called EITHER as:
//   openCookDialog(recipeObj, servings)
// OR
//   openCookDialog(dayId)
function openCookDialog(arg1, defaultServings) {
  let recipe = null;
  let plannedServings = defaultServings;

  // ---------- MODE 1: called with a recipe object ----------
  if (arg1 && typeof arg1 === "object" && Array.isArray(arg1.ingredients)) {
    recipe = arg1;
  } else {
    // ---------- MODE 2: called with a dayId (old behaviour) ----------
    const dayId = arg1;
    const entry = mealPlan.find((d) => d && d.dayId === dayId);
    if (!entry || !entry.recipeId) {
      alert("No recipe selected for this day.");
      return;
    }

    const found = recipes.find((r) => r.id === entry.recipeId);
    if (!found) {
      alert("Recipe not found.");
      return;
    }

    recipe = found;

    if (!plannedServings || plannedServings <= 0) {
      plannedServings =
        (entry.servings && entry.servings > 0)
          ? entry.servings
          : (recipe.servings && recipe.servings > 0 ? recipe.servings : 1);
    }
  }

  // Final safety check
  if (!recipe || !Array.isArray(recipe.ingredients) || !recipe.ingredients.length) {
    alert("This recipe has no ingredients saved yet.");
    return;
  }

  // If we came from LET'S COOK, use that; otherwise fall back to recipe base
  const initialServings =
    (plannedServings && plannedServings > 0)
      ? plannedServings
      : (recipe.servings && recipe.servings > 0 ? recipe.servings : 1);

  // ===== BUILD OVERLAY =====
  const overlay = document.createElement("div");
  overlay.className = "recipe-detail-overlay cook-overlay";

  const panel = document.createElement("div");
  panel.className = "recipe-detail-panel";

  // Close button (YELLOW so we know it's cook mode)
  const closeBtn = document.createElement("button");
  closeBtn.type = "button";
  closeBtn.className = "recipe-detail-close";
  closeBtn.textContent = "Close";
  closeBtn.style.backgroundColor = "yellow";
  closeBtn.style.color = "#000";
  closeBtn.addEventListener("click", () => overlay.remove());
  panel.appendChild(closeBtn);

  // Title
  const title = document.createElement("h2");
  title.textContent = `Cook: ${recipe.name}`;
  panel.appendChild(title);

  // Servings chooser
  const servingsLabel = document.createElement("label");
  servingsLabel.textContent = "How many servings are you cooking?";
  servingsLabel.style.display = "block";

  const servingsInput = document.createElement("input");
  servingsInput.type = "number";
  servingsInput.min = "1";
  servingsInput.step = "1";
  servingsInput.value = String(initialServings);
  servingsInput.style.marginTop = "0.5rem";

  servingsLabel.appendChild(servingsInput);
  panel.appendChild(servingsLabel);

  // Ingredient checklist container
  const ingSection = document.createElement("div");
  ingSection.className = "subpanel";
  ingSection.style.marginTop = "1rem";

  const ingHeading = document.createElement("h3");
  ingHeading.textContent = "Ingredients to use";
  ingSection.appendChild(ingHeading);

  const ingHelp = document.createElement("p");
  ingHelp.textContent =
    "Tick each ingredient as you get it out. Ticking will deduct it from your inventory.";
  ingSection.appendChild(ingHelp);

  const ingList = document.createElement("ul");
  // reuse normal detail styling
  ingList.className = "recipe-detail-ingredients cook-ingredients-list";
  ingSection.appendChild(ingList);

  panel.appendChild(ingSection);

  // Footer buttons
  const footer = document.createElement("div");
  footer.className = "barcode-scanner-actions";

  const cancelBtn = document.createElement("button");
  cancelBtn.type = "button";
  cancelBtn.className = "inventory-delete-button";
  cancelBtn.textContent = "Cancel";
  cancelBtn.addEventListener("click", () => overlay.remove());

  const finishBtn = document.createElement("button");
  finishBtn.type = "button";
  finishBtn.textContent = "Finish cooking";

  footer.appendChild(cancelBtn);
  footer.appendChild(finishBtn);

  panel.appendChild(footer);
  overlay.appendChild(panel);
  document.body.appendChild(overlay);

  // Close by tapping dark background
  overlay.addEventListener("click", (e) => {
    if (e.target === overlay) overlay.remove();
  });

  // ---------- RENDER SCALED INGREDIENTS ----------
  function renderCookIngredients() {
    ingList.innerHTML = "";

    const cookServings = parseFloat(servingsInput.value || "0");
    if (!cookServings || cookServings <= 0) return;

    const baseServings =
      recipe.servings && recipe.servings > 0 ? recipe.servings : 1;
    const scale = cookServings / baseServings;

    recipe.ingredients.forEach((ing) => {
      if (!ing || !ing.name) return;

      // Skip staples
      if (typeof isStapleIngredient === "function" && isStapleIngredient(ing.name)) {
        return;
      }

      let q = ing.quantity || 0;
      let u = ing.unit || "";
      let scaledQty = q * scale;

      const baseUnit =
        typeof chooseBaseUnit === "function"
          ? chooseBaseUnit(u, ing.name)
          : (u || "");
      const qtyBase =
        typeof convertToUnit === "function"
          ? convertToUnit(scaledQty, u, baseUnit)
          : scaledQty;

      // Pretty quantity string (same as detail view)
      let displayQty = scaledQty;
      let displayUnit = u;

      if (
        displayQty &&
        (displayUnit === "g" || displayUnit === "ml") &&
        displayQty >= 1000
      ) {
        displayQty = displayQty / 1000;
        displayUnit = displayUnit === "g" ? "kg" : "l";
      }

      const niceQty =
        typeof formatQuantityForDisplay === "function"
          ? formatQuantityForDisplay(displayQty)
          : displayQty;

      const canonicalUnit =
        typeof normaliseUnit === "function"
          ? normaliseUnit(displayUnit || "")
          : (displayUnit || "").toLowerCase();

      const unitLabel =
        typeof pluraliseUnit === "function"
          ? pluraliseUnit(canonicalUnit, displayQty)
          : canonicalUnit;

      let qtyStr = "";
      if (displayQty && displayQty > 0) {
        if (!unitLabel) {
          qtyStr = String(niceQty);
        } else {
          const COMPACT_UNITS = ["g", "kg", "ml"];
          if (COMPACT_UNITS.includes(canonicalUnit)) {
            qtyStr = `${niceQty}${unitLabel}`;      // 450g, 200ml
          } else {
            qtyStr = `${niceQty} ${unitLabel}`;     // 1 litre, 2 bottles, etc.
          }
        }
      }

      // ONE LINE: Name   QtyUnit   [ ]
      const li = document.createElement("li");
      li.className = "cook-ingredient-row";
      li.style.display = "flex";
      li.style.alignItems = "center";

      const nameSpan = document.createElement("span");
      nameSpan.className = "ingredient-name";
      nameSpan.textContent = ing.name;
      nameSpan.style.flex = "1 1 auto";
      li.appendChild(nameSpan);

      const qtySpan = document.createElement("span");
      qtySpan.className = "ingredient-qty";
      qtySpan.textContent = qtyStr || "";
      qtySpan.style.marginLeft = "0.75rem";
      li.appendChild(qtySpan);

      const cb = document.createElement("input");
      cb.type = "checkbox";
      cb.className = "cook-ingredient-checkbox";
      cb.style.marginLeft = "0.75rem";

      cb.dataset.ingName = ing.name;
      cb.dataset.qtyBase = String(qtyBase);
      cb.dataset.baseUnit = baseUnit || "";

      cb.addEventListener("change", () => {
        if (!cb.checked || cb.dataset.applied === "true") return;

        const name = cb.dataset.ingName;
        const qtyBaseNum = parseFloat(cb.dataset.qtyBase || "0");
        const base = cb.dataset.baseUnit || "";

        const invItem = inventory.find(
          (i) => i.name && i.name.toLowerCase() === name.toLowerCase()
        );

        if (!invItem) {
          const ok = confirm(
            `"${name}" is not currently in your inventory.\n\n` +
              "Did you forget to add it, or are you happy to continue without deducting anything?"
          );
          if (!ok) {
            cb.checked = false;
            return;
          }
          cb.dataset.applied = "true";
          cb.disabled = true;
          return;
        }

        const success =
          typeof deductInventoryForCooking === "function"
            ? deductInventoryForCooking(name, qtyBaseNum, base)
            : false;

        if (!success) {
          alert("Could not update inventory for " + name);
          cb.checked = false;
          return;
        }

        cb.dataset.applied = "true";
        cb.disabled = true;

        renderInventory();
        saveState();
      });

      li.appendChild(cb);
      ingList.appendChild(li);
    });
  }

  // Initial render
  renderCookIngredients();

  // Re-render when servings change
  servingsInput.addEventListener("change", () => {
    const val = parseFloat(servingsInput.value || "0");
    if (!val || val <= 0) {
      servingsInput.value = "1";
    }
    renderCookIngredients();
  });

  // Finish cooking: warn if some ingredients not ticked
  finishBtn.addEventListener("click", () => {
    const unchecked = Array.from(
      ingList.querySelectorAll('input[type="checkbox"]:not(:checked)')
    ).map((cb) => cb.dataset.ingName);

    if (unchecked.length) {
      const ok = confirm(
        "You haven't ticked these ingredients:\n\n" +
          unchecked.map((n) => "‚Ä¢ " + n).join("\n") +
          "\n\nIs that because you didn't use them or couldn't buy them?"
      );
      if (!ok) return;
    }

    overlay.remove();
  });
}

function startRecipeEdit(id, ingredientIndexToEdit) {
  const recipe = recipes.find((r) => r.id === id);
  if (!recipe) return;

  editingRecipeId = id;
  currentRecipe = {
    id: recipe.id,
    name: recipe.name,
    servings: recipe.servings,
    ingredients: recipe.ingredients.map((ing) => ({
      name: ing.name,
      quantity: ing.quantity,
      unit: ing.unit,
    })),
  };

  document.getElementById("recipe-name").value = currentRecipe.name;
  document.getElementById("recipe-servings").value =
    currentRecipe.servings;

  document
    .getElementById("recipe-ingredients-section")
    .classList.remove("hidden");
  document
    .getElementById("cancel-recipe-edit")
    .classList.remove("hidden");

  renderCurrentRecipeIngredients();

  // If we came from the long-press popup, drop straight into that ingredient
  if (
    typeof ingredientIndexToEdit === "number" &&
    ingredientIndexToEdit >= 0 &&
    ingredientIndexToEdit < currentRecipe.ingredients.length
  ) {
    startIngredientEdit(ingredientIndexToEdit);
  } else {
    clearIngredientEditState();
  }
}

function formatUnitText(unit, quantity) {
  const u = (unit || "").toLowerCase();

  if (u === "l") {
    // 1 litre, 2 litres, 0.5 litres, etc.
    if (quantity === 1) return "litre";
    return "litres";
  }

  // everything else unchanged for now (g, ml, kg, tsp, tbsp, etc.)
  return unit;
}

function formatQuantityForDisplay(q) {
  if (q == null || Number.isNaN(q)) return "";

  const value = Number(q);
  if (!Number.isFinite(value)) return "";

  const abs = Math.abs(value);
  const whole = Math.floor(abs);
  const frac  = abs - whole;
  const sign  = value < 0 ? "-" : "";

  const EPS = 0.01;

  let fracChar = null;
  if (Math.abs(frac - 0.25) < EPS) fracChar = "¬º";
  else if (Math.abs(frac - 0.5)  < EPS) fracChar = "¬Ω";
  else if (Math.abs(frac - 0.75) < EPS) fracChar = "¬æ";

  if (fracChar) {
    if (whole === 0) return sign + fracChar;      // "¬º"
    return `${sign}${whole} ${fracChar}`;         // "1 ¬º", "2 ¬Ω", etc.
  }

  if (Number.isInteger(value)) return String(value);
  return (Math.round(value * 10) / 10).toString();
}

// Clean weird "600ml/20fl oz stock (ideally beef...)" style lines
function cleanStockLine(raw) {
  if (!raw) return raw;
  let s = String(raw);

  // 1) If it starts with "600ml/20fl oz" etc, keep ONLY the ml bit
  const m = s.match(/^(\d+(?:\.\d+)?)\s*ml\s*\/\s*\d+(?:\.\d+)?\s*fl\s*oz(.*)$/i);
  if (m) {
    // m[1] = the ml quantity, m[2] = rest of the line (" stock (ideally...)")
    s = `${m[1]}ml${m[2] || ""}`;
  }

  // 2) Strip any bracketed hints: "(ideally beef, ...)"
  s = s.replace(/\([^)]*\)/g, "");

  // 3) Normal tidy-up spaces
  return s.replace(/\s+/g, " ").trim();
}

// Is this ingredient name just a generic "stock" (not beef/chicken/veg)?
function isGenericStockName(name) {
  if (!name) return false;
  const lower = name.toLowerCase().trim();

  if (!lower.includes("stock")) return false;

  // Already specific? (you can add more here later if you like)
  if (lower.startsWith("beef stock"))       return false;
  if (lower.startsWith("chicken stock"))    return false;
  if (lower.startsWith("vegetable stock"))  return false;
  if (lower.startsWith("veg stock"))        return false;

  return true; // e.g. "stock", "hot stock", "beef or chicken stock"
}

function openStockTypeDialogForRecipe(recipeId) {
  const recipe = recipes.find((r) => r.id === recipeId);
  if (!recipe || !Array.isArray(recipe.ingredients)) return;

  const genericStocks = recipe.ingredients.filter((ing) =>
    isGenericStockName(ing.name)
  );

  if (!genericStocks.length) return; // nothing to do

  const overlay = document.createElement("div");
  overlay.className = "recipe-detail-overlay";

  const panel = document.createElement("div");
  panel.className = "recipe-detail-panel";
  panel.style.maxWidth = "360px";

  const title = document.createElement("h3");
  title.textContent = "Confirm stock type";
  panel.appendChild(title);

  const msg = document.createElement("p");
  msg.textContent =
    "What type of stock is used within this recipe?";
  panel.appendChild(msg);

  const label = document.createElement("label");
  label.textContent = "Stock type";
  label.style.display = "block";
  label.style.marginTop = "0.5rem";

  const select = document.createElement("select");
  ["Beef", "Chicken", "Vegetable"].forEach((type) => {
    const opt = document.createElement("option");
    opt.value = type;
    opt.textContent = type;
    select.appendChild(opt);
  });

  label.appendChild(select);
  panel.appendChild(label);

  // Buttons
  const btnRow = document.createElement("div");
  btnRow.className = "barcode-scanner-actions";
  btnRow.style.marginTop = "1rem";

  const cancelBtn = document.createElement("button");
  cancelBtn.type = "button";
  cancelBtn.className = "secondary";
  cancelBtn.textContent = "Skip";
  cancelBtn.addEventListener("click", () => {
    overlay.remove(); // leave as generic "Stock"
  });

  const okBtn = document.createElement("button");
  okBtn.type = "button";
  okBtn.className = "ios-green-button";
  okBtn.textContent = "Save";
  okBtn.addEventListener("click", () => {
    const chosen = select.value || "Beef";

    genericStocks.forEach((ing) => {
      ing.name = `${chosen} Stock`;
    });

    saveState();
    renderRecipesList();
    // If you want the detail overlay (if open) to update too,
    // you could also call renderMealPlan() or reopen the recipe.
    overlay.remove();
  });

  btnRow.appendChild(cancelBtn);
  btnRow.appendChild(okBtn);
  panel.appendChild(btnRow);

  overlay.appendChild(panel);
  document.body.appendChild(overlay);

  // Tap outside to close
  overlay.addEventListener("click", (e) => {
    if (e.target === overlay) overlay.remove();
  });
}

function openRecipeImportPreviewDialog(parsed) {
  // parsed is the object returned by importRecipeFromUrl

  // Remove any old overlay
  const old = document.getElementById("recipe-import-preview-overlay");
  if (old) old.remove();

  const overlay = document.createElement("div");
  overlay.id = "recipe-import-preview-overlay";
  overlay.className = "barcode-scanner-overlay"; // reuse dark scrim

  const panel = document.createElement("div");
  panel.className = "barcode-scanner-panel add-item-panel";

  // --- Title ---
  const title = document.createElement("h2");
  title.textContent = parsed.title || "Imported recipe";
  panel.appendChild(title);

  // --- Image preview (if any) ---
  if (parsed.imageUrl) {
    const imgWrap = document.createElement("div");
    imgWrap.className = "recipe-image-preview-wrapper";

    const img = document.createElement("img");
    img.src = parsed.imageUrl;
    img.alt = parsed.title || "Recipe image";
    img.className = "recipe-image-preview";

    imgWrap.appendChild(img);
    panel.appendChild(imgWrap);
  }

  // --- Servings text (if any) ---
  if (parsed.servingsText || parsed.servingsNumber) {
    const meta = document.createElement("p");
    meta.className = "recipe-card-meta";
    if (parsed.servingsNumber) {
      meta.textContent =
        `Serves ${parsed.servingsNumber} (${parsed.servingsText || ""})`;
    } else {
      meta.textContent = parsed.servingsText;
    }
    panel.appendChild(meta);
  }

  // --- Ingredients preview (raw text, just for review) ---
  const ingTitle = document.createElement("h3");
  ingTitle.textContent = "Ingredients detected";
  panel.appendChild(ingTitle);

  const ingList = document.createElement("ul");
  ingList.className = "recipe-detail-ingredients";

  (parsed.ingredients || []).forEach((line) => {
    const li = document.createElement("li");
    li.textContent = line;
    ingList.appendChild(li);
  });

  panel.appendChild(ingList);

  // --- Buttons row ---
  const btnRow = document.createElement("div");
  btnRow.className = "barcode-scanner-actions";

  const cancelBtn = document.createElement("button");
  cancelBtn.type = "button";
  cancelBtn.className = "inventory-delete-button";
  cancelBtn.textContent = "Cancel";
  cancelBtn.addEventListener("click", () => {
    const ov = document.getElementById("recipe-import-preview-overlay");
    if (ov && ov.parentNode) ov.parentNode.removeChild(ov);
  });

  const importBtn = document.createElement("button");
  importBtn.type = "button";
  importBtn.className = "ios-green-button";
  importBtn.textContent = "Import recipe";

  importBtn.addEventListener("click", () => {
    // --- 1) Clean recipe name ---
    const rawName = parsed.title || "Imported recipe";
    const name =
      typeof titleCase === "function" ? titleCase(rawName) : rawName;

    // --- 2) Servings ---
    const servings =
      parsed.servingsNumber && parsed.servingsNumber > 0
        ? parsed.servingsNumber
        : 2; // safe default

    // --- 3) Lines + BBC ingredient names ---
    const lines = Array.isArray(parsed.ingredients)
      ? parsed.ingredients
      : [];

    const ingredientNames =
      (parsed.ingredientNames && parsed.ingredientNames.length)
        ? parsed.ingredientNames
        : (
            window.lastImportedRecipeMeta &&
            Array.isArray(window.lastImportedRecipeMeta.ingredientNames)
              ? window.lastImportedRecipeMeta.ingredientNames
              : []
          );

    // --- 3b) Parse lines and MERGE duplicates (same name + unit) ---
    const byKey = new Map();

       lines.forEach((line) => {
      const trimmed = (line || "").trim();
      if (!trimmed) return;

      let normLine = typeof normaliseFractions === "function"
  ? normaliseFractions(trimmed)
  : trimmed;

// üîπ special clean-up for stock lines like "600ml/20fl oz stock (ideally beef...)"
normLine = cleanStockLine(normLine);

      // Did the (normalised) text contain any digits?
      const hadExplicitNumber = /\d/.test(normLine);

      let parsedIng = null;

      // Prefer BBC-specific parser if available
         if (
        ingredientNames.length &&
        typeof parseBbcIngredient === "function"
      ) {
        parsedIng = parseBbcIngredient(normLine, ingredientNames);
      }

      // Fallback: generic parser
      if (!parsedIng && typeof parseIngredientLine === "function") {
        parsedIng = parseIngredientLine(normLine);
      }
      // Last resort: just keep the line as a name
      if (!parsedIng) {
        parsedIng = {
          name: trimmed,
          quantity: null,
          unit: "",
        };
      }

      if (!parsedIng.name) return;

            // If the line clearly has a fraction (1/4, 1 1/4, etc),
      // override whatever quantity the parser guessed and
      // compute it ourselves, so "1/4 onion" becomes 0.25.
      if (
        hadExplicitNumber &&
        /(\d+\s+)?\d+\/\d+/.test(normLine) &&         // looks like a fraction
        typeof parseLeadingFractionQuantity === "function"
      ) {
        const fracQty = parseLeadingFractionQuantity(normLine);
        if (fracQty && fracQty > 0) {
          parsedIng.quantity = fracQty;              // e.g. 0.25 or 1.25

          // If the parser treated something like "1/4" as a unit, drop it
          if (parsedIng.unit && /\/\d+/.test(parsedIng.unit)) {
            parsedIng.unit = "";
          }
        }
      }

            // If parser didn't give a quantity but we DO have numbers,
      // try to parse leading fraction(s) like "1/4" or "1 1/4".
      if (
        (parsedIng.quantity === null || parsedIng.quantity === undefined) &&
        hadExplicitNumber &&
        typeof parseLeadingFractionQuantity === "function"
      ) {
        const fracQty = parseLeadingFractionQuantity(normLine);
        if (fracQty && fracQty > 0) {
          parsedIng.quantity = fracQty;   // e.g. 0.25, 1.25
        }
      }

      // If parser guessed quantity = 1 but original line had NO digits,
      // treat it as "no explicit quantity" (so it can become a staple).
      if (!hadExplicitNumber && parsedIng.quantity === 1) {
        parsedIng.quantity = null;
        parsedIng.unit = "";
      }

      // If quantity is present, it must be a positive number
           // If quantity is present, coerce to a positive number
      if (
        parsedIng.quantity !== null &&
        parsedIng.quantity !== undefined
      ) {
        const numQty = Number(parsedIng.quantity);
        if (!Number.isFinite(numQty) || numQty <= 0) {
          return;
        }
        parsedIng.quantity = numQty; // normalise to Number
      }
      
            // Try to recover missing units from the text line
      parsedIng = fixMissingUnitFromLine(normLine, parsedIng);

      // Apply smart defaults for anything still missing (wine ‚Üí bottle, rosemary ‚Üí sprig, etc.)
      if (typeof applySmartDefaultUnit === "function") {
        parsedIng.unit = applySmartDefaultUnit(
          parsedIng.name,
          parsedIng.quantity,
          parsedIng.unit
        );
      }

      // MERGE step: same name + unit ‚Üí summed quantity
      const nameKey = (parsedIng.name || "").toLowerCase().trim();
      const unitKey = (parsedIng.unit || "").toLowerCase().trim();
      const key = nameKey + "||" + unitKey;

           const existing = byKey.get(key);
      if (existing) {
        const q1 = existing.quantity != null ? Number(existing.quantity) : 0;
        const q2 = parsedIng.quantity != null ? Number(parsedIng.quantity) : 0;

        const safeQ1 = Number.isFinite(q1) ? q1 : 0;
        const safeQ2 = Number.isFinite(q2) ? q2 : 0;
        const mergedQty = safeQ1 + safeQ2;

        existing.quantity = mergedQty > 0 ? mergedQty : null;
      } else {
        byKey.set(key, { ...parsedIng });
      }
    });

    const newIngredients = Array.from(byKey.values());

    if (!newIngredients.length) {
      if (!confirm("No valid ingredients were parsed. Save recipe anyway?")) {
        return;
      }
    }

    // --- 4) Build final recipe object ---
    const newRecipe = {
      id: String(Date.now()),
      name,
      servings,
      ingredients: newIngredients,
      instructions:
        window.lastImportedRecipeMeta &&
        Array.isArray(window.lastImportedRecipeMeta.instructions)
          ? window.lastImportedRecipeMeta.instructions.slice()
          : [],
      imageUrl: parsed.imageUrl || "",
      sourceUrl: parsed.sourceUrl || "",
    };

    // --- 5) Save / update recipe list (avoid duplicates) ---

// See if a recipe with the same sourceUrl already exists
let existingIndex = -1;

if (newRecipe.sourceUrl) {
  existingIndex = recipes.findIndex(
    (r) => r.sourceUrl && r.sourceUrl === newRecipe.sourceUrl
  );
}

// If no match by sourceUrl, fall back to name match
if (existingIndex === -1) {
  existingIndex = recipes.findIndex((r) => r.name === newRecipe.name);
}

if (existingIndex !== -1) {
  // Overwrite existing recipe, keep its id stable
  newRecipe.id = recipes[existingIndex].id;
  recipes[existingIndex] = newRecipe;
} else {
  // Brand-new recipe
  recipes.push(newRecipe);
}

saveState();
renderRecipesList();

// üîπ Only now open the stock-type dialog once
if (typeof openStockTypeDialogForRecipe === "function") {
  openStockTypeDialogForRecipe(newRecipe.id);
}

    // Close preview overlay
    const ov = document.getElementById("recipe-import-preview-overlay");
    if (ov && ov.parentNode) ov.parentNode.removeChild(ov);

    if (typeof showPage === "function") {
      showPage("page-recipes");
    }
  });

  btnRow.appendChild(cancelBtn);
  btnRow.appendChild(importBtn);
  panel.appendChild(btnRow);

  overlay.appendChild(panel);
  document.body.appendChild(overlay);

  // Animate in
  requestAnimationFrame(() => {
    panel.classList.add("visible");
  });
}

const MEAL_SLOTS = [
  { key: "breakfast", label: "Breakfast" },
  { key: "lunch",     label: "Lunch"     },
  { key: "dinner",    label: "Dinner"    },
];

const DAY_NAMES = ["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"];
const MONTH_NAMES = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];

function normaliseMealPlan() {
  if (!Array.isArray(mealPlan)) {
    mealPlan = [];
  }

  // 1) Work out which Monday this week is anchored to
  if (!mealPlanBaseMonday) {
    // Try to infer from existing data (first day with a date)
    const firstWithDate = mealPlan.find((d) => d && d.dateISO);
    if (firstWithDate && firstWithDate.dateISO) {
      mealPlanBaseMonday = getMonday(new Date(firstWithDate.dateISO));
    } else {
      // Fallback: current week
      mealPlanBaseMonday = getMonday(new Date());
    }
  }

  const base = new Date(mealPlanBaseMonday);
  const nextPlan = [];

  for (let i = 0; i < 7; i++) {
    const thisDate = new Date(base);
    thisDate.setDate(base.getDate() + i);

    const existing = mealPlan[i] || {};

    nextPlan.push({
      // keep any existing slots (breakfast / lunch / dinner)
      ...existing,
      dateISO: thisDate.toISOString().slice(0, 10),
    });
  }

  mealPlan = nextPlan;
}

function formatWeekRangeLabel() {
  if (!mealPlanBaseMonday) {
    mealPlanBaseMonday = getMonday(new Date());
  }
  const start = new Date(mealPlanBaseMonday);
  const end = new Date(mealPlanBaseMonday);
  end.setDate(end.getDate() + 6);
  return `${formatDayMonth(start)}‚Äì${formatDayMonth(end)}`;
}

function formatDayLabel(dayObj) {
  let d;
  if (dayObj && dayObj.dateISO) {
    d = new Date(dayObj.dateISO);
  } else {
    d = new Date();
  }

  const dayName = d.toLocaleDateString(undefined, { weekday: "long" });
  const dateLabel = d.toLocaleDateString(undefined, {
    day: "numeric",
    month: "short",
  });

  return { dayName, dateLabel };
}

function getRecipeById(id) {
  if (!id) return null;
  return recipes.find(r => r.id === id) || null;
}

let mealPlanBaseMonday = null; // "anchor" Monday for the current week

function getMonday(date) {
  const d = new Date(date);
  const day = d.getDay(); // 0=Sun, 1=Mon, ... 6=Sat
  const diff = (day + 6) % 7; // how many days since Monday
  d.setDate(d.getDate() - diff);
  d.setHours(0, 0, 0, 0);
  return d;
}

function formatDayMonth(d) {
  return d.toLocaleDateString(undefined, {
    day: "numeric",
    month: "short",
  });
}

function openMealplanWeekPicker() {
  // Kill any existing picker
  const old = document.getElementById("mealplan-week-overlay");
  if (old) old.remove();

  // Start from current base Monday or today
  let workingMonth = mealPlanBaseMonday
    ? new Date(mealPlanBaseMonday)
    : new Date();
  workingMonth.setDate(1); // first of the month

  const overlay = document.createElement("div");
  overlay.id = "mealplan-week-overlay";
  overlay.className = "barcode-scanner-overlay";

  const panel = document.createElement("div");
  panel.className = "barcode-scanner-panel add-item-panel week-picker-panel";

  // --- Header: title + close ---
  const title = document.createElement("h2");
  title.textContent = "Pick week";
  panel.appendChild(title);

  // Month nav row
  const monthRow = document.createElement("div");
  monthRow.className = "week-picker-month-row";

  const prevBtn = document.createElement("button");
  prevBtn.type = "button";
  prevBtn.className = "secondary week-picker-nav";
  prevBtn.textContent = "‚Äπ";

  const monthLabel = document.createElement("div");
  monthLabel.className = "week-picker-month-label";

  const nextBtn = document.createElement("button");
  nextBtn.type = "button";
  nextBtn.className = "secondary week-picker-nav";
  nextBtn.textContent = "‚Ä∫";

  monthRow.appendChild(prevBtn);
  monthRow.appendChild(monthLabel);
  monthRow.appendChild(nextBtn);
  panel.appendChild(monthRow);

  // Weekday headings + grid
  const grid = document.createElement("div");
  grid.className = "week-picker-grid";
  panel.appendChild(grid);

  // Buttons row at bottom
  const btnRow = document.createElement("div");
  btnRow.className = "barcode-scanner-actions";

  const cancelBtn = document.createElement("button");
  cancelBtn.type = "button";
  cancelBtn.className = "inventory-delete-button";
  cancelBtn.textContent = "Cancel";
  cancelBtn.addEventListener("click", () => {
    overlay.remove();
  });

  btnRow.appendChild(cancelBtn);
  panel.appendChild(btnRow);

  overlay.appendChild(panel);
  document.body.appendChild(overlay);

  requestAnimationFrame(() => panel.classList.add("visible"));

  // --- Render current month ---
  function renderMonth() {
    monthLabel.textContent = workingMonth.toLocaleDateString(undefined, {
      month: "long",
      year: "numeric",
    });

    grid.innerHTML = "";

    const weekdayNames = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
    weekdayNames.forEach((name) => {
      const head = document.createElement("div");
      head.className = "week-picker-header-cell";
      head.textContent = name;
      grid.appendChild(head);
    });

    const year = workingMonth.getFullYear();
    const month = workingMonth.getMonth();
    const firstOfMonth = new Date(year, month, 1);
    const firstDow = firstOfMonth.getDay(); // 0=Sun,1=Mon,..6=Sat
    const startColumn = (firstDow + 6) % 7; // Mon=0

    // Empty slots before day 1
    for (let i = 0; i < startColumn; i++) {
      const empty = document.createElement("div");
      empty.className = "week-picker-empty-cell";
      grid.appendChild(empty);
    }

    const daysInMonth = new Date(year, month + 1, 0).getDate();

    for (let day = 1; day <= daysInMonth; day++) {
      const date = new Date(year, month, day);
      const cell = document.createElement("button");
      cell.type = "button";
      cell.textContent = String(day);
      cell.className = "week-picker-day";

      const dow = date.getDay(); // 1 = Monday

      if (dow !== 1) {
        // Not Monday ‚Üí disabled grey cell
        cell.disabled = true;
        cell.classList.add("not-monday");
      } else {
        // Monday ‚Üí selectable
        cell.classList.add("monday-selectable");
        cell.addEventListener("click", () => {
          mealPlanBaseMonday = getMonday(date);
          normaliseMealPlan();
          renderMealPlan();
          saveState && saveState();
          overlay.remove();
        });
      }

      grid.appendChild(cell);
    }
  }

  // Month navigation
  prevBtn.addEventListener("click", () => {
    workingMonth.setMonth(workingMonth.getMonth() - 1);
    renderMonth();
  });

  nextBtn.addEventListener("click", () => {
    workingMonth.setMonth(workingMonth.getMonth() + 1);
    renderMonth();
  });

  // Close if tap outside panel
  overlay.addEventListener("click", (e) => {
    if (e.target === overlay) overlay.remove();
  });

  renderMonth();
}

// Long-press on a meal slot ‚Üí "LET'S COOK!!" dialog
function attachMealSlotLongPress(btn, dayIndex, slotKey) {
  let pressTimer = null;

  // Avoid text selection on long-press
  btn.style.userSelect = "none";
  btn.style.webkitUserSelect = "none";

  const start = (event) => {
    // Don‚Äôt kill normal click ‚Äì just prevent text selection
    event.preventDefault();

    if (pressTimer !== null) return;

    pressTimer = setTimeout(() => {
      pressTimer = null;
      // mark that this was a long-press so click handler can ignore it
      btn._mealSlotLongPressFired = true;
      openLetsCookDialog(dayIndex, slotKey);
    }, 450); // ~0.45s long press
  };

  const cancel = () => {
    if (pressTimer !== null) {
      clearTimeout(pressTimer);
      pressTimer = null;
    }
  };

  btn.addEventListener("pointerdown", start);
  btn.addEventListener("pointerup", cancel);
  btn.addEventListener("pointerleave", cancel);
  btn.addEventListener("pointercancel", cancel);
}

function openLetsCookDialog(dayIndex, slotKey) {
  normaliseMealPlan();

  const dayObj = mealPlan[dayIndex];
  if (!dayObj) return;

  const slotState = dayObj[slotKey] || { recipeId: "", servings: 0 };
  if (!slotState.recipeId) {
    alert("No recipe selected for this slot yet.");
    return;
  }

  const recipe = getRecipeById(slotState.recipeId);
  if (!recipe) {
    alert("Recipe not found.");
    return;
  }

  const { dayName, dateLabel } = formatDayLabel(dayObj);

  // What is currently planned for this slot?
  const plannedServings =
    (slotState.servings && slotState.servings > 0)
      ? slotState.servings
      : (recipe.servings && recipe.servings > 0 ? recipe.servings : 1);

  // Kill any existing LET'S COOK overlay
  const old = document.getElementById("lets-cook-overlay");
  if (old) old.remove();

  const overlay = document.createElement("div");
  overlay.id = "lets-cook-overlay";
  overlay.className = "recipe-detail-overlay";

  const panel = document.createElement("div");
  panel.className = "recipe-detail-panel";

  // Title
  const titleEl = document.createElement("h2");
  titleEl.textContent = "LET'S COOK!!";
  panel.appendChild(titleEl);

  // Little summary
  const info = document.createElement("p");
  info.textContent = `${dayName} ¬∑ ${
    slotKey.charAt(0).toUpperCase() + slotKey.slice(1)
  } ¬∑ ${dateLabel}`;
  panel.appendChild(info);

  const recipeLine = document.createElement("p");
  recipeLine.textContent = `${recipe.name} ‚Äì ${plannedServings} serving${
    plannedServings === 1 ? "" : "s"
  }`;
  panel.appendChild(recipeLine);

  // --- Servings input in this dialog ---
  const servingsLabel = document.createElement("label");
  servingsLabel.textContent = "How many servings are you cooking?";
  servingsLabel.style.display = "block";

  const servingsInput = document.createElement("input");
  servingsInput.type = "number";
  servingsInput.min = "1";
  servingsInput.step = "1";
  servingsInput.value = String(plannedServings);
  servingsInput.style.marginTop = "0.5rem";

  servingsLabel.appendChild(servingsInput);
  panel.appendChild(servingsLabel);

  // Buttons row
  const btnRow = document.createElement("div");
  btnRow.className = "barcode-scanner-actions";

  const cancelBtn = document.createElement("button");
  cancelBtn.type = "button";
  cancelBtn.className = "inventory-delete-button";
  cancelBtn.textContent = "Cancel";
  cancelBtn.addEventListener("click", () => overlay.remove());

  const cookBtn = document.createElement("button");
  cookBtn.type = "button";
  cookBtn.className = "ios-green-button";
  cookBtn.textContent = "Open recipe";

  cookBtn.addEventListener("click", () => {
    // Read the chosen servings from this dialog
    let chosenServings = parseFloat(servingsInput.value || "0");
    if (!chosenServings || chosenServings <= 0) {
      chosenServings = plannedServings;
    }

    // Close LET'S COOK dialog
    overlay.remove();

    // üî• Open the cook overlay, passing the RECIPE OBJECT + servings
    openCookDialog(recipe, chosenServings);
  });

  btnRow.appendChild(cancelBtn);
  btnRow.appendChild(cookBtn);
  panel.appendChild(btnRow);

  overlay.appendChild(panel);
  document.body.appendChild(overlay);

  // Tap dim background to close
  overlay.addEventListener("click", (e) => {
    if (e.target === overlay) overlay.remove();
  });
}

function renderMealPlan() {
  const container = document.getElementById("mealplan-days");
  const labelEl   = document.getElementById("mealplan-week-label");
  if (!container) return;

  // Make sure structure is sane
  normaliseMealPlan();

  // Update week label in header
  if (labelEl) {
    labelEl.textContent = `This week ¬∑ ${formatWeekRangeLabel()}`;
  }

  container.innerHTML = "";

  mealPlan.forEach((dayObj, dayIndex) => {
    const { dayName, dateLabel } = formatDayLabel(dayObj);

    const card = document.createElement("article");
    card.className = "mealplan-day-card";

    // Header
    const header = document.createElement("header");
    header.className = "mealplan-day-header";

    const left = document.createElement("div");
    const nameEl = document.createElement("div");
    nameEl.className = "mealplan-day-name";
    nameEl.textContent = dayName;

    const dateEl = document.createElement("div");
    dateEl.className = "mealplan-day-date";
    dateEl.textContent = dateLabel;

    left.appendChild(nameEl);
    left.appendChild(dateEl);
    header.appendChild(left);
    card.appendChild(header);

    // Meals
    const mealsWrap = document.createElement("div");
    mealsWrap.className = "mealplan-meals";

    MEAL_SLOTS.forEach(({ key, label }) => {
      const slotState = dayObj[key] || { recipeId: "", servings: 0 };
      const recipe    = getRecipeById(slotState.recipeId);

      const row = document.createElement("div");
      row.className = "mealplan-meal-row";

      const lab = document.createElement("span");
      lab.className = "mealplan-meal-label";
      lab.textContent = label;
      row.appendChild(lab);

      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "action-pill";
      btn._mealSlotLongPressFired = false;   // flag for long-press

      if (recipe) {
        const plannedServings =
          (slotState.servings && slotState.servings > 0)
            ? slotState.servings
            : (recipe.servings || null);

        if (plannedServings) {
          const servingWord =
            plannedServings === 1 ? "Serving" : "Servings";

          btn.innerHTML = `
            <strong>${recipe.name}</strong>
            <span class="mealplan-servings">
              &nbsp;‚Äì ${plannedServings} ${servingWord}
            </span>
          `;
        } else {
          btn.innerHTML = `<strong>${recipe.name}</strong>`;
        }
      } else {
        btn.textContent = "Add recipe";
      }

      // Normal tap ‚Üí open slot picker
      btn.addEventListener("click", () => {
        // if this click is immediately after a long-press, swallow it
        if (btn._mealSlotLongPressFired) {
          btn._mealSlotLongPressFired = false;
          return;
        }
        openMealSlotPicker(dayIndex, key);
      });

      // Long-press ‚Üí "LET'S COOK!!" dialog
      attachMealSlotLongPress(btn, dayIndex, key);

      row.appendChild(btn);
      mealsWrap.appendChild(row);
    });

    card.appendChild(mealsWrap);
    container.appendChild(card);
  });
}

function openMealSlotPicker(dayIndex, slotKey) {
  normaliseMealPlan();

  const dayObj  = mealPlan[dayIndex];
  const slotDef = MEAL_SLOTS.find(s => s.key === slotKey);
  if (!dayObj || !slotDef) return;

  const { dayName, dateLabel } = formatDayLabel(dayObj);
  const slotState = dayObj[slotKey] || { recipeId: "", servings: 0 };
  const currentRecipe = getRecipeById(slotState.recipeId);
    // We'll use these later in the Save button
  let recipeSelect = null;
  let servingsInput = null;

  // Kill any existing picker
  const old = document.getElementById("mealplan-slot-overlay");
  if (old) old.remove();

  // Overlay
  const overlay = document.createElement("div");
  overlay.id = "mealplan-slot-overlay";
  overlay.className = "barcode-scanner-overlay";

  const panel = document.createElement("div");
  panel.className = "barcode-scanner-panel add-item-panel";

  // Title
  const title = document.createElement("h2");
  title.textContent = `${slotDef.label} ¬∑ ${dayName}`;
  panel.appendChild(title);

  const subtitle = document.createElement("p");
  subtitle.style.marginTop = "0.1rem";
  subtitle.style.marginBottom = "0.6rem";
  subtitle.textContent = dateLabel;
  panel.appendChild(subtitle);

  const hasRecipes = Array.isArray(recipes) && recipes.length;

  // If there are no recipes yet, show a friendly message
  if (!hasRecipes) {
    const msg = document.createElement("p");
    msg.textContent =
      "No recipes saved yet. Add a recipe first, then come back to plan it.";
    panel.appendChild(msg);
  } else {
    // ----- Recipe dropdown -----
    const recipeRow = document.createElement("div");
    recipeRow.className = "barcode-input-row";

    const recipeLabel = document.createElement("label");
    recipeLabel.textContent = "Recipe";
    recipeLabel.style.display = "block";

    recipeSelect = document.createElement("select");

    const optNone = document.createElement("option");
    optNone.value = "";
    optNone.textContent = "Select a recipe‚Ä¶";
    recipeSelect.appendChild(optNone);

    recipes.forEach((r) => {
      const opt = document.createElement("option");
      opt.value = r.id;
      opt.textContent = r.name;
      if (currentRecipe && r.id === currentRecipe.id) {
        opt.selected = true;
      }
      recipeSelect.appendChild(opt);
    });

    recipeLabel.appendChild(recipeSelect);
    recipeRow.appendChild(recipeLabel);
    panel.appendChild(recipeRow);

    // ----- Servings input -----
    const servingsRow = document.createElement("div");
    servingsRow.className = "barcode-input-row";

    const servingsLabel = document.createElement("label");
    servingsLabel.textContent = "Servings";
    servingsLabel.style.display = "block";

    servingsInput = document.createElement("input");
    servingsInput.type = "number";
    servingsInput.min = "1";
    servingsInput.step = "1";

    const defaultServings =
      (slotState.servings && slotState.servings > 0)
        ? slotState.servings
        : (currentRecipe && currentRecipe.servings && currentRecipe.servings > 0
            ? currentRecipe.servings
            : 2);

    servingsInput.value = String(defaultServings);

    servingsLabel.appendChild(servingsInput);
    servingsRow.appendChild(servingsLabel);
    panel.appendChild(servingsRow);

    // When recipe changes, update servings to that recipe's default
    recipeSelect.addEventListener("change", () => {
      const chosenId = recipeSelect.value;
      const chosen = getRecipeById(chosenId);
      if (chosen && chosen.servings && chosen.servings > 0) {
        servingsInput.value = String(chosen.servings);
      }
    });
  }

   // Buttons row
  const btnRow = document.createElement("div");
  btnRow.className = "barcode-scanner-actions";

  // ----- Save (only if we actually have recipes) -----
  if (recipeSelect && servingsInput) {
    const saveBtn = document.createElement("button");
    saveBtn.type = "button";
    saveBtn.className = "ios-green-button";
    saveBtn.textContent = "Save";

    saveBtn.addEventListener("click", () => {
      const recipeId = recipeSelect.value;
      if (!recipeId) {
        alert("Please choose a recipe, or Clear the slot.");
        return;
      }

      const recipe = getRecipeById(recipeId);
      let servingsNum = parseFloat(servingsInput.value || "0");

      if (!servingsNum || servingsNum <= 0 || Number.isNaN(servingsNum)) {
        servingsNum =
          recipe && recipe.servings && recipe.servings > 0
            ? recipe.servings
            : 2;
      }

      dayObj[slotKey] = {
        recipeId,
        servings: servingsNum
      };

      saveState();
      renderMealPlan();
      overlay.remove();
    });

    btnRow.appendChild(saveBtn);
  }

  // ----- Clear this slot -----
  const clearBtn = document.createElement("button");
  clearBtn.type = "button";
  clearBtn.className = "inventory-delete-button";
  clearBtn.textContent = currentRecipe ? "Clear slot" : "Clear";
  clearBtn.addEventListener("click", () => {
    dayObj[slotKey] = { recipeId: "", servings: 0 };
    saveState();
    renderMealPlan();
    overlay.remove();
  });

  // ----- Cancel -----
  const cancelBtn = document.createElement("button");
  cancelBtn.type = "button";
  cancelBtn.className = "secondary";
  cancelBtn.textContent = "Cancel";
  cancelBtn.addEventListener("click", () => overlay.remove());

  btnRow.appendChild(clearBtn);
  btnRow.appendChild(cancelBtn);
  panel.appendChild(btnRow);

  overlay.appendChild(panel);
  document.body.appendChild(overlay);

  requestAnimationFrame(() => {
    panel.classList.add("visible");
  });

  // Close by tapping outside
  overlay.addEventListener("click", (e) => {
    if (e.target === overlay) overlay.remove();
  });
}

function clearMealPlanWeek() {
  normaliseMealPlan();
  mealPlan.forEach(day => {
    MEAL_SLOTS.forEach(({ key }) => {
      day[key] = { recipeId: "", servings: 0 };
    });
  });
  saveState();
  renderMealPlan();
}

function pluraliseUnit(rawUnit, quantity) {
  const unit = (rawUnit || "").toLowerCase();
  const q = Number(quantity);

  // Units that NEVER get an "s"
  const FIXED_UNITS = ["g", "kg", "ml", "tsp", "tbsp"];
  if (FIXED_UNITS.includes(unit)) {
    return unit;
  }

  // Special case: litres
  if (unit === "l") {
    return q === 1 ? "litre" : "litres";
  }

  if (!unit) return "";

  // Default plural logic for word-y units like bottle, sprig, pack‚Ä¶
  if (q === 1) return unit;
  if (unit.endsWith("y")) return unit.slice(0, -1) + "ies";
  return unit + "s";
}

function generateShoppingList() {
  // Keep the structure sane first
  if (typeof normaliseMealPlan === "function") {
    normaliseMealPlan();
  }

  const required = {};

  // Walk every day and every MEAL_SLOT
  mealPlan.forEach((dayEntry) => {
    if (!dayEntry) return;

    MEAL_SLOTS.forEach(({ key }) => {
      const slot = dayEntry[key];
      if (!slot || !slot.recipeId) return;

      const plannedServings = parseFloat(slot.servings || "0");
      if (!plannedServings || plannedServings <= 0) return;

      const recipe = recipes.find((r) => r.id === slot.recipeId);
      if (!recipe || !recipe.servings || recipe.servings <= 0) return;

      const scale = plannedServings / recipe.servings;

      (recipe.ingredients || []).forEach((ing) => {
        if (!ing || !ing.name) return;

        // Skip staples (salt, oil, pepper, etc.)
        if (
          typeof isStapleIngredient === "function" &&
          isStapleIngredient(ing.name)
        ) {
          return;
        }

        // Skip if no usable quantity
        if (!ing.quantity || ing.quantity <= 0) {
          return;
        }

        const keyName = (ing.name || "").toLowerCase();
        const ingUnit = normaliseUnit(ing.unit || "");

        // Reuse existing baseUnit for this ingredient name if we have one
        const existing = required[keyName];
        const baseUnit = existing
          ? existing.baseUnit
          : (typeof chooseBaseUnit === "function"
              ? chooseBaseUnit(ingUnit, ing.name)
              : ingUnit);

        if (!required[keyName]) {
          required[keyName] = {
            name: ing.name,
            quantityBase: 0,
            baseUnit,
          };
        }

        const qtyScaled = ing.quantity * scale;

        const qtyInBase =
          typeof convertToUnit === "function"
            ? convertToUnit(qtyScaled, ingUnit, required[keyName].baseUnit)
            : qtyScaled;

        required[keyName].quantityBase += qtyInBase;
      });
    });
  });

  const tbody = document.querySelector("#shopping-table tbody");
  if (!tbody) return;
  tbody.innerHTML = "";

  // Tidy number for display
  function formatNumberNice(n) {
    if (Number.isInteger(n)) return String(n);
    const oneDp = Math.round(n * 10) / 10;
    if (Number.isInteger(oneDp * 10)) return oneDp.toString();
    return (Math.round(n * 100) / 100).toString();
  }

  Object.keys(required).forEach((keyName) => {
    const need = required[keyName];
    const baseUnit = need.baseUnit;
    let requiredBase = need.quantityBase;

    // How much we already have (in same base unit)
    let invQtyBase = 0;
    const invItem = inventory.find(
      (i) => i.name.toLowerCase() === keyName
    );

    if (invItem && baseUnit && typeof convertToUnit === "function") {
      invQtyBase = convertToUnit(
        invItem.quantity,
        invItem.unit || "",
        baseUnit
      );
    } else if (invItem && !baseUnit) {
      invQtyBase = invItem.quantity;
    }

    let toBuyBase = Math.max(0, requiredBase - invQtyBase);
    if (toBuyBase <= 1e-9) return; // nothing to buy

    // Decide how to *display* quantity
    let displayQty = toBuyBase;
    let displayUnit = baseUnit;

    if (!displayUnit) {
      // No unit ‚Üí single items (onions, limes, eggs, etc.)
      // Always round UP so you don‚Äôt underbuy
      displayQty = Math.ceil(displayQty);
    } else {
      // g/ml ‚Üî kg/l conversion
      if (baseUnit === "g") {
        if (displayQty >= 1000) {
          displayQty = displayQty / 1000;
          displayUnit = "kg";
        } else {
          displayUnit = "g";
        }
      } else if (baseUnit === "ml") {
        if (displayQty >= 1000) {
          displayQty = displayQty / 1000;
          displayUnit = "l";
        } else {
          displayUnit = "ml";
        }
      }

      // Let your helper round to sensible shopping amounts
      if (typeof roundUpForShopping === "function") {
        displayQty = roundUpForShopping(displayQty, displayUnit);
      }
    }

    // Build a nice string, with litres spelt out and
    // bottle/sprig/etc pluralised via pluraliseUnit()
   const q = displayQty;
const u = normaliseUnit(displayUnit || "");
const niceQty = formatNumberNice(q);
const unitLabel = pluraliseUnit(u, q);

let qtyStr = unitLabel ? `${niceQty} ${unitLabel}` : niceQty;

    // Convert tiny kg/L back to g/ml in the final string if needed
    let fixedQtyStr = qtyStr;
    const match = qtyStr.match(/^(\d+(?:\.\d+)?)\s*(kg|KG|l|L)$/);

    if (match) {
      let value = parseFloat(match[1]);
      const unit = match[2].toLowerCase();

      const tidy = (n) =>
        Number.isInteger(n)
          ? String(n)
          : (Math.round(n * 100) / 100).toString();

      if (unit === "kg" && value < 1) {
        const grams = value * 1000;
        fixedQtyStr = tidy(grams) + "g";
      } else if (unit === "l" && value < 1) {
        const ml = value * 1000;
        fixedQtyStr = tidy(ml) + "ml";
      }
    }

    // Table row
    const tr = document.createElement("tr");
    tr.dataset.itemName = need.name;
    tr.dataset.buyQty = String(displayQty);
    tr.dataset.buyUnit = displayUnit || "";

    const tdCheck = document.createElement("td");
    const cb = document.createElement("input");
    cb.type = "checkbox";
    cb.className = "shopping-bought";
    tdCheck.appendChild(cb);

    const tdName = document.createElement("td");
    tdName.textContent = need.name;

    const tdBuy = document.createElement("td");
    tdBuy.textContent = fixedQtyStr;

    tr.appendChild(tdCheck);
    tr.appendChild(tdName);
    tr.appendChild(tdBuy);
    tbody.appendChild(tr);
  });

  // When you tick items, add them into inventory
  const checkboxes = tbody.querySelectorAll(".shopping-bought");
  checkboxes.forEach((cb) => {
    cb.addEventListener("change", () => {
      const tr = cb.closest("tr");
      if (!tr) return;
      if (!cb.checked || tr.dataset.applied === "true") return;

      const name = tr.dataset.itemName;
      const qty = parseFloat(tr.dataset.buyQty || "0");
      const unit = tr.dataset.buyUnit || "";
      if (!name || !qty || qty <= 0) return;

      if (typeof upsertInventoryItem === "function") {
        upsertInventoryItem(name, qty, unit);
      }
      tr.dataset.applied = "true";

      renderInventory();
      renderInventoryNameSuggestions();
      saveState();
    });
  });
}

let activeBarcodeReader = null;
let barcodeScanHandled = false;
let scanSessionId = 0;

window.barcodeMap = window.barcodeMap || {};

function stopBarcodeReader() {
  try {
    if (activeBarcodeReader && typeof activeBarcodeReader.reset === "function") {
      activeBarcodeReader.reset();
    }
  } catch (err) {
    console.error("Error resetting barcode reader:", err);
  }
  activeBarcodeReader = null;

  const video = document.getElementById("barcode-video");
  if (video && video.srcObject) {
    try {
      video.srcObject.getTracks().forEach((t) => t.stop());
    } catch (err) {
      console.error("Error stopping video tracks:", err);
    }
    video.srcObject = null;
  }
}

function closeBarcodeScannerOverlay() {
  barcodeScanHandled = true;          // guard so callback ignores further reads
  stopBarcodeReader();

  const overlay = document.getElementById("barcode-scanner-overlay");
  if (overlay && overlay.parentNode) {
    overlay.parentNode.removeChild(overlay);
  }
}

function openBarcodeScanner() {
  if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
    alert("Camera access is not supported on this device / browser.");
    return;
  }

  // New scan session
  scanSessionId++;
  const thisSession = scanSessionId;
  barcodeScanHandled = false;

  // Clean up any previous reader/overlay
  stopBarcodeReader();
  const oldOverlay = document.getElementById("barcode-scanner-overlay");
  if (oldOverlay) oldOverlay.remove();

  // Build overlay
  const overlay = document.createElement("div");
  overlay.id = "barcode-scanner-overlay";
  overlay.className = "barcode-scanner-overlay";

  const panel = document.createElement("div");
  panel.className = "barcode-scanner-panel";

  const title = document.createElement("h2");
  title.textContent = "Scan barcode";
  panel.appendChild(title);

  const video = document.createElement("video");
  video.id = "barcode-video";
  video.autoplay = true;
  video.playsInline = true;
  panel.appendChild(video);

  const btnRow = document.createElement("div");
  btnRow.className = "barcode-scanner-actions";

  const cancelBtn = document.createElement("button");
  cancelBtn.type = "button";
  cancelBtn.textContent = "Cancel";
  cancelBtn.className = "inventory-delete-button";
  cancelBtn.addEventListener("click", () => {
    closeBarcodeScannerOverlay();
  });

  btnRow.appendChild(cancelBtn);
  panel.appendChild(btnRow);
  overlay.appendChild(panel);

  // Tap dark background to cancel
  overlay.addEventListener("click", (e) => {
    if (e.target === overlay) {
      closeBarcodeScannerOverlay();
    }
  });

  document.body.appendChild(overlay);

  // Start ZXing
  const ZX = window.ZXingBrowser || window.ZXing;
  if (!ZX || !ZX.BrowserMultiFormatReader) {
    alert("Barcode scanner library not loaded.");
    return;
  }

  activeBarcodeReader = new ZX.BrowserMultiFormatReader();

  activeBarcodeReader.decodeFromVideoDevice(
    null,
    "barcode-video",
    (result, err) => {
      // Ignore if:
      //  - this is an old session
      //  - we've already handled a scan
      if (thisSession !== scanSessionId || barcodeScanHandled) return;

      if (!result || !result.text) return;

      const code = result.text.trim();
      if (!code) return;

      console.log("Barcode scanned:", code);

      barcodeScanHandled = true;
      closeBarcodeScannerOverlay();   // stop camera + remove overlay
      handleBarcodeCode(code);        // open your add-item flow ONCE
    }
  );
}

function handleBarcodeCode(barcode) {
  if (!barcode) return;

  const map = (window.barcodeMap = window.barcodeMap || {});
  const entry = map[barcode];

  // üÜï Case 1: brand new barcode ‚Äì no mapping yet
  if (!entry) {
    openAddInventoryItemDialog(null, {
      scannedBarcode: barcode,
      presetName: "",
    });
    return;
  }

  // Normalise entry to an array of names
  let names = Array.isArray(entry) ? entry.slice() : [entry];

  // Clean duplicates / blanks
  names = [...new Set(names.filter(Boolean))];

  // üßæ Case 2: exactly one known name
  if (names.length === 1) {
    const name = names[0];

    // ‚ùå Do NOT pass existing item here ‚Äì treat as a *new* entry,
    //     just with the name pre-filled.
    openAddInventoryItemDialog(null, {
      scannedBarcode: barcode,
      presetName: name,
    });
    return;
  }

  // üìã Case 3: multiple possible names ‚Üí show picker
  openBarcodeNamePicker(barcode, names);
}

function openBarcodeNamePicker(barcode, names) {
  // Normalise the list (turn single string ‚Üí array)
  if (!Array.isArray(names)) {
    names = names ? [names] : [];
  }

  // No names ‚Üí treat as new barcode
  if (names.length === 0) {
    openAddInventoryItemDialog(null, {
      scannedBarcode: barcode,
      presetName: name,
    });
    return;
  }

  // Only one ‚Üí open dialog prefilled
  if (names.length === 1) {
    const name = names[0];

    // Try to locate this item in your inventory
    const existing =
      inventory.find(
        (i) => i.name && i.name.toLowerCase() === name.toLowerCase()
      ) || null;

    openAddInventoryItemDialog(existing, {
      scannedBarcode: barcode,
      presetName: name,
    });
    return;
  }

  // Multiple names ‚Üí show picker
  const oldOverlay = document.getElementById("barcode-choice-overlay");
  if (oldOverlay) oldOverlay.remove();

  const overlay = document.createElement("div");
  overlay.id = "barcode-choice-overlay";
  overlay.className = "optional-overlay";

  const modal = document.createElement("div");
  modal.className = "optional-modal";

  // Title
  const title = document.createElement("h3");
  title.textContent = "Which item is this?";
  modal.appendChild(title);

  // Description
  const desc = document.createElement("p");
  desc.textContent =
    "This barcode is linked to multiple items. Choose one, or tap Something else to add another.";
  modal.appendChild(desc);

  // --- Buttons for each known name ---
  names.forEach((name) => {
    const btn = document.createElement("button");
    btn.type = "button";
    btn.textContent = name;
    btn.className = "inventory-edit-btn"; // your nice pill style
    btn.style.display = "block";
    btn.style.marginTop = "0.4rem";

    btn.addEventListener("click", () => {
      overlay.remove();

      const existing =
        inventory.find(
          (i) => i.name && i.name.toLowerCase() === name.toLowerCase()
        ) || null;

      openAddInventoryItemDialog(existing, {
        scannedBarcode: barcode,
        presetName: name,
      });
    });

    modal.appendChild(btn);
  });

  // --- Something else button ---
  const otherBtn = document.createElement("button");
  otherBtn.type = "button";
  otherBtn.textContent = "Something else‚Ä¶";
  otherBtn.className = "secondary";
  otherBtn.style.marginTop = "0.8rem";

  otherBtn.addEventListener("click", () => {
    overlay.remove();
    openAddInventoryItemDialog(null, {
      scannedBarcode: barcode, // <-- CRITICAL so new item is added to barcodeMap
      presetName: "",
    });
  });

  modal.appendChild(otherBtn);

  // --- Cancel button ---
  const cancelBtn = document.createElement("button");
  cancelBtn.type = "button";
  cancelBtn.textContent = "Cancel";
  cancelBtn.className = "inventory-delete-button";
  cancelBtn.style.marginTop = "0.5rem";

  cancelBtn.addEventListener("click", () => overlay.remove());

  modal.appendChild(cancelBtn);

  // Close picker when tapping background
  overlay.addEventListener("click", (evt) => {
    if (evt.target === overlay) overlay.remove();
  });

  overlay.appendChild(modal);
  document.body.appendChild(overlay);
}

function showPage(pageId) {
      const pages = document.querySelectorAll(".page");
      const navButtons = document.querySelectorAll(".app-nav button");

      pages.forEach((page) => {
        if (!page) return;
        page.classList.toggle("hidden", page.id !== pageId);
      });

      navButtons.forEach((btn) => {
        if (!btn) return;
        const controls = btn.getAttribute("aria-controls");
        btn.setAttribute(
          "aria-selected",
          controls === pageId ? "true" : "false"
        );
      });
    }

    // ---------- INIT ----------

 document.addEventListener("DOMContentLoaded", () => {
  loadState();

  // üîπ Make sure mealPlan has a sane 7-day structure
  if (typeof normaliseMealPlan === "function") {
    normaliseMealPlan();
  }

  // ----- NAV / MENU -----
  const menuToggle = document.getElementById("menu-toggle");
  const appNav = document.getElementById("app-nav");

  function closeMenu() {
    if (appNav) appNav.classList.remove("nav-open");
    if (menuToggle) menuToggle.setAttribute("aria-expanded", "false");
  }

  if (menuToggle && appNav) {
    menuToggle.addEventListener("click", () => {
      const isOpen = appNav.classList.toggle("nav-open");
      menuToggle.setAttribute("aria-expanded", isOpen ? "true" : "false");
    });
  }

  const navInventory = document.getElementById("nav-inventory");
  const navRecipes   = document.getElementById("nav-recipes");
  const navMealplan  = document.getElementById("nav-mealplan");
  const navShopping  = document.getElementById("nav-shopping");

  if (navInventory) {
    navInventory.addEventListener("click", () => {
      showPage("page-inventory");
      closeMenu();
    });
  }

  if (navRecipes) {
    navRecipes.addEventListener("click", () => {
      showPage("page-recipes");
      closeMenu();
    });
  }

  if (navMealplan) {
    navMealplan.addEventListener("click", () => {
      showPage("page-mealplan");
      closeMenu();
    });
  }

  if (navShopping) {
    navShopping.addEventListener("click", () => {
      showPage("page-shopping");
      closeMenu();
    });
  }

  showPage("page-inventory");

  // === INVENTORY EVENTS ===
  const addInventoryBtn = document.getElementById("add-inventory-item-btn");
  const realScanBtn     = document.getElementById("real-scan-btn");

  if (addInventoryBtn) {
    addInventoryBtn.addEventListener("click", () => {
      console.log("Add item button clicked");

      console.log("typeof window.openAddInventoryItemDialog =",
        typeof window.openAddInventoryItemDialog
      );

      if (typeof window.openAddInventoryItemDialog !== "function") {
        console.error("openAddInventoryItemDialog is not a function:", window.openAddInventoryItemDialog);
        alert("Add item dialog is not available (JS error) ‚Äì check console.");
        return;
      }

      window.openAddInventoryItemDialog();
    });
  } else {
    console.warn("No #add-inventory-item-btn found in DOM");
  }

  if (realScanBtn) {
    realScanBtn.addEventListener("click", () => {
      openBarcodeScanner();
    });
  } else {
    console.warn("No #real-scan-btn found in DOM");
  }
  
  // ----- RECIPES BUTTONS -----
  const addRecipeBtn     = document.getElementById("add-recipe-btn");
  const recipeForm       = document.getElementById("recipe-form");
  const importRecipeBtn  = document.getElementById("import-recipe-btn");

  if (addRecipeBtn && recipeForm) {
    addRecipeBtn.addEventListener("click", () => {
      openRecipeMetaDialog();
    });
  }

  if (importRecipeBtn) {
    importRecipeBtn.addEventListener("click", () => {
      openRecipeImportDialog();
    });
  }

  // ----- RECIPES -----
  const startRecipeBtn       = document.getElementById("start-recipe");
  const ingSection           = document.getElementById("recipe-ingredients-section");
  const cancelRecipeEditBtn  = document.getElementById("cancel-recipe-edit");
  const importBtn            = document.getElementById("import-ingredients-btn");
  const ingForm              = document.getElementById("ingredient-form");
  const cancelIngEditBtn     = document.getElementById("cancel-ingredient-edit");
  const saveRecipeBtn        = document.getElementById("save-recipe");

  if (startRecipeBtn && ingSection && cancelRecipeEditBtn) {
    startRecipeBtn.addEventListener("click", () => {
      const nameEl     = document.getElementById("recipe-name");
      const servingsEl = document.getElementById("recipe-servings");

      const name = nameEl ? nameEl.value.trim() : "";
      const servings = servingsEl
        ? parseFloat(servingsEl.value || "0")
        : 0;

      if (!name || servings <= 0) {
        alert("Please enter a recipe name and servings.");
        return;
      }

      if (!currentRecipe || !editingRecipeId) {
        currentRecipe = {
          id: editingRecipeId || String(Date.now()),
          name: titleCase(name),
          servings,
          ingredients: [],
        };
      } else {
        currentRecipe.name     = titleCase(name);
        currentRecipe.servings = servings;
      }

      ingSection.classList.remove("hidden");
      renderCurrentRecipeIngredients();

      if (editingRecipeId) {
        cancelRecipeEditBtn.classList.remove("hidden");
      } else {
        cancelRecipeEditBtn.classList.add("hidden");
      }
      clearIngredientEditState();
    });
  }

  if (cancelRecipeEditBtn) {
    cancelRecipeEditBtn.addEventListener("click", () => {
      clearRecipeEditState();
    });
  }

  if (ingForm) {
    ingForm.addEventListener("submit", (e) => {
      e.preventDefault();
      if (!currentRecipe) {
        alert("Start a recipe first.");
        return;
      }

      const nameEl = document.getElementById("ing-name");
      const qtyEl  = document.getElementById("ing-qty");
      const unitEl = document.getElementById("ing-unit");

      const name = nameEl ? nameEl.value.trim() : "";
      const qty  = qtyEl  ? parseFloat(qtyEl.value || "0") : 0;
      const unit = unitEl ? unitEl.value.trim() : "";

      if (!name || qty <= 0) {
        alert("Please enter a valid ingredient name & quantity.");
        return;
      }

      const cleanName = titleCase(name);

      if (editingIngredientIndex !== null) {
        currentRecipe.ingredients[editingIngredientIndex] = {
          name: cleanName,
          quantity: qty,
          unit,
        };
        clearIngredientEditState();
      } else {
        currentRecipe.ingredients.push({
          name: cleanName,
          quantity: qty,
          unit,
        });
      }

      renderCurrentRecipeIngredients();
    });
  }

  if (cancelIngEditBtn) {
    cancelIngEditBtn.addEventListener("click", () => {
      clearIngredientEditState();
    });
  }

  // Import ingredients from textarea (BBC-aware parser)
  const recipeImportUrlInput = document.getElementById("recipe-import-url");
  const recipeImageFetchBtn  = document.getElementById("recipe-fetch-image");
  const recipeImportStatus   = document.getElementById("recipe-import-status");
  const recipeImagePreview   = document.getElementById("recipe-image-preview");
  const recipeImportTextarea = document.getElementById("import-text");
  const recipeClearBtn       = document.getElementById("recipe-clear-import");

  if (
    recipeImportUrlInput &&
    recipeImageFetchBtn &&
    recipeImportStatus &&
    recipeImagePreview &&
    recipeImportTextarea
  ) {
    if (recipeClearBtn) {
      recipeClearBtn.addEventListener("click", () => {
        recipeImportUrlInput.value = "";
        recipeImportStatus.textContent = "";
        recipeImportStatus.classList.remove("error");

        recipeImagePreview.style.display = "none";
        recipeImagePreview.src = "";

        recipeImportTextarea.value = "";
        lastImportedRecipeMeta = null;
      });
    }

    recipeImageFetchBtn.addEventListener("click", async () => {
      const rawUrl = recipeImportUrlInput.value.trim();
      if (!rawUrl) {
        recipeImportStatus.textContent = "Please paste a recipe URL first.";
        recipeImportStatus.classList.add("error");
        recipeImagePreview.style.display = "none";
        return;
      }

      recipeImportStatus.textContent = "Fetching recipe‚Ä¶";
      recipeImportStatus.classList.remove("error");
      recipeImagePreview.style.display = "none";
      lastImportedRecipeMeta = null;

      try {
        const endpoint = WORKER_BASE + "?url=" + encodeURIComponent(rawUrl);
        const res = await fetch(endpoint);
        if (!res.ok) {
          throw new Error("Proxy returned " + res.status);
        }
        const data = await res.json();

        if (!data || data.ok === false) {
          recipeImportStatus.textContent =
            (data && data.error) || "Recipe not found on that page.";
          recipeImportStatus.classList.add("error");
          recipeImagePreview.style.display = "none";
          return;
        }

        if (data.image) {
          recipeImagePreview.src = data.image;
          recipeImagePreview.style.display = "block";
        } else {
          recipeImagePreview.style.display = "none";
        }

        const titleInput = document.getElementById("recipe-name");
        if (titleInput && !titleInput.value.trim() && data.title) {
          titleInput.value = tidyRecipeTitle(data.title);
        }

        const servingsInput = document.getElementById("recipe-servings");
        if (servingsInput && data.servings) {
          const currentVal = servingsInput.value.trim();
          if (!currentVal || currentVal === "2") {
            const parsed = parseServingsNumber(data.servings);
            if (parsed && parsed > 0) {
              servingsInput.value = String(parsed);
            }
          }
        }

        if (Array.isArray(data.ingredients) && data.ingredients.length) {
          recipeImportTextarea.value = data.ingredients.join("\n");
        }

        const ingredientNames = Array.isArray(data.ingredientNames)
          ? data.ingredientNames
          : [];

        if (Array.isArray(data.instructions) && data.instructions.length) {
          lastImportedRecipeMeta = {
            instructions: data.instructions.slice(),
            sourceUrl: data.source || rawUrl,
            servingsText: data.servings || "",
            image: data.image || "",
            title: data.title || "",
            ingredientNames
          };
        } else {
          lastImportedRecipeMeta = {
            instructions: [],
            sourceUrl: data.source || rawUrl,
            servingsText: data.servings || "",
            image: data.image || "",
            title: data.title || "",
            ingredientNames
          };
        }

        recipeImportStatus.textContent =
          "Recipe info loaded. Review, then click 'Import ingredients'.";
        recipeImportStatus.classList.remove("error");
      } catch (err) {
        console.error(err);
        recipeImportStatus.textContent = "Could not fetch recipe.";
        recipeImportStatus.classList.add("error");
        recipeImagePreview.style.display = "none";
        lastImportedRecipeMeta = null;
      }
    });
  }

  // ----- MEAL PLAN & SHOPPING -----

  // 1) "Pick week" opens the Monday calendar dialog
  const pickWeekBtn = document.getElementById("mealplan-pick-week");
  if (pickWeekBtn && typeof openMealplanWeekPicker === "function") {
    pickWeekBtn.addEventListener("click", () => {
      openMealplanWeekPicker();
    });
  }

  // 2) "Generate list" (green pill in Meal plan header)
  const generateShoppingFromMealplanBtn =
    document.getElementById("mealplan-generate-list");
  if (generateShoppingFromMealplanBtn) {
    generateShoppingFromMealplanBtn.addEventListener("click", () => {
      generateShoppingList();
      showPage("page-shopping");
    });
  }

  // 3) (Optional) if you STILL have a button with id="generate-shopping-list"
  //    somewhere on the Shopping page itself, keep this too:
  const generateShoppingBtn = document.getElementById("generate-shopping-list");
  if (generateShoppingBtn) {
    generateShoppingBtn.addEventListener("click", () => {
      generateShoppingList();
    });
  }

  // 4) "Clear week" on meal planner
  const mealplanClearBtn = document.getElementById("mealplan-clear-btn");
  if (mealplanClearBtn && typeof clearMealPlanWeek === "function") {
    mealplanClearBtn.addEventListener("click", clearMealPlanWeek);
  }

  // ----- INITIAL RENDERS -----
  renderInventory();
  renderInventoryNameSuggestions();
  renderRecipesList();
  renderMealPlan();
});

</script>
</body>
</html>