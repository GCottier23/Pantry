<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <meta name="color-scheme" content="dark light">
  <title>Pantry App</title>

  <link rel="stylesheet" href="styles.css?v=5" />

  <!-- PWA bits (same as before) -->
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#ff7a00">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <link rel="apple-touch-icon" href="icons/icon-192.png">
</head>
<body>
  <h1>Pantry App v1</h1>

  <!-- NAVIGATION -->
  <nav class="app-nav" role="tablist" aria-label="Pantry navigation">
    <button id="nav-inventory" role="tab" aria-selected="true" aria-controls="page-inventory">Inventory</button>
    <button id="nav-recipes"   role="tab" aria-selected="false" aria-controls="page-recipes">Recipes</button>
    <button id="nav-mealplan"  role="tab" aria-selected="false" aria-controls="page-mealplan">Meal plan</button>
    <button id="nav-shopping"  role="tab" aria-selected="false" aria-controls="page-shopping">Shopping list</button>
  </nav>

  <!-- PAGE 1: INVENTORY -->
  <div id="page-inventory" class="page" role="tabpanel" aria-labelledby="nav-inventory">
    <div class="inventory-controls">
      <label>
        Search inventory
        <input type="text" id="inventory-search" placeholder="Type to filter items..." />
      </label>
    </div>

    <section class="panel">
      <h2>Inventory</h2>

      <!-- Fake barcode scan tools -->
      <div class="barcode-tools">
        <button type="button" id="fake-scan-btn" class="secondary">
          Fake barcode scan
        </button>
      </div>

      <form id="inventory-form">
        <label>
          Item name
          <input type="text" id="inv-name" list="inv-name-list" required />
          <datalist id="inv-name-list"></datalist>
        </label>
        <label>
          Quantity
          <input type="number" id="inv-qty" value="1" min="0" step="0.1" required />
        </label>
        <label>
          Unit
          <select id="inv-unit">
            <option value="">(none)</option>
            <option value="g">g</option>
            <option value="kg">kg</option>
            <option value="ml">ml</option>
            <option value="l">l</option>
            <option value="pack">pack</option>
            <option value="packs">packs</option>
            <option value="pcs">pcs</option>
          </select>
        </label>
        <button type="submit" id="inventory-submit-btn">Add / Update Inventory</button>
        <button type="button" id="inventory-cancel-edit" class="secondary hidden">Cancel Edit</button>
      </form>

      <div id="inventory-list" class="inventory-list"></div>
    </section>
  </div>

  <!-- PAGE 2: RECIPES -->
  <div id="page-recipes" class="page hidden" role="tabpanel" aria-labelledby="nav-recipes">
    <section class="panel">
      <h2>Recipes</h2>

      <form id="recipe-form">
        <label>
          Recipe name
          <input type="text" id="recipe-name" required />
        </label>
        <label>
          Servings (base recipe)
          <input type="number" id="recipe-servings" value="2" min="1" required />
        </label>
        <button type="button" id="start-recipe">Start new recipe</button>
        <button type="button" id="cancel-recipe-edit" class="secondary hidden">Cancel Edit</button>
      </form>

      <div id="recipe-ingredients-section" class="subpanel hidden">
        <h3>Ingredients for current recipe</h3>

        <form id="ingredient-form">
          <label>
            Ingredient name
            <input type="text" id="ing-name" required />
          </label>
          <label>
            Quantity
            <input type="number" id="ing-qty" value="1" min="0" step="0.1" required />
          </label>
          <label>
            Unit
            <input type="text" id="ing-unit" placeholder="g, ml, pcs..." />
          </label>
          <button type="submit" id="ingredient-submit-btn">Add ingredient</button>
          <button type="button" id="cancel-ingredient-edit" class="secondary hidden">
            Cancel Ingredient Edit
          </button>
        </form>

        <ul id="current-recipe-ingredients"></ul>

        <button id="save-recipe">Save recipe</button>

        <div class="subpanel">
          <h3>Quick import from text</h3>
          <p>Paste one ingredient per line, e.g. “500g beef mince” or “4 sticks celery, finely chopped (optional)”.</p>
          <label>
            Ingredients text
            <textarea id="import-text" rows="6" placeholder="Example:
500g beef mince
4 sticks celery, finely chopped (optional)
1 onion, chopped"></textarea>
          </label>
          <button type="button" id="import-ingredients-btn">Import into current recipe</button>
        </div>
      </div>
    </section>

    <section class="panel">
      <h2>Saved recipes</h2>
      <p>Recipes you create here can be used later on the Meal plan page.</p>
      <div id="recipes-list"></div>
    </section>
  </div>

  <!-- PAGE 3: MEAL PLAN -->
  <div id="page-mealplan" class="page hidden" role="tabpanel" aria-labelledby="nav-mealplan">
    <section class="panel">
      <h2>Meal plan</h2>
      <p>Select meals for each day and how many portions you’ll cook.</p>
      <div id="meal-plan-container"></div>
      <button id="generate-shopping-list">Generate Shopping List</button>
    </section>
  </div>

  <!-- PAGE 4: SHOPPING LIST -->
  <div id="page-shopping" class="page hidden" role="tabpanel" aria-labelledby="nav-shopping">
    <section class="panel">
      <h2>Shopping List</h2>
      <p>This list is based on your weekly meal plan and current inventory.</p>
      <table id="shopping-table">
        <thead>
          <tr>
            <th>✓</th>
            <th>Item</th>
            <th>To buy</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </section>
  </div>

  <!-- ================= JS ================= -->
  <script>
    /* ------------ helpers ------------ */
    function titleCase(str) {
      return str
        .toLowerCase()
        .split(" ")
        .filter(Boolean)
        .map(w => w.charAt(0).toUpperCase() + w.slice(1))
        .join(" ");
    }

    function convertToUnit(quantity, fromUnit, toUnit) {
      if (!fromUnit || !toUnit) return quantity;
      if (fromUnit === toUnit) return quantity;
      if (fromUnit === "g" && toUnit === "kg") return quantity / 1000;
      if (fromUnit === "kg" && toUnit === "g") return quantity * 1000;
      if (fromUnit === "ml" && toUnit === "l") return quantity / 1000;
      if (fromUnit === "l" && toUnit === "ml") return quantity * 1000;
      return quantity;
    }

    function normalizeInventoryItem(item) {
      if (item.unit === "g" && item.quantity >= 1000) {
        item.quantity = item.quantity / 1000;
        item.unit = "kg";
      } else if (item.unit === "ml" && item.quantity >= 1000) {
        item.quantity = item.quantity / 1000;
        item.unit = "l";
      }
    }

    function chooseBaseUnit(unit) {
      if (unit === "kg" || unit === "g") return "g";
      if (unit === "l" || unit === "ml") return "ml";
      return unit || "";
    }

    function formatQuantityWithUnit(quantity, unit) {
      if (!unit) return String(quantity);
      const compact = ["g","kg","ml","l"];
      const isCompact = compact.includes(unit);
      const nStr = Number.isInteger(quantity) ? String(quantity) : quantity.toString();
      return isCompact ? nStr + unit : nStr + " " + unit.toLowerCase();
    }

    /* ------------ ingredient parser ------------ */
    function parseIngredientCore(rawText) {
      let line = rawText.trim();
      if (!line) return null;

      const commaIndex = line.indexOf(",");
      if (commaIndex !== -1) line = line.slice(0, commaIndex).trim();
      if (!line) return null;

      const m = line.match(/^(\d+(?:\.\d+)?)([a-zA-Z]+)\/\S+\s+(.+)$/);
      if (m) line = m[1] + " " + m[2] + " " + m[3];

      const parts = line.split(/\s+/);
      if (!parts.length) return null;

      const qty = parseFloat(parts[0]);
      if (isNaN(qty) || qty <= 0) {
        return { name: titleCase(line), quantity: 1, unit: "" };
      }

      const rest = parts.slice(1);
      if (!rest.length) return { name: "", quantity: qty, unit: "" };

      const adjectivesToDrop = [
        "level","heaped","heaping","rounded","about","approx","approximately","roughly"
      ];
      const countUnits = [
        "clove","cloves","stick","sticks","tin","tins","can","cans","slice","slices"
      ];
      const baseUnits = new Set([
        "g","kg","ml","l","tsp","teaspoon","teaspoons","tbsp","tablespoon",
        "tablespoons","cup","cups"
      ]);

      const ofIndex = rest.indexOf("of");
      let unitWords = [];
      let nameWords = [];

      if (ofIndex !== -1) {
        unitWords = rest.slice(0, ofIndex);
        nameWords = rest.slice(ofIndex + 1);
      } else {
        const firstLower = rest[0].toLowerCase();
        if (baseUnits.has(firstLower)) {
          unitWords = [rest[0]];
          nameWords = rest.slice(1);
        } else {
          unitWords = rest.slice(0, Math.min(2, rest.length));
          nameWords = rest.slice(unitWords.length);
        }
      }

      unitWords = unitWords.filter(w => !adjectivesToDrop.includes(w.toLowerCase()));

      if (!nameWords.length) {
        if (unitWords.length === 1) {
          const w = unitWords[0];
          return { name: titleCase(w), quantity: qty, unit: "" };
        } else if (unitWords.length >= 2) {
          const first = unitWords[0];
          const last = unitWords[unitWords.length - 1];

          if (countUnits.includes(first.toLowerCase())) {
            const namePart = unitWords.slice(1).join(" ");
            return { name: titleCase(namePart), quantity: qty, unit: first.toLowerCase() };
          }
          if (countUnits.includes(last.toLowerCase())) {
            const namePart = unitWords.slice(0, -1).join(" ");
            return { name: titleCase(namePart), quantity: qty, unit: last.toLowerCase() };
          }
          return { name: titleCase(unitWords.join(" ")), quantity: qty, unit: "" };
        }
      }

      let unit = "";
      if (unitWords.length) {
        const rawUnit = unitWords[unitWords.length - 1].toLowerCase();
        const unitMap = {
          tablespoon: "tbsp", tablespoons: "tbsp", tbsp: "tbsp",
          teaspoon: "tsp", teaspoons: "tsp", tsp: "tsp",
          gram: "g", grams: "g", g: "g", kg: "kg",
          millilitre: "ml", millilitres: "ml", ml: "ml",
          litre: "l", litres: "l", l: "l",
          stick: "stick", sticks: "sticks",
          clove: "clove", cloves: "cloves",
          cup: "cup", cups: "cups"
        };
        unit = unitMap[rawUnit] || rawUnit;
      }

      const name = titleCase(nameWords.join(" "));
      return { name, quantity: qty, unit };
    }

    /* ------------ state ------------ */
    let inventory = [];
    let recipes = [];
    let currentRecipe = null;
    let inventoryFilter = "";
    let editingInventoryKey = null;
    let editingRecipeId = null;
    let editingIngredientIndex = null;
    let mealPlan = [];

    // barcode templates and index
    // barcodeItems: key = nameKey, value = { name, baseQuantity, unit }
    let barcodeItems = {};
    // barcodeIndex: key = barcode string, value = array of nameKeys
    let barcodeIndex = {};

    const STORAGE_KEY = "pantryAppState_v1";

    function initDefaultMealPlan() {
      const days = ["Monday","Tuesday","Wednesday","Thursday","Friday","Saturday","Sunday"];
      mealPlan = days.map(day => ({
        dayId: day.toLowerCase(),
        dayLabel: day,
        recipeId: "",
        servings: 0
      }));
    }

    function saveAppState() {
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify({
          inventory,
          recipes,
          mealPlan,
          barcodeItems,
          barcodeIndex
        }));
      } catch (e) {
        console.error("Failed to save", e);
      }
    }

    function loadAppState() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) {
          initDefaultMealPlan();
          barcodeItems = {};
          barcodeIndex = {};
          return;
        }
        const data = JSON.parse(raw);
        if (Array.isArray(data.inventory)) inventory = data.inventory;
        if (Array.isArray(data.recipes)) recipes = data.recipes;
        if (Array.isArray(data.mealPlan)) mealPlan = data.mealPlan; else initDefaultMealPlan();
        barcodeItems = data.barcodeItems || {};
        barcodeIndex = data.barcodeIndex || {};
      } catch {
        initDefaultMealPlan();
        barcodeItems = {};
        barcodeIndex = {};
      }
      if (!mealPlan || !mealPlan.length) initDefaultMealPlan();
    }

    /* ------------ inventory ------------ */
    function upsertInventoryItem(name, quantity, unit) {
      const cleanName = titleCase(name.trim());
      const key = cleanName.toLowerCase();
      let item = inventory.find(i => i.key === key);

      if (!item) {
        item = { key, name: cleanName, quantity, unit };
        normalizeInventoryItem(item);
        inventory.push(item);
        return;
      }

      const baseUnit = item.unit || unit;
      const converted = convertToUnit(quantity, unit, baseUnit);
      if (!item.unit && unit) item.unit = unit;
      item.quantity += converted;
      normalizeInventoryItem(item);
    }

    function setInventoryItemExact(originalKey, name, quantity, unit) {
      const cleanName = titleCase(name.trim());
      const newKey = cleanName.toLowerCase();
      let item = inventory.find(i => i.key === originalKey);

      if (!item) {
        item = { key: newKey, name: cleanName, quantity, unit };
        normalizeInventoryItem(item);
        inventory.push(item);
      } else {
        item.name = cleanName;
        item.key = newKey;
        item.quantity = quantity;
        item.unit = unit;
        normalizeInventoryItem(item);
      }
    }

    function deleteInventoryItem(key) {
      inventory = inventory.filter(i => i.key !== key);
    }

    function renderInventoryNameSuggestions() {
      const datalist = document.getElementById("inv-name-list");
      if (!datalist) return;
      datalist.innerHTML = "";
      inventory
        .slice()
        .sort((a,b) => a.name.localeCompare(b.name))
        .forEach(item => {
          const opt = document.createElement("option");
          opt.value = item.name;
          datalist.appendChild(opt);
        });
    }

    function renderInventory() {
      const container = document.getElementById("inventory-list");
      if (!container) return;
      container.innerHTML = "";

      const filter = inventoryFilter.toLowerCase();

      inventory
        .slice()
        .sort((a,b) => a.name.localeCompare(b.name))
        .forEach(item => {
          if (filter && !item.name.toLowerCase().includes(filter)) return;

          const row = document.createElement("div");
          row.className = "inventory-item";

          const text = document.createElement("span");
          text.className = "inventory-item-text";
          text.textContent =
            item.name + " - " + formatQuantityWithUnit(item.quantity, item.unit || "");
          row.appendChild(text);

          const actions = document.createElement("div");
          actions.className = "inventory-actions";

          const editBtn = document.createElement("button");
          editBtn.type = "button";
          editBtn.textContent = "Edit";
          editBtn.addEventListener("click", function () {
            startInventoryEdit(item.key);
          });

          const delBtn = document.createElement("button");
          delBtn.type = "button";
          delBtn.textContent = "Delete";
          delBtn.addEventListener("click", function () {
            if (confirm("Delete " + item.name + " from inventory?")) {
              deleteInventoryItem(item.key);
              if (editingInventoryKey === item.key) clearInventoryEditState();
              renderInventory();
              renderInventoryNameSuggestions();
              saveAppState();
            }
          });

          actions.appendChild(editBtn);
          actions.appendChild(delBtn);
          row.appendChild(actions);

          container.appendChild(row);
        });
    }

    function startInventoryEdit(key) {
      const item = inventory.find(i => i.key === key);
      if (!item) return;

      document.getElementById("inv-name").value = item.name;
      document.getElementById("inv-qty").value = item.quantity;
      document.getElementById("inv-unit").value = item.unit || "";

      document.getElementById("inventory-submit-btn").textContent = "Save Changes";
      document.getElementById("inventory-cancel-edit").classList.remove("hidden");
      editingInventoryKey = key;
    }

    function clearInventoryEditState() {
      document.getElementById("inv-name").value = "";
      document.getElementById("inv-qty").value = "1";
      document.getElementById("inv-unit").value = "";
      document.getElementById("inventory-submit-btn").textContent = "Add / Update Inventory";
      document.getElementById("inventory-cancel-edit").classList.add("hidden");
      editingInventoryKey = null;
    }

    /* ------------ recipes & ingredients ------------ */
    function renderCurrentRecipeIngredients() {
      const ul = document.getElementById("current-recipe-ingredients");
      if (!ul) return;
      ul.innerHTML = "";

      if (!currentRecipe || !Array.isArray(currentRecipe.ingredients)) return;

      currentRecipe.ingredients.forEach(function (ing, index) {
        const li = document.createElement("li");

        const textSpan = document.createElement("span");
        textSpan.textContent = ing.name + ": " + ing.quantity + " " + ing.unit;
        li.appendChild(textSpan);

        const actionsDiv = document.createElement("div");
        actionsDiv.className = "table-actions";

        const editBtn = document.createElement("button");
        editBtn.type = "button";
        editBtn.className = "secondary";
        editBtn.textContent = "Edit";
        editBtn.addEventListener("click", function () {
          startIngredientEdit(index);
        });

        const delBtn = document.createElement("button");
        delBtn.type = "button";
        delBtn.className = "secondary";
        delBtn.textContent = "Delete";
        delBtn.addEventListener("click", function () {
          currentRecipe.ingredients.splice(index, 1);
          renderCurrentRecipeIngredients();
        });

        actionsDiv.appendChild(editBtn);
        actionsDiv.appendChild(delBtn);
        li.appendChild(actionsDiv);
        ul.appendChild(li);
      });
    }

    function startIngredientEdit(index) {
      if (!currentRecipe || !currentRecipe.ingredients[index]) return;

      const ing = currentRecipe.ingredients[index];
      document.getElementById("ing-name").value = ing.name;
      document.getElementById("ing-qty").value = ing.quantity;
      document.getElementById("ing-unit").value = ing.unit;

      document.getElementById("ingredient-submit-btn").textContent = "Save ingredient";
      document.getElementById("cancel-ingredient-edit").classList.remove("hidden");
      editingIngredientIndex = index;
    }

    function clearIngredientEditState() {
      document.getElementById("ing-name").value = "";
      document.getElementById("ing-qty").value = "1";
      document.getElementById("ing-unit").value = "";
      document.getElementById("ingredient-submit-btn").textContent = "Add ingredient";
      document.getElementById("cancel-ingredient-edit").classList.add("hidden");
      editingIngredientIndex = null;
    }

    function renderRecipesList() {
      const container = document.getElementById("recipes-list");
      if (!container) return;
      container.innerHTML = "";

      if (!recipes.length) {
        container.textContent = "No recipes saved yet.";
        return;
      }

      recipes.forEach(function (recipe) {
        const wrapper = document.createElement("div");
        wrapper.className = "subpanel";

        const titleRow = document.createElement("div");
        titleRow.style.display = "flex";
        titleRow.style.justifyContent = "space-between";
        titleRow.style.alignItems = "center";

        const title = document.createElement("h3");
        title.textContent = recipe.name + " (serves " + recipe.servings + ")";

        const actionsDiv = document.createElement("div");
        actionsDiv.className = "table-actions";

        const editBtn = document.createElement("button");
        editBtn.type = "button";
        editBtn.className = "secondary";
        editBtn.textContent = "Edit";
        editBtn.addEventListener("click", function () {
          startRecipeEdit(recipe.id);
        });

        const delBtn = document.createElement("button");
        delBtn.type = "button";
        delBtn.className = "secondary";
        delBtn.textContent = "Delete";
        delBtn.addEventListener("click", function () {
          if (confirm('Delete recipe "' + recipe.name + '"?')) {
            deleteRecipe(recipe.id);
            mealPlan.forEach(function (entry) {
              if (entry.recipeId === recipe.id) {
                entry.recipeId = "";
                entry.servings = 0;
              }
            });
            renderRecipesList();
            renderMealPlan();
            saveAppState();
          }
        });

        actionsDiv.appendChild(editBtn);
        actionsDiv.appendChild(delBtn);

        titleRow.appendChild(title);
        titleRow.appendChild(actionsDiv);
        wrapper.appendChild(titleRow);

        const ul = document.createElement("ul");
        recipe.ingredients.forEach(function (ing) {
          const li = document.createElement("li");
          li.textContent = ing.name + ": " + ing.quantity + " " + ing.unit;
          ul.appendChild(li);
        });
        wrapper.appendChild(ul);

        container.appendChild(wrapper);
      });

      renderMealPlan();
    }

    function deleteRecipe(id) {
      recipes = recipes.filter(function (r) { return r.id !== id; });
      if (editingRecipeId === id) clearRecipeEditState();
    }

    function startRecipeEdit(id) {
      const recipe = recipes.find(function (r) { return r.id === id; });
      if (!recipe) return;

      editingRecipeId = id;
      currentRecipe = {
        id: recipe.id,
        name: recipe.name,
        servings: recipe.servings,
        ingredients: recipe.ingredients.map(function (ing) {
          return { name: ing.name, quantity: ing.quantity, unit: ing.unit };
        })
      };

      document.getElementById("recipe-name").value = currentRecipe.name;
      document.getElementById("recipe-servings").value = currentRecipe.servings;

      document.getElementById("recipe-ingredients-section").classList.remove("hidden");
      document.getElementById("cancel-recipe-edit").classList.remove("hidden");

      renderCurrentRecipeIngredients();
      clearIngredientEditState();
    }

    function clearRecipeEditState() {
      editingRecipeId = null;
      currentRecipe = null;

      document.getElementById("recipe-name").value = "";
      document.getElementById("recipe-servings").value = "2";

      document.getElementById("current-recipe-ingredients").innerHTML = "";
      document.getElementById("recipe-ingredients-section").classList.add("hidden");
      document.getElementById("cancel-recipe-edit").classList.add("hidden");

      clearIngredientEditState();
    }

    /* ------------ meal plan ------------ */
    function initDefaultMealPlanIfNeeded() {
      if (!mealPlan || !mealPlan.length) initDefaultMealPlan();
    }

    function renderMealPlan() {
      const container = document.getElementById("meal-plan-container");
      if (!container) return;
      container.innerHTML = "";

      initDefaultMealPlanIfNeeded();

      const validIds = new Set(recipes.map(function (r) { return r.id; }));
      mealPlan.forEach(function (entry) {
        if (entry.recipeId && !validIds.has(entry.recipeId)) {
          entry.recipeId = "";
          entry.servings = 0;
        }
      });

      mealPlan.forEach(function (entry) {
        const row = document.createElement("div");
        row.className = "subpanel";

        const label = document.createElement("h3");
        label.textContent = entry.dayLabel;
        row.appendChild(label);

        const recipeLabel = document.createElement("label");
        recipeLabel.textContent = "Recipe";

        const select = document.createElement("select");
        select.dataset.dayId = entry.dayId;

        const defaultOpt = document.createElement("option");
        defaultOpt.value = "";
        defaultOpt.textContent = "(no meal selected)";
        select.appendChild(defaultOpt);

        recipes
          .slice()
          .sort(function (a, b) { return a.name.localeCompare(b.name); })
          .forEach(function (recipe) {
            const opt = document.createElement("option");
            opt.value = recipe.id;
            opt.textContent = recipe.name + " (serves " + recipe.servings + ")";
            select.appendChild(opt);
          });

        select.value = entry.recipeId || "";

        select.addEventListener("change", function (e) {
          const id = e.target.dataset.dayId;
          const planEntry = mealPlan.find(function (p) { return p.dayId === id; });
          if (!planEntry) return;
          planEntry.recipeId = e.target.value;
          if (!planEntry.recipeId) {
            planEntry.servings = 0;
            const sInput = document.querySelector('input[data-day-id="' + id + '"]');
            if (sInput) sInput.value = "0";
          }
          saveAppState();
        });

        recipeLabel.appendChild(select);
        row.appendChild(recipeLabel);

        const servingsLabel = document.createElement("label");
        servingsLabel.textContent = "Planned servings";

        const servingsInput = document.createElement("input");
        servingsInput.type = "number";
        servingsInput.min = "0";
        servingsInput.step = "1";
        servingsInput.dataset.dayId = entry.dayId;
        servingsInput.value = entry.servings && entry.servings > 0 ? entry.servings : "0";

        servingsInput.addEventListener("change", function (e) {
          const id = e.target.dataset.dayId;
          const planEntry = mealPlan.find(function (p) { return p.dayId === id; });
          if (!planEntry) return;
          var val = parseFloat(e.target.value || "0");
          if (isNaN(val) || val < 0) val = 0;
          planEntry.servings = val;
          e.target.value = val === 0 ? "0" : String(val);
          saveAppState();
        });

        servingsLabel.appendChild(servingsInput);
        row.appendChild(servingsLabel);

        container.appendChild(row);
      });
    }

    /* ------------ shopping list ------------ */
    function generateShoppingList() {
      const required = {};

      mealPlan.forEach(function (entry) {
        if (!entry.recipeId) return;
        const plannedServings = parseFloat(entry.servings || "0");
        if (plannedServings <= 0) return;

        const recipe = recipes.find(function (r) { return r.id === entry.recipeId; });
        if (!recipe) return;

        const scale = plannedServings / recipe.servings;

        recipe.ingredients.forEach(function (ing) {
          const key = ing.name.toLowerCase();
          const ingUnit = ing.unit || "";
          const baseUnit = required[key]
            ? required[key].baseUnit
            : chooseBaseUnit(ingUnit);

          if (!required[key]) {
            required[key] = {
              name: ing.name,
              quantityBase: 0,
              baseUnit: baseUnit
            };
          }

          const qtyScaled = ing.quantity * scale;
          const qtyInBase = convertToUnit(qtyScaled, ingUnit, required[key].baseUnit);
          required[key].quantityBase += qtyInBase;
        });
      });

      const tbody = document.querySelector("#shopping-table tbody");
      if (!tbody) return;
      tbody.innerHTML = "";

      Object.keys(required).forEach(function (key) {
        const need = required[key];
        const baseUnit = need.baseUnit;
        let requiredBase = need.quantityBase;

        let invQtyBase = 0;
        const invItem = inventory.find(function (i) { return i.name.toLowerCase() === key; });
        if (invItem && baseUnit) {
          invQtyBase = convertToUnit(invItem.quantity, invItem.unit || "", baseUnit);
        } else if (invItem && !baseUnit) {
          invQtyBase = invItem.quantity;
        }

        let toBuyBase = Math.max(0, requiredBase - invQtyBase);
        if (toBuyBase <= 1e-9) return;

        let displayUnit = baseUnit;
        if (baseUnit === "g" && (requiredBase >= 1000 || invQtyBase >= 1000 || toBuyBase >= 1000)) {
          displayUnit = "kg";
        } else if (baseUnit === "ml" && (requiredBase >= 1000 || invQtyBase >= 1000 || toBuyBase >= 1000)) {
          displayUnit = "l";
        }

        let displayQtyNumeric;
        if (displayUnit) {
          displayQtyNumeric = convertToUnit(toBuyBase, baseUnit, displayUnit);
        } else {
          displayQtyNumeric = toBuyBase;
        }
        displayQtyNumeric = Math.round(displayQtyNumeric * 100) / 100;

        const compactUnits = ["g","kg","ml","l"];
        const isCompact = displayUnit && compactUnits.includes(displayUnit);

        let qtyStr;
        if (!displayUnit) {
          qtyStr = displayQtyNumeric.toString();
        } else if (isCompact) {
          const nStr = Number.isInteger(displayQtyNumeric)
            ? String(displayQtyNumeric)
            : displayQtyNumeric.toFixed(2);
          qtyStr = nStr + displayUnit;
        } else {
          const nStr = Number.isInteger(displayQtyNumeric)
            ? String(displayQtyNumeric)
            : displayQtyNumeric.toFixed(2);
          qtyStr = nStr + " " + displayUnit.toLowerCase();
        }

        const tr = document.createElement("tr");
        tr.dataset.itemName = need.name;
        tr.dataset.buyQty = String(displayQtyNumeric);
        tr.dataset.buyUnit = displayUnit || "";

        const tdCheck = document.createElement("td");
        const cb = document.createElement("input");
        cb.type = "checkbox";
        cb.className = "shopping-bought";
        tdCheck.appendChild(cb);

        const tdName = document.createElement("td");
        tdName.textContent = need.name;

        const tdBuy = document.createElement("td");
        tdBuy.textContent = qtyStr;

        tr.appendChild(tdCheck);
        tr.appendChild(tdName);
        tr.appendChild(tdBuy);
        tbody.appendChild(tr);
      });

      const checkboxes = tbody.querySelectorAll(".shopping-bought");
      checkboxes.forEach(function (cb) {
        cb.addEventListener("change", function () {
          const tr = cb.closest("tr");
          if (!tr) return;
          if (!cb.checked || tr.dataset.applied === "true") return;

          const name = tr.dataset.itemName;
          const qty = parseFloat(tr.dataset.buyQty || "0");
          const unit = tr.dataset.buyUnit || "";
          if (!name || !qty || qty <= 0) return;

          upsertInventoryItem(name, qty, unit);
          tr.dataset.applied = "true";

          renderInventory();
          renderInventoryNameSuggestions();
          saveAppState();
        });
      });
    }

    /* ------------ fake barcode scan logic ------------ */

    function ensureBarcodeArray(barcode) {
      if (!barcodeIndex[barcode]) barcodeIndex[barcode] = [];
      return barcodeIndex[barcode];
    }

    function handleExistingBarcode(barcode, mappings) {
      if (!mappings.length) return false;

      // single mapping
      if (mappings.length === 1) {
        var nameKey = mappings[0];
        var tpl = barcodeItems[nameKey];
        if (!tpl) return false;

        var confirmMsg =
          "This barcode is currently linked to:\n\n" +
          tpl.name +
          (tpl.baseQuantity ? " (typical amount: " + tpl.baseQuantity + (tpl.unit || "") + ")" : "") +
          "\n\nIs that correct?";

        var isCorrect = confirm(confirmMsg);
        if (!isCorrect) {
          // treat as new item for this barcode
          return false;
        }

        var unit = tpl.unit || "";
        var defaultVal = (tpl.baseQuantity && tpl.baseQuantity > 0)
          ? String(tpl.baseQuantity)
          : "1";
        var unitText = unit ? " in " + unit : "";
        var qtyMsg =
          tpl.name + " already in list - how much did you buy?" +
          "\n\n" +
          (tpl.baseQuantity
            ? "Typical amount: " + tpl.baseQuantity + (unit || "") + ".\n"
            : "") +
          "Enter the total amount" + unitText + ":";

        var qtyStr = prompt(qtyMsg, defaultVal);
        if (!qtyStr) return true;
        var qty = parseFloat(qtyStr);
        if (isNaN(qty) || qty <= 0) return true;

        upsertInventoryItem(tpl.name, qty, unit);
        renderInventory();
        renderInventoryNameSuggestions();
        saveAppState();
        alert("Added " + formatQuantityWithUnit(qty, unit) + " of " + tpl.name + " to inventory.");
        return true;
      }

      // multiple mappings – user chooses which item, or 0 for new
      var msg = "This barcode is linked to multiple items:\n\n";
      mappings.forEach(function (nameKey, idx) {
        var tpl2 = barcodeItems[nameKey];
        if (!tpl2) return;
        msg +=
          (idx + 1) + ". " + tpl2.name +
          (tpl2.baseQuantity ? " (" + tpl2.baseQuantity + (tpl2.unit || "") + " typical)" : "") +
          "\n";
      });
      msg += "\nEnter the number of the correct item,\n" +
             "or 0 if it's a different item:";

      var choiceStr = prompt(msg, "");
      if (!choiceStr) return false;
      var choice = parseInt(choiceStr, 10);
      if (isNaN(choice) || choice < 1 || choice > mappings.length) {
        // user chose 0 or invalid → treat as new item
        return false;
      }

      var pickedNameKey = mappings[choice - 1];
      var tpl3 = barcodeItems[pickedNameKey];
      if (!tpl3) return true;

      var unit3 = tpl3.unit || "";
      var defaultVal3 = (tpl3.baseQuantity && tpl3.baseQuantity > 0)
        ? String(tpl3.baseQuantity)
        : "1";
      var unitText3 = unit3 ? " in " + unit3 : "";
      var qtyMsg3 =
        tpl3.name + " already in list - how much did you buy?" +
        "\n\n" +
        (tpl3.baseQuantity
          ? "Typical amount: " + tpl3.baseQuantity + (unit3 || "") + ".\n"
          : "") +
        "Enter the total amount" + unitText3 + ":";

      var qtyStr3 = prompt(qtyMsg3, defaultVal3);
      if (!qtyStr3) return true;
      var qty3 = parseFloat(qtyStr3);
      if (isNaN(qty3) || qty3 <= 0) return true;

      upsertInventoryItem(tpl3.name, qty3, unit3);
      renderInventory();
      renderInventoryNameSuggestions();
      saveAppState();
      alert("Added " + formatQuantityWithUnit(qty3, unit3) + " of " + tpl3.name + " to inventory.");
      return true;
    }

    function handleNewBarcodeOrNewItem(barcode) {
      var name = prompt("What is this item called?", "");
      if (!name) {
        alert("Cancelled.");
        return;
      }
      var cleanName = titleCase(name.trim());
      var nameKey = cleanName.toLowerCase();

      var existingTpl = barcodeItems[nameKey];

      // barcode for an item we already know (e.g. Beef Mince from before)
      if (existingTpl) {
        var arr = ensureBarcodeArray(barcode);
        if (arr.indexOf(nameKey) === -1) arr.push(nameKey);

        var unit = existingTpl.unit || "";
        var defaultVal = (existingTpl.baseQuantity && existingTpl.baseQuantity > 0)
          ? String(existingTpl.baseQuantity)
          : "1";
        var unitText = unit ? " in " + unit : "";
        var msg =
          cleanName + " is already defined in your pantry.\n" +
          (existingTpl.baseQuantity
            ? "Typical amount: " + existingTpl.baseQuantity + (unit || "") + ".\n"
            : "") +
          "How much did you buy" + unitText + "?";

        var qtyStr = prompt(msg, defaultVal);
        if (!qtyStr) {
          saveAppState();
          return;
        }
        var qty = parseFloat(qtyStr);
        if (isNaN(qty) || qty <= 0) {
          saveAppState();
          return;
        }

        upsertInventoryItem(cleanName, qty, unit);
        renderInventory();
        renderInventoryNameSuggestions();
        saveAppState();
        alert("Added " + formatQuantityWithUnit(qty, unit) + " of " + cleanName + " to inventory.");
        return;
      }

      // brand new item template
      var qtyStr2 = prompt(
        'For one typical amount of "' + cleanName + '", what is the quantity?\n' +
        'Example: for a 500g pack, enter 500.',
        "500"
      );
      if (!qtyStr2) {
        alert("Cancelled.");
        return;
      }
      var baseQty = parseFloat(qtyStr2);
      if (isNaN(baseQty) || baseQty <= 0) {
        alert("Invalid quantity. Cancelled.");
        return;
      }

      var unitStr = prompt(
        "What is the unit for this quantity?\n" +
        "Examples: g, kg, ml, l, pack, packs, pcs",
        "g"
      );
      var unit2 = (unitStr || "").trim();

      barcodeItems[nameKey] = {
        name: cleanName,
        baseQuantity: baseQty,
        unit: unit2
      };

      var arr2 = ensureBarcodeArray(barcode);
      if (arr2.indexOf(nameKey) === -1) arr2.push(nameKey);

      var unitText2 = unit2 ? " in " + unit2 : "";
      var msgNow =
        "Saved " + cleanName + " as a typical amount of " + baseQty + (unit2 || "") + ".\n\n" +
        "How much did you buy right now" + unitText2 + "?\n" +
        "Example: if you bought one pack, enter " + baseQty + ".";

      var qtyNowStr = prompt(msgNow, String(baseQty));
      if (!qtyNowStr) {
        saveAppState();
        return;
      }
      var qtyNow = parseFloat(qtyNowStr);
      if (isNaN(qtyNow) || qtyNow <= 0) {
        saveAppState();
        return;
      }

      upsertInventoryItem(cleanName, qtyNow, unit2);
      renderInventory();
      renderInventoryNameSuggestions();
      saveAppState();
      alert("Added " + formatQuantityWithUnit(qtyNow, unit2) + " of " + cleanName + " to inventory.");
    }

    function fakeBarcodeScanFlow() {
      var code = prompt("Fake barcode scan: enter a barcode number or code.", "");
      if (!code) return;
      code = String(code).trim();
      if (!code) return;

      var mappings = barcodeIndex[code] || [];

      // if we have mappings, try to handle them first
      if (mappings.length) {
        var handled = handleExistingBarcode(code, mappings);
        if (handled) return;
        // otherwise fall through to "new item" flow
      }

      handleNewBarcodeOrNewItem(code);
    }

    /* ------------ navigation ------------ */
    function showPage(pageId) {
      var pages = [
        document.getElementById("page-inventory"),
        document.getElementById("page-recipes"),
        document.getElementById("page-mealplan"),
        document.getElementById("page-shopping")
      ];
      var navButtons = [
        document.getElementById("nav-inventory"),
        document.getElementById("nav-recipes"),
        document.getElementById("nav-mealplan"),
        document.getElementById("nav-shopping")
      ];

      pages.forEach(function (page) {
        if (!page) return;
        page.classList.toggle("hidden", page.id !== pageId);
      });

      navButtons.forEach(function (btn) {
        if (!btn) return;
        var controls = btn.getAttribute("aria-controls");
        btn.setAttribute("aria-selected", controls === pageId ? "true" : "false");
      });

      var page = document.getElementById(pageId);
      if (page) {
        var h2 = page.querySelector("h2");
        if (h2) {
          h2.setAttribute("tabindex", "-1");
          h2.focus();
        }
      }
    }

    /* ------------ DOMContentLoaded ------------ */
    document.addEventListener("DOMContentLoaded", function () {
      loadAppState();

      document.getElementById("nav-inventory").addEventListener("click", function () {
        showPage("page-inventory");
      });
      document.getElementById("nav-recipes").addEventListener("click", function () {
        showPage("page-recipes");
      });
      document.getElementById("nav-mealplan").addEventListener("click", function () {
        showPage("page-mealplan");
      });
      document.getElementById("nav-shopping").addEventListener("click", function () {
        showPage("page-shopping");
      });
      showPage("page-inventory");

      var invForm = document.getElementById("inventory-form");
      var searchInput = document.getElementById("inventory-search");
      var cancelInvEditBtn = document.getElementById("inventory-cancel-edit");
      var fakeScanBtn = document.getElementById("fake-scan-btn");

      invForm.addEventListener("submit", function (e) {
        e.preventDefault();

        var name = document.getElementById("inv-name").value.trim();
        var qty = parseFloat(document.getElementById("inv-qty").value || "0");
        var unit = (document.getElementById("inv-unit").value || "").trim();

        if (!name || qty <= 0) {
          alert("Please enter a valid name and quantity.");
          return;
        }

        if (editingInventoryKey) {
          setInventoryItemExact(editingInventoryKey, name, qty, unit);
          clearInventoryEditState();
        } else {
          upsertInventoryItem(name, qty, unit);
          document.getElementById("inv-name").value = "";
          document.getElementById("inv-qty").value = "1";
          document.getElementById("inv-unit").value = "";
        }

        renderInventory();
        renderInventoryNameSuggestions();
        saveAppState();
      });

      cancelInvEditBtn.addEventListener("click", function () {
        clearInventoryEditState();
      });

      searchInput.addEventListener("input", function () {
        inventoryFilter = searchInput.value || "";
        renderInventory();
      });

      fakeScanBtn.addEventListener("click", function () {
        fakeBarcodeScanFlow();
      });

      /* recipes: start recipe, ingredient add/import, save, etc. */
      var startRecipeBtn = document.getElementById("start-recipe");
      var ingSection = document.getElementById("recipe-ingredients-section");
      var cancelRecipeEditBtn = document.getElementById("cancel-recipe-edit");
      var importBtn = document.getElementById("import-ingredients-btn");

      startRecipeBtn.addEventListener("click", function () {
        var name = document.getElementById("recipe-name").value.trim();
        var servings = parseFloat(document.getElementById("recipe-servings").value || "0");

        if (!name || servings <= 0) {
          alert("Please enter a recipe name and servings.");
          return;
        }

        if (!currentRecipe || !editingRecipeId) {
          currentRecipe = {
            id: editingRecipeId || String(Date.now()),
            name: titleCase(name),
            servings: servings,
            ingredients: []
          };
        } else {
          currentRecipe.name = titleCase(name);
          currentRecipe.servings = servings;
        }

        ingSection.classList.remove("hidden");
        renderCurrentRecipeIngredients();
        if (editingRecipeId) {
          cancelRecipeEditBtn.classList.remove("hidden");
        } else {
          cancelRecipeEditBtn.classList.add("hidden");
        }
        clearIngredientEditState();
      });

      cancelRecipeEditBtn.addEventListener("click", function () {
        clearRecipeEditState();
      });

      var ingForm = document.getElementById("ingredient-form");
      ingForm.addEventListener("submit", function (e) {
        e.preventDefault();
        if (!currentRecipe) {
          alert("Start a recipe first.");
          return;
        }

        var name = document.getElementById("ing-name").value.trim();
        var qty = parseFloat(document.getElementById("ing-qty").value || "0");
        var unit = document.getElementById("ing-unit").value.trim();

        if (!name || qty <= 0) {
          alert("Please enter a valid ingredient name and quantity.");
          return;
        }

        var cleanName = titleCase(name);

        if (editingIngredientIndex !== null) {
          currentRecipe.ingredients[editingIngredientIndex] = {
            name: cleanName,
            quantity: qty,
            unit: unit
          };
          clearIngredientEditState();
        } else {
          currentRecipe.ingredients.push({
            name: cleanName,
            quantity: qty,
            unit: unit
          });
        }

        renderCurrentRecipeIngredients();
      });

      document.getElementById("cancel-ingredient-edit").addEventListener("click", function () {
        clearIngredientEditState();
      });

      importBtn.addEventListener("click", function () {
        if (!currentRecipe) {
          alert("Start a recipe first (enter name + servings, then click 'Start new recipe').");
          return;
        }

        var textarea = document.getElementById("import-text");
        var raw = textarea.value || "";
        var lines = raw.split(/\r?\n/);

        var requiredIngredients = [];
        var optionalGroups = [];
        var skipped = 0;

        lines.forEach(function (lineRaw) {
          var originalLine = lineRaw.trim();
          if (!originalLine) { skipped++; return; }

          var isOptional = /\boptional\b/i.test(originalLine);
          var working = originalLine.replace(/\([^)]*\)/g, "").trim();
          if (!working) { skipped++; return; }

          if (isOptional && /\s+or\s+/i.test(working)) {
            var parts = working.split(/\s+or\s+/i);
            var options = [];
            parts.forEach(function (p) {
              var parsed = parseIngredientCore(p.trim());
              if (parsed && parsed.name && parsed.quantity > 0) options.push(parsed);
            });
            if (options.length > 0) optionalGroups.push({ originalLine: originalLine, options: options });
            else skipped++;
          } else {
            var parsed2 = parseIngredientCore(working);
            if (!parsed2 || !parsed2.name || parsed2.quantity <= 0) { skipped++; return; }
            if (isOptional) optionalGroups.push({ originalLine: originalLine, options: [parsed2] });
            else requiredIngredients.push(parsed2);
          }
        });

        requiredIngredients.forEach(function (ing) {
          currentRecipe.ingredients.push(ing);
        });

        if (!optionalGroups.length) {
          renderCurrentRecipeIngredients();
          if (requiredIngredients.length || skipped) {
            alert(requiredIngredients.length + " ingredient(s) imported, " + skipped + " line(s) skipped or empty.");
          } else {
            alert("No valid ingredients found to import.");
          }
          if (requiredIngredients.length) textarea.value = "";
          return;
        }

        var overlay = document.createElement("div");
        overlay.className = "optional-overlay";

        var modal = document.createElement("div");
        modal.className = "optional-modal";

        var heading = document.createElement("h3");
        heading.textContent = "Optional ingredients";
        modal.appendChild(heading);

        var desc = document.createElement("p");
        desc.textContent = 'Tick any optional ingredients you want to include, then press "Add selected".';
        modal.appendChild(desc);

        var form = document.createElement("form");
        form.addEventListener("submit", function (e) { e.preventDefault(); });

        optionalGroups.forEach(function (group, gIndex) {
          var fs = document.createElement("fieldset");

          var legend = document.createElement("legend");
          legend.textContent = 'From: "' + group.originalLine + '"';
          fs.appendChild(legend);

          group.options.forEach(function (opt, oIndex) {
            var lbl = document.createElement("label");
            var cb = document.createElement("input");
            cb.type = "checkbox";
            cb.dataset.groupIndex = String(gIndex);
            cb.dataset.optionIndex = String(oIndex);

            var text = document.createTextNode(" " + opt.name + ": " + opt.quantity + " " + opt.unit);

            lbl.appendChild(cb);
            lbl.appendChild(text);
            fs.appendChild(lbl);
          });

          form.appendChild(fs);
        });

        var buttonsDiv = document.createElement("div");
        buttonsDiv.className = "optional-buttons";

        var cancelBtn = document.createElement("button");
        cancelBtn.type = "button";
        cancelBtn.className = "secondary";
        cancelBtn.textContent = "Skip all optional";
        cancelBtn.addEventListener("click", function () {
          document.body.removeChild(overlay);
          renderCurrentRecipeIngredients();
          var baseMsg = requiredIngredients.length + " required ingredient(s) imported.";
          var skipMsg = optionalGroups.length ? " " + optionalGroups.length + " optional group(s) skipped." : "";
          var skipLinesMsg = skipped ? " " + skipped + " line(s) skipped or empty." : "";
          alert(baseMsg + skipMsg + skipLinesMsg);
          if (requiredIngredients.length) textarea.value = "";
        });

        var addBtn = document.createElement("button");
        addBtn.type = "button";
        addBtn.textContent = "Add selected";
        addBtn.addEventListener("click", function () {
          var checkboxes = form.querySelectorAll('input[type="checkbox"][data-group-index]');
          var addedOptional = 0;
          checkboxes.forEach(function (cb) {
            if (cb.checked) {
              var g = parseInt(cb.dataset.groupIndex, 10);
              var o = parseInt(cb.dataset.optionIndex, 10);
              var opt = optionalGroups[g] && optionalGroups[g].options[o];
              if (opt) {
                currentRecipe.ingredients.push({
                  name: opt.name,
                  quantity: opt.quantity,
                  unit: opt.unit
                });
                addedOptional++;
              }
            }
          });

          document.body.removeChild(overlay);
          renderCurrentRecipeIngredients();

          var msg = requiredIngredients.length + " required ingredient(s) imported.";
          msg += " " + addedOptional + " optional ingredient(s) added.";
          if (skipped) msg += " " + skipped + " line(s) skipped or empty.";
          alert(msg);

          if (requiredIngredients.length || addedOptional) textarea.value = "";
        });

        buttonsDiv.appendChild(cancelBtn);
        buttonsDiv.appendChild(addBtn);
        form.appendChild(buttonsDiv);
        modal.appendChild(form);
        overlay.appendChild(modal);
        document.body.appendChild(overlay);
      });

      document.getElementById("save-recipe").addEventListener("click", function () {
        if (!currentRecipe) {
          alert("No recipe in progress.");
          return;
        }
        if (!currentRecipe.ingredients || !currentRecipe.ingredients.length) {
          alert("Add at least one ingredient.");
          return;
        }

        if (editingRecipeId) {
          var idx = recipes.findIndex(function (r) { return r.id === editingRecipeId; });
          if (idx !== -1) {
            recipes[idx] = {
              id: editingRecipeId,
              name: currentRecipe.name,
              servings: currentRecipe.servings,
              ingredients: currentRecipe.ingredients
            };
          }
        } else {
          recipes.push(currentRecipe);
        }

        clearRecipeEditState();
        renderRecipesList();
        saveAppState();
      });

      document.getElementById("generate-shopping-list").addEventListener("click", function () {
        generateShoppingList();
        showPage("page-shopping");
      });

      // initial renders
      renderInventory();
      renderInventoryNameSuggestions();
      renderRecipesList();
      renderMealPlan();
    });

    /* service worker */
    if ("serviceWorker" in navigator) {
      navigator.serviceWorker.register("./sw.js").catch(function () {});
    }
  </script>
</body>
</html>