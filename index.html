<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <meta name="color-scheme" content="dark light">
  <title>Pantry App</title>

  <!-- cache-busted CSS -->
  <link rel="stylesheet" href="styles.css?v=7" />

  <!-- PWA bits -->
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#ff7a00">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <link rel="apple-touch-icon" href="icons/icon-192.png">
</head>
<body>
  <!-- TOP BAR WITH HAMBURGER -->
  <header class="top-bar">
    <button
      id="menu-toggle"
      class="menu-toggle"
      aria-label="Open navigation menu"
      aria-expanded="false"
      aria-controls="app-nav"
    >
      ‚ò∞
    </button>
    <span class="top-bar-title">Pantry App</span>
  </header>

  <!-- HAMBURGER NAV (DROPDOWN) -->
  <!-- HAMBURGER NAV -->
  <nav
    id="app-nav"
    class="app-nav"
    role="tablist"
    aria-label="Pantry navigation"
  >
    <button
      id="nav-inventory"
      role="tab"
      aria-selected="true"
      aria-controls="page-inventory"
      onclick="showPage('page-inventory')"
    >
      Inventory
    </button>

    <button
      id="nav-recipes"
      role="tab"
      aria-selected="false"
      aria-controls="page-recipes"
      onclick="showPage('page-recipes')"
    >
      Recipes
    </button>

    <button
      id="nav-mealplan"
      role="tab"
      aria-selected="false"
      aria-controls="page-mealplan"
      onclick="showPage('page-mealplan')"
    >
      Meal plan
    </button>

    <button
      id="nav-shopping"
      role="tab"
      aria-selected="false"
      aria-controls="page-shopping"
      onclick="showPage('page-shopping')"
    >
      Shopping list
    </button>
  </nav>

  <!-- PAGE 1: INVENTORY -->
  <div id="page-inventory" class="page" role="tabpanel" aria-labelledby="nav-inventory">
    <div class="inventory-controls">
      <label>
        Search inventory
        <input type="text" id="inventory-search" placeholder="Type to filter items..." />
      </label>
    </div>

    <section class="panel">
      <h2>Inventory</h2>

      <!-- Fake barcode scan tools -->
      <div class="barcode-tools">
        <button type="button" id="fake-scan-btn" class="secondary">
          Fake barcode scan
        </button>
      </div>

      <form id="inventory-form">
        <label>
          Item name
          <input type="text" id="inv-name" list="inv-name-list" required />
          <datalist id="inv-name-list"></datalist>
        </label>
        <div class="grid-2">
          <label>
            Quantity
            <input type="number" id="inv-qty" value="1" min="0" step="0.1" required />
          </label>
          <label>
            Unit
            <select id="inv-unit">
              <option value="">(none)</option>
              <option value="g">g</option>
              <option value="kg">kg</option>
              <option value="ml">ml</option>
              <option value="l">l</option>
              <option value="pack">pack</option>
              <option value="packs">packs</option>
              <option value="pcs">pcs</option>
            </select>
          </label>
        </div>
        <div class="form-actions">
          <button type="submit" id="inventory-submit-btn">Add / Update</button>
          <button type="button" id="inventory-cancel-edit" class="secondary hidden">Cancel edit</button>
        </div>
      </form>

      <div id="inventory-list" class="inventory-list"></div>
    </section>
  </div>

  <!-- PAGE 2: RECIPES -->
  <div id="page-recipes" class="page hidden" role="tabpanel" aria-labelledby="nav-recipes">
    <section class="panel">
      <h2>Recipes</h2>

      <form id="recipe-form">
        <label>
          Recipe name
          <input type="text" id="recipe-name" required />
        </label>
        <label>
          Servings (base recipe)
          <input type="number" id="recipe-servings" value="2" min="1" required />
        </label>
        <div class="form-actions">
          <button type="button" id="start-recipe">Start new recipe</button>
          <button type="button" id="cancel-recipe-edit" class="secondary hidden">Cancel edit</button>
        </div>
      </form>

      <div id="recipe-ingredients-section" class="subpanel hidden">
        <h3>Ingredients for current recipe</h3>

        <form id="ingredient-form">
          <label>
            Ingredient name
            <input type="text" id="ing-name" required />
          </label>
          <div class="grid-2">
            <label>
              Quantity
              <input type="number" id="ing-qty" value="1" min="0" step="0.1" required />
            </label>
            <label>
              Unit
              <input type="text" id="ing-unit" placeholder="g, ml, pcs..." />
            </label>
          </div>
          <div class="form-actions">
            <button type="submit" id="ingredient-submit-btn">Add ingredient</button>
            <button type="button" id="cancel-ingredient-edit" class="secondary hidden">
              Cancel ingredient edit
            </button>
          </div>
        </form>

        <ul id="current-recipe-ingredients"></ul>

        <button id="save-recipe">Save recipe</button>

        <div class="subpanel">
          <h3>Quick import from text</h3>
          <p>Paste one ingredient per line, e.g. ‚Äú500g beef mince‚Äù or ‚Äú4 sticks celery, finely chopped (optional)‚Äù.</p>
          <label>
            Ingredients text
            <textarea id="import-text" rows="6" placeholder="Example:
500g beef mince
4 sticks celery, finely chopped (optional)
1 onion, chopped"></textarea>
          </label>
          <button type="button" id="import-ingredients-btn">Import into current recipe</button>
        </div>
      </div>
    </section>

    <section class="panel">
      <h2>Saved recipes</h2>
      <p>Recipes you create here can be used on the Meal plan page.</p>
      <div id="recipes-list"></div>
    </section>
  </div>

  <!-- PAGE 3: MEAL PLAN -->
  <div id="page-mealplan" class="page hidden" role="tabpanel" aria-labelledby="nav-mealplan">
    <section class="panel">
      <h2>Meal plan</h2>
      <p>Select meals for each day and how many portions you‚Äôll cook.</p>
      <div id="meal-plan-container"></div>
      <button id="generate-shopping-list">Generate shopping list</button>
    </section>
  </div>

  <!-- PAGE 4: SHOPPING LIST -->
  <div id="page-shopping" class="page hidden" role="tabpanel" aria-labelledby="nav-shopping">
    <section class="panel">
      <h2>Shopping list</h2>
      <p>This list is based on your weekly meal plan and current inventory.</p>
      <table id="shopping-table">
        <thead>
          <tr>
            <th>‚úì</th>
            <th>Item</th>
            <th>To buy</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </section>
  </div>

  <!-- ================= JS ================= -->
  <script>
    /* ------------ helpers ------------ */
    function titleCase(str) {
      return str
        .toLowerCase()
        .split(" ")
        .filter(Boolean)
        .map(w => w.charAt(0).toUpperCase() + w.slice(1))
        .join(" ");
    }

    function convertToUnit(quantity, fromUnit, toUnit) {
      if (!fromUnit || !toUnit) return quantity;
      if (fromUnit === toUnit) return quantity;
      if (fromUnit === "g" && toUnit === "kg") return quantity / 1000;
      if (fromUnit === "kg" && toUnit === "g") return quantity * 1000;
      if (fromUnit === "ml" && toUnit === "l") return quantity / 1000;
      if (fromUnit === "l" && toUnit === "ml") return quantity * 1000;
      return quantity;
    }

    function normalizeInventoryItem(item) {
      if (item.unit === "g" && item.quantity >= 1000) {
        item.quantity = item.quantity / 1000;
        item.unit = "kg";
      } else if (item.unit === "ml" && item.quantity >= 1000) {
        item.quantity = item.quantity / 1000;
        item.unit = "l";
      }
    }

    function chooseBaseUnit(unit) {
      if (unit === "kg" || unit === "g") return "g";
      if (unit === "l" || unit === "ml") return "ml";
      return unit || "";
    }

    function formatQuantityWithUnit(quantity, unit) {
      if (!unit) return String(quantity);
      const compact = ["g","kg","ml","l"];
      const isCompact = compact.includes(unit);
      const nStr = Number.isInteger(quantity) ? String(quantity) : quantity.toString();
      return isCompact ? nStr + unit : nStr + " " + unit.toLowerCase();
    }

    /* ------------ ingredient parser ------------ */
    function parseIngredientCore(rawText) {
      let line = rawText.trim();
      if (!line) return null;

      const commaIndex = line.indexOf(",");
      if (commaIndex !== -1) line = line.slice(0, commaIndex).trim();
      if (!line) return null;

      const m = line.match(/^(\d+(?:\.\d+)?)([a-zA-Z]+)\/\S+\s+(.+)$/);
      if (m) line = `${m[1]} ${m[2]} ${m[3]}`;

      const parts = line.split(/\s+/);
      if (!parts.length) return null;

      const qty = parseFloat(parts[0]);
      if (isNaN(qty) || qty <= 0) {
        return { name: titleCase(line), quantity: 1, unit: "" };
      }

      const rest = parts.slice(1);
      if (!rest.length) return { name: "", quantity: qty, unit: "" };

      const adjectivesToDrop = [
        "level","heaped","heaping","rounded","about","approx","approximately","roughly"
      ];
      const countUnits = [
        "clove","cloves","stick","sticks","tin","tins","can","cans","slice","slices"
      ];
      const baseUnits = new Set([
        "g","kg","ml","l","tsp","teaspoon","teaspoons","tbsp","tablespoon",
        "tablespoons","cup","cups"
      ];

      const ofIndex = rest.indexOf("of");
      let unitWords = [];
      let nameWords = [];

      if (ofIndex !== -1) {
        unitWords = rest.slice(0, ofIndex);
        nameWords = rest.slice(ofIndex + 1);
      } else {
        const firstLower = rest[0].toLowerCase();
        if (baseUnits.has(firstLower)) {
          unitWords = [rest[0]];
          nameWords = rest.slice(1);
        } else {
          unitWords = rest.slice(0, Math.min(2, rest.length));
          nameWords = rest.slice(unitWords.length);
        }
      }

      unitWords = unitWords.filter(w => !adjectivesToDrop.includes(w.toLowerCase()));

      if (!nameWords.length) {
        if (unitWords.length === 1) {
          const w = unitWords[0];
          return { name: titleCase(w), quantity: qty, unit: "" };
        } else if (unitWords.length >= 2) {
          const first = unitWords[0];
          const last = unitWords[unitWords.length - 1];

          if (countUnits.includes(first.toLowerCase())) {
            const namePart = unitWords.slice(1).join(" ");
            return { name: titleCase(namePart), quantity: qty, unit: first.toLowerCase() };
          }
          if (countUnits.includes(last.toLowerCase())) {
            const namePart = unitWords.slice(0, -1).join(" ");
            return { name: titleCase(namePart), quantity: qty, unit: last.toLowerCase() };
          }
          return { name: titleCase(unitWords.join(" ")), quantity: qty, unit: "" };
        }
      }

      let unit = "";
      if (unitWords.length) {
        const rawUnit = unitWords[unitWords.length - 1].toLowerCase();
        const unitMap = {
          tablespoon: "tbsp", tablespoons: "tbsp", tbsp: "tbsp",
          teaspoon: "tsp", teaspoons: "tsp", tsp: "tsp",
          gram: "g", grams: "g", g: "g", kg: "kg",
          millilitre: "ml", millilitres: "ml", ml: "ml",
          litre: "l", litres: "l", l: "l",
          stick: "stick", sticks: "sticks",
          clove: "clove", cloves: "cloves",
          cup: "cup", cups: "cups"
        };
        unit = unitMap[rawUnit] || rawUnit;
      }

      const name = titleCase(nameWords.join(" "));
      return { name, quantity: qty, unit };
    }

    /* ------------ state ------------ */
    let inventory = [];
    let recipes = [];
    let currentRecipe = null;
    let inventoryFilter = "";
    let editingInventoryKey = null;
    let editingRecipeId = null;
    let editingIngredientIndex = null;
    let mealPlan = [];

    // barcode templates and index
    let barcodeItems = {};  // nameKey -> { name, baseQuantity, unit }
    let barcodeIndex = {};  // barcode -> [nameKey, ...]

    const STORAGE_KEY = "pantryAppState_v1";

    function initDefaultMealPlan() {
      const days = ["Monday","Tuesday","Wednesday","Thursday","Friday","Saturday","Sunday"];
      mealPlan = days.map(day => ({
        dayId: day.toLowerCase(),
        dayLabel: day,
        recipeId: "",
        servings: 0
      }));
    }

    function saveAppState() {
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify({
          inventory,
          recipes,
          mealPlan,
          barcodeItems,
          barcodeIndex
        }));
      } catch (e) {
        console.error("Failed to save", e);
      }
    }

    function loadAppState() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) {
          initDefaultMealPlan();
          barcodeItems = {};
          barcodeIndex = {};
          return;
        }
        const data = JSON.parse(raw);
        if (Array.isArray(data.inventory)) inventory = data.inventory;
        if (Array.isArray(data.recipes)) recipes = data.recipes;
        if (Array.isArray(data.mealPlan)) mealPlan = data.mealPlan; else initDefaultMealPlan();
        barcodeItems = data.barcodeItems || {};
        barcodeIndex = data.barcodeIndex || {};
      } catch {
        initDefaultMealPlan();
        barcodeItems = {};
        barcodeIndex = {};
      }
      if (!mealPlan || !mealPlan.length) initDefaultMealPlan();
    }

    /* ------------ inventory ------------ */
    function upsertInventoryItem(name, quantity, unit) {
      const cleanName = titleCase(name.trim());
      const key = cleanName.toLowerCase();
      let item = inventory.find(i => i.key === key);

      if (!item) {
        item = { key, name: cleanName, quantity, unit };
        normalizeInventoryItem(item);
        inventory.push(item);
        return;
      }

      const baseUnit = item.unit || unit;
      const converted = convertToUnit(quantity, unit, baseUnit);
      if (!item.unit && unit) item.unit = unit;
      item.quantity += converted;
      normalizeInventoryItem(item);
    }

    function setInventoryItemExact(originalKey, name, quantity, unit) {
      const cleanName = titleCase(name.trim());
      const newKey = cleanName.toLowerCase();
      let item = inventory.find(i => i.key === originalKey);

      if (!item) {
        item = { key: newKey, name: cleanName, quantity, unit };
        normalizeInventoryItem(item);
        inventory.push(item);
      } else {
        item.name = cleanName;
        item.key = newKey;
        item.quantity = quantity;
        item.unit = unit;
        normalizeInventoryItem(item);
      }
    }

    function deleteInventoryItem(key) {
      inventory = inventory.filter(i => i.key !== key);
    }

    function renderInventoryNameSuggestions() {
      const datalist = document.getElementById("inv-name-list");
      if (!datalist) return;
      datalist.innerHTML = "";
      inventory
        .slice()
        .sort((a,b) => a.name.localeCompare(b.name))
        .forEach(item => {
          const opt = document.createElement("option");
          opt.value = item.name;
          datalist.appendChild(opt);
        });
    }

    function renderInventory() {
      const container = document.getElementById("inventory-list");
      if (!container) return;
      container.innerHTML = "";

      const filter = inventoryFilter.toLowerCase();

      inventory
        .slice()
        .sort((a,b) => a.name.localeCompare(b.name))
        .forEach(item => {
          if (filter && !item.name.toLowerCase().includes(filter)) return;

          const row = document.createElement("div");
          row.className = "inventory-item";

          const text = document.createElement("span");
          text.className = "inventory-item-text";
          text.textContent =
            `${item.name} - ${formatQuantityWithUnit(item.quantity, item.unit || "")}`;
          row.appendChild(text);

          const actions = document.createElement("div");
          actions.className = "inventory-actions";

          const editBtn = document.createElement("button");
          editBtn.type = "button";
          editBtn.textContent = "‚úé";
          editBtn.title = "Edit";
          editBtn.addEventListener("click", () => startInventoryEdit(item.key));

          const delBtn = document.createElement("button");
          delBtn.type = "button";
          delBtn.textContent = "üóë";
          delBtn.title = "Delete";
          delBtn.addEventListener("click", () => {
            if (confirm(`Delete ${item.name} from inventory?`)) {
              deleteInventoryItem(item.key);
              if (editingInventoryKey === item.key) clearInventoryEditState();
              renderInventory();
              renderInventoryNameSuggestions();
              saveAppState();
            }
          });

          actions.appendChild(editBtn);
          actions.appendChild(delBtn);
          row.appendChild(actions);

          container.appendChild(row);
        });
    }

    function startInventoryEdit(key) {
      const item = inventory.find(i => i.key === key);
      if (!item) return;

      document.getElementById("inv-name").value = item.name;
      document.getElementById("inv-qty").value = item.quantity;
      document.getElementById("inv-unit").value = item.unit || "";

      document.getElementById("inventory-submit-btn").textContent = "Save changes";
      document.getElementById("inventory-cancel-edit").classList.remove("hidden");
      editingInventoryKey = key;
    }

    function clearInventoryEditState() {
      document.getElementById("inv-name").value = "";
      document.getElementById("inv-qty").value = "1";
      document.getElementById("inv-unit").value = "";
      document.getElementById("inventory-submit-btn").textContent = "Add / Update";
      document.getElementById("inventory-cancel-edit").classList.add("hidden");
      editingInventoryKey = null;
    }

    /* ------------ recipes & ingredients ------------ */
    function renderCurrentRecipeIngredients() {
      const ul = document.getElementById("current-recipe-ingredients");
      if (!ul) return;
      ul.innerHTML = "";

      if (!currentRecipe || !Array.isArray(currentRecipe.ingredients)) return;

      currentRecipe.ingredients.forEach((ing, index) => {
        const li = document.createElement("li");

        const textSpan = document.createElement("span");
        textSpan.textContent = `${ing.name}: ${ing.quantity} ${ing.unit}`;
        li.appendChild(textSpan);

        const actionsDiv = document.createElement("div");
        actionsDiv.className = "table-actions";

        const editBtn = document.createElement("button");
        editBtn.type = "button";
        editBtn.className = "secondary";
        editBtn.textContent = "Edit";
        editBtn.addEventListener("click", () => startIngredientEdit(index));

        const delBtn = document.createElement("button");
        delBtn.type = "button";
        delBtn.className = "secondary";
        delBtn.textContent = "Delete";
        delBtn.addEventListener("click", () => {
          currentRecipe.ingredients.splice(index, 1);
          renderCurrentRecipeIngredients();
        });

        actionsDiv.appendChild(editBtn);
        actionsDiv.appendChild(delBtn);
        li.appendChild(actionsDiv);
        ul.appendChild(li);
      });
    }

    function startIngredientEdit(index) {
      if (!currentRecipe || !currentRecipe.ingredients[index]) return;

      const ing = currentRecipe.ingredients[index];
      document.getElementById("ing-name").value = ing.name;
      document.getElementById("ing-qty").value = ing.quantity;
      document.getElementById("ing-unit").value = ing.unit;

      document.getElementById("ingredient-submit-btn").textContent = "Save ingredient";
      document.getElementById("cancel-ingredient-edit").classList.remove("hidden");
      editingIngredientIndex = index;
    }

    function clearIngredientEditState() {
      document.getElementById("ing-name").value = "";
      document.getElementById("ing-qty").value = "1";
      document.getElementById("ing-unit").value = "";
      document.getElementById("ingredient-submit-btn").textContent = "Add ingredient";
      document.getElementById("cancel-ingredient-edit").classList.add("hidden");
      editingIngredientIndex = null;
    }

    function renderRecipesList() {
      const container = document.getElementById("recipes-list");
      if (!container) return;
      container.innerHTML = "";

      if (!recipes.length) {
        container.textContent = "No recipes saved yet.";
        return;
      }

      recipes.forEach(recipe => {
        const wrapper = document.createElement("div");
        wrapper.className = "subpanel";

        const titleRow = document.createElement("div");
        titleRow.className = "recipe-header";

        const title = document.createElement("h3");
        title.textContent = `${recipe.name} (serves ${recipe.servings})`;

        const actionsDiv = document.createElement("div");
        actionsDiv.className = "table-actions";

        const editBtn = document.createElement("button");
        editBtn.type = "button";
        editBtn.className = "secondary";
        editBtn.textContent = "Edit";
        editBtn.addEventListener("click", () => startRecipeEdit(recipe.id));

        const delBtn = document.createElement("button");
        delBtn.type = "button";
        delBtn.className = "secondary";
        delBtn.textContent = "Delete";
        delBtn.addEventListener("click", () => {
          if (confirm(`Delete recipe "${recipe.name}"?`)) {
            deleteRecipe(recipe.id);
            mealPlan.forEach(entry => {
              if (entry.recipeId === recipe.id) {
                entry.recipeId = "";
                entry.servings = 0;
              }
            });
            renderRecipesList();
            renderMealPlan();
            saveAppState();
          }
        });

        actionsDiv.appendChild(editBtn);
        actionsDiv.appendChild(delBtn);

        titleRow.appendChild(title);
        titleRow.appendChild(actionsDiv);
        wrapper.appendChild(titleRow);

        const ul = document.createElement("ul");
        recipe.ingredients.forEach(ing => {
          const li = document.createElement("li");
          li.textContent = `${ing.name}: ${ing.quantity} ${ing.unit}`;
          ul.appendChild(li);
        });
        wrapper.appendChild(ul);

        container.appendChild(wrapper);
      });

      renderMealPlan();
    }

    function deleteRecipe(id) {
      recipes = recipes.filter(r => r.id !== id);
      if (editingRecipeId === id) clearRecipeEditState();
    }

    function startRecipeEdit(id) {
      const recipe = recipes.find(r => r.id === id);
      if (!recipe) return;

      editingRecipeId = id;
      currentRecipe = {
        id: recipe.id,
        name: recipe.name,
        servings: recipe.servings,
        ingredients: recipe.ingredients.map(ing => ({
          name: ing.name,
          quantity: ing.quantity,
          unit: ing.unit
        }))
      };

      document.getElementById("recipe-name").value = currentRecipe.name;
      document.getElementById("recipe-servings").value = currentRecipe.servings;

      document.getElementById("recipe-ingredients-section").classList.remove("hidden");
      document.getElementById("cancel-recipe-edit").classList.remove("hidden");

      renderCurrentRecipeIngredients();
      clearIngredientEditState();
    }

    function clearRecipeEditState() {
      editingRecipeId = null;
      currentRecipe = null;

      document.getElementById("recipe-name").value = "";
      document.getElementById("recipe-servings").value = "2";

      document.getElementById("current-recipe-ingredients").innerHTML = "";
      document.getElementById("recipe-ingredients-section").classList.add("hidden");
      document.getElementById("cancel-recipe-edit").classList.add("hidden");

      clearIngredientEditState();
    }

    /* ------------ meal plan ------------ */
    function initDefaultMealPlanIfNeeded() {
      if (!mealPlan || !mealPlan.length) initDefaultMealPlan();
    }

    function renderMealPlan() {
      const container = document.getElementById("meal-plan-container");
      if (!container) return;
      container.innerHTML = "";

      initDefaultMealPlanIfNeeded();

      const validIds = new Set(recipes.map(r => r.id));
      mealPlan.forEach(entry => {
        if (entry.recipeId && !validIds.has(entry.recipeId)) {
          entry.recipeId = "";
          entry.servings = 0;
        }
      });

      mealPlan.forEach(entry => {
        const row = document.createElement("div");
        row.className = "subpanel";

        const label = document.createElement("h3");
        label.textContent = entry.dayLabel;
        row.appendChild(label);

        const recipeLabel = document.createElement("label");
        recipeLabel.textContent = "Recipe";

        const select = document.createElement("select");
        select.dataset.dayId = entry.dayId;

        const defaultOpt = document.createElement("option");
        defaultOpt.value = "";
        defaultOpt.textContent = "(no meal selected)";
        select.appendChild(defaultOpt);

        recipes
          .slice()
          .sort((a,b) => a.name.localeCompare(b.name))
          .forEach(recipe => {
            const opt = document.createElement("option");
            opt.value = recipe.id;
            opt.textContent = `${recipe.name} (serves ${recipe.servings})`;
            select.appendChild(opt);
          });

        select.value = entry.recipeId || "";

        select.addEventListener("change", e => {
          const id = e.target.dataset.dayId;
          const planEntry = mealPlan.find(p => p.dayId === id);
          if (!planEntry) return;
          planEntry.recipeId = e.target.value;
          if (!planEntry.recipeId) {
            planEntry.servings = 0;
            const sInput = document.querySelector(`input[data-day-id="${id}"]`);
            if (sInput) sInput.value = "0";
          }
          saveAppState();
        });

        recipeLabel.appendChild(select);
        row.appendChild(recipeLabel);

        const servingsLabel = document.createElement("label");
        servingsLabel.textContent = "Planned servings";

        const servingsInput = document.createElement("input");
        servingsInput.type = "number";
        servingsInput.min = "0";
        servingsInput.step = "1";
        servingsInput.dataset.dayId = entry.dayId;
        servingsInput.value = entry.servings && entry.servings > 0 ? entry.servings : "0";

        servingsInput.addEventListener("change", e => {
          const id = e.target.dataset.dayId;
          const planEntry = mealPlan.find(p => p.dayId === id);
          if (!planEntry) return;
          let val = parseFloat(e.target.value || "0");
          if (isNaN(val) || val < 0) val = 0;
          planEntry.servings = val;
          e.target.value = val === 0 ? "0" : String(val);
          saveAppState();
        });

        servingsLabel.appendChild(servingsInput);
        row.appendChild(servingsLabel);

        container.appendChild(row);
      });
    }

    /* ------------ shopping list ------------ */
    function generateShoppingList() {
      const required = {};

      mealPlan.forEach(entry => {
        if (!entry.recipeId) return;
        const plannedServings = parseFloat(entry.servings || "0");
        if (plannedServings <= 0) return;

        const recipe = recipes.find(r => r.id === entry.recipeId);
        if (!recipe) return;

        const scale = plannedServings / recipe.servings;

        recipe.ingredients.forEach(ing => {
          const key = ing.name.toLowerCase();
          const ingUnit = ing.unit || "";
          const baseUnit = required[key]
            ? required[key].baseUnit
            : chooseBaseUnit(ingUnit);

          if (!required[key]) {
            required[key] = {
              name: ing.name,
              quantityBase: 0,
              baseUnit
            };
          }

          const qtyScaled = ing.quantity * scale;
          const qtyInBase = convertToUnit(qtyScaled, ingUnit, required[key].baseUnit);
          required[key].quantityBase += qtyInBase;
        });
      });

      const tbody = document.querySelector("#shopping-table tbody");
      if (!tbody) return;
      tbody.innerHTML = "";

      Object.keys(required).forEach(key => {
        const need = required[key];
        const baseUnit = need.baseUnit;
        let requiredBase = need.quantityBase;

        let invQtyBase = 0;
        const invItem = inventory.find(i => i.name.toLowerCase() === key);
        if (invItem && baseUnit) {
          invQtyBase = convertToUnit(invItem.quantity, invItem.unit || "", baseUnit);
        } else if (invItem && !baseUnit) {
          invQtyBase = invItem.quantity;
        }

        let toBuyBase = Math.max(0, requiredBase - invQtyBase);
        if (toBuyBase <= 1e-9) return;

        let displayUnit = baseUnit;
        if (baseUnit === "g" && (requiredBase >= 1000 || invQtyBase >= 1000 || toBuyBase >= 1000)) {
          displayUnit = "kg";
        } else if (baseUnit === "ml" && (requiredBase >= 1000 || invQtyBase >= 1000 || toBuyBase >= 1000)) {
          displayUnit = "l";
        }

        let displayQtyNumeric;
        if (displayUnit) {
          displayQtyNumeric = convertToUnit(toBuyBase, baseUnit, displayUnit);
        } else {
          displayQtyNumeric = toBuyBase;
        }
        displayQtyNumeric = Math.round(displayQtyNumeric * 100) / 100;

        const compactUnits = ["g","kg","ml","l"];
        const isCompact = displayUnit && compactUnits.includes(displayUnit);

        let qtyStr;
        if (!displayUnit) {
          qtyStr = displayQtyNumeric.toString();
        } else if (isCompact) {
          const nStr = Number.isInteger(displayQtyNumeric)
            ? String(displayQtyNumeric)
            : displayQtyNumeric.toFixed(2);
          qtyStr = nStr + displayUnit;
        } else {
          const nStr = Number.isInteger(displayQtyNumeric)
            ? String(displayQtyNumeric)
            : displayQtyNumeric.toFixed(2);
          qtyStr = nStr + " " + displayUnit.toLowerCase();
        }

        const tr = document.createElement("tr");
        tr.dataset.itemName = need.name;
        tr.dataset.buyQty = String(displayQtyNumeric);
        tr.dataset.buyUnit = displayUnit || "";

        const tdCheck = document.createElement("td");
        const cb = document.createElement("input");
        cb.type = "checkbox";
        cb.className = "shopping-bought";
        tdCheck.appendChild(cb);

        const tdName = document.createElement("td");
        tdName.textContent = need.name;

        const tdBuy = document.createElement("td");
        tdBuy.textContent = qtyStr;

        tr.appendChild(tdCheck);
        tr.appendChild(tdName);
        tr.appendChild(tdBuy);
        tbody.appendChild(tr);
      });

      const checkboxes = tbody.querySelectorAll(".shopping-bought");
      checkboxes.forEach(cb => {
        cb.addEventListener("change", () => {
          const tr = cb.closest("tr");
          if (!tr) return;
          if (!cb.checked || tr.dataset.applied === "true") return;

          const name = tr.dataset.itemName;
          const qty = parseFloat(tr.dataset.buyQty || "0");
          const unit = tr.dataset.buyUnit || "";
          if (!name || !qty || qty <= 0) return;

          upsertInventoryItem(name, qty, unit);
          tr.dataset.applied = "true";

          renderInventory();
          renderInventoryNameSuggestions();
          saveAppState();
        });
      });
    }

    /* ------------ fake barcode scan logic ------------ */

    function ensureBarcodeArray(barcode) {
      if (!barcodeIndex[barcode]) barcodeIndex[barcode] = [];
      return barcodeIndex[barcode];
    }

    function handleExistingBarcode(barcode, mappings) {
      if (!mappings.length) return false;

      // single mapping
      if (mappings.length === 1) {
        const nameKey = mappings[0];
        const tpl = barcodeItems[nameKey];
        if (!tpl) return false;

        const confirmMsg =
          "This barcode is currently linked to:\n\n" +
          tpl.name +
          (tpl.baseQuantity ? " (typical amount: " + tpl.baseQuantity + (tpl.unit || "") + ")" : "") +
          "\n\nIs that correct?";

        const isCorrect = confirm(confirmMsg);
        if (!isCorrect) {
          // treat as new item for this barcode
          return false;
        }

        const unit = tpl.unit || "";
        const defaultVal = (tpl.baseQuantity && tpl.baseQuantity > 0)
          ? String(tpl.baseQuantity)
          : "1";
        const unitText = unit ? " in " + unit : "";
        const qtyMsg =
          tpl.name + " already in list - how much did you buy?" +
          "\n\n" +
          (tpl.baseQuantity
            ? "Typical amount: " + tpl.baseQuantity + (unit || "") + ".\n"
            : "") +
          "Enter the total amount" + unitText + ":";

        const qtyStr = prompt(qtyMsg, defaultVal);
        if (!qtyStr) return true;
        const qty = parseFloat(qtyStr);
        if (isNaN(qty) || qty <= 0) return true;

        upsertInventoryItem(tpl.name, qty, unit);
        renderInventory();
        renderInventoryNameSuggestions();
        saveAppState();
        alert("Added " + formatQuantityWithUnit(qty, unit) + " of " + tpl.name + " to inventory.");
        return true;
      }

      // multiple mappings ‚Äì user chooses which item, or 0 for new
      let msg = "This barcode is linked to multiple items:\n\n";
      mappings.forEach((nameKey, idx) => {
        const tpl2 = barcodeItems[nameKey];
        if (!tpl2) return;
        msg +=
          (idx + 1) + ". " + tpl2.name +
          (tpl2.baseQuantity ? " (" + tpl2.baseQuantity + (tpl2.unit || "") + " typical)" : "") +
          "\n";
      });
      msg += "\nEnter the number of the correct item,\n" +
             "or 0 if it's a different item:";

      const choiceStr = prompt(msg, "");
      if (!choiceStr) return false;
      const choice = parseInt(choiceStr, 10);
      if (isNaN(choice) || choice < 1 || choice > mappings.length) {
        // user chose 0 or invalid ‚Üí treat as new item
        return false;
      }

      const pickedNameKey = mappings[choice - 1];
      const tpl3 = barcodeItems[pickedNameKey];
      if (!tpl3) return true;

      const unit3 = tpl3.unit || "";
      const defaultVal3 = (tpl3.baseQuantity && tpl3.baseQuantity > 0)
        ? String(tpl3.baseQuantity)
        : "1";
      const unitText3 = unit3 ? " in " + unit3 : "";
      const qtyMsg3 =
        tpl3.name + " already in list - how much did you buy?" +
        "\n\n" +
        (tpl3.baseQuantity
          ? "Typical amount: " + tpl3.baseQuantity + (unit3 || "") + ".\n"
          : "") +
        "Enter the total amount" + unitText3 + ":";

      const qtyStr3 = prompt(qtyMsg3, defaultVal3);
      if (!qtyStr3) return true;
      const qty3 = parseFloat(qtyStr3);
      if (isNaN(qty3) || qty3 <= 0) return true;

      upsertInventoryItem(tpl3.name, qty3, unit3);
      renderInventory();
      renderInventoryNameSuggestions();
      saveAppState();
      alert("Added " + formatQuantityWithUnit(qty3, unit3) + " of " + tpl3.name + " to inventory.");
      return true;
    }

    function handleNewBarcodeOrNewItem(barcode) {
      let name = prompt("What is this item called?", "");
      if (!name) {
        alert("Cancelled.");
        return;
      }
      const cleanName = titleCase(name.trim());
      const nameKey = cleanName.toLowerCase();

      const existingTpl = barcodeItems[nameKey];

      // barcode for an item we already know (e.g. Beef Mince from before)
      if (existingTpl) {
        const arr = ensureBarcodeArray(barcode);
        if (!arr.includes(nameKey)) arr.push(nameKey);

        const unit = existingTpl.unit || "";
        const defaultVal = (existingTpl.baseQuantity && existingTpl.baseQuantity > 0)
          ? String(existingTpl.baseQuantity)
          : "1";
        const unitText = unit ? " in " + unit : "";
        const msg =
          cleanName + " is already defined in your pantry.\n" +
          (existingTpl.baseQuantity
            ? "Typical amount: " + existingTpl.baseQuantity + (unit || "") + ".\n"
            : "") +
          "How much did you buy" + unitText + "?";

        const qtyStr = prompt(msg, defaultVal);
        if (!qtyStr) {
          saveAppState();
          return;
        }
        const qty = parseFloat(qtyStr);
        if (isNaN(qty) || qty <= 0) {
          saveAppState();
          return;
        }

        upsertInventoryItem(cleanName, qty, unit);
        renderInventory();
        renderInventoryNameSuggestions();
        saveAppState();
        alert("Added " + formatQuantityWithUnit(qty, unit) + " of " + cleanName + " to inventory.");
        return;
      }

      // brand new item template
      const qtyStr2 = prompt(
        'For one typical amount of "' + cleanName + '", what is the quantity?\n' +
        'Example: for a 500g pack, enter 500.',
        "500"
      );
      if (!qtyStr2) {
        alert("Cancelled.");
        return;
      }
      const baseQty = parseFloat(qtyStr2);
      if (isNaN(baseQty) || baseQty <= 0) {
        alert("Invalid quantity. Cancelled.");
        return;
      }

      const unitStr = prompt(
        "What is the unit for this quantity?\n" +
        "Examples: g, kg, ml, l, pack, packs, pcs",
        "g"
      );
      const unit2 = (unitStr || "").trim();

      barcodeItems[nameKey] = {
        name: cleanName,
        baseQuantity: baseQty,
        unit: unit2
      };

      const arr2 = ensureBarcodeArray(barcode);
      if (!arr2.includes(nameKey)) arr2.push(nameKey);

      const unitText2 = unit2 ? " in " + unit2 : "";
      const msgNow =
        "Saved " + cleanName + " as a typical amount of " + baseQty + (unit2 || "") + ".\n\n" +
        "How much did you buy right now" + unitText2 + "?\n" +
        "Example: if you bought one pack, enter " + baseQty + ".";

      const qtyNowStr = prompt(msgNow, String(baseQty));
      if (!qtyNowStr) {
        saveAppState();
        return;
      }
      const qtyNow = parseFloat(qtyNowStr);
      if (isNaN(qtyNow) || qtyNow <= 0) {
        saveAppState();
        return;
      }

      upsertInventoryItem(cleanName, qtyNow, unit2);
      renderInventory();
      renderInventoryNameSuggestions();
      saveAppState();
      alert("Added " + formatQuantityWithUnit(qtyNow, unit2) + " of " + cleanName + " to inventory.");
    }

    function fakeBarcodeScanFlow() {
      let code = prompt("Fake barcode scan: enter a barcode number or code.", "");
      if (!code) return;
      code = String(code).trim();
      if (!code) return;

      const mappings = barcodeIndex[code] || [];

      // if we have mappings, try to handle them first
      if (mappings.length) {
        const handled = handleExistingBarcode(code, mappings);
        if (handled) return;
        // otherwise fall through to "new item" flow
      }

      handleNewBarcodeOrNewItem(code);
    }

    /* ------------ navigation ------------ */
    function showPage(pageId) {
      const pages = [
        document.getElementById("page-inventory"),
        document.getElementById("page-recipes"),
        document.getElementById("page-mealplan"),
        document.getElementById("page-shopping")
      ];
      const navButtons = [
        document.getElementById("nav-inventory"),
        document.getElementById("nav-recipes"),
        document.getElementById("nav-mealplan"),
        document.getElementById("nav-shopping")
      ];

      pages.forEach(page => {
        if (!page) return;
        page.classList.toggle("hidden", page.id !== pageId);
      });

      navButtons.forEach(btn => {
        if (!btn) return;
        const controls = btn.getAttribute("aria-controls");
        btn.setAttribute("aria-selected", controls === pageId ? "true" : "false");
      });

      // Close the hamburger menu after navigation (mobile)
      const appNav = document.getElementById("app-nav");
      const menuToggle = document.getElementById("menu-toggle");
      if (appNav && menuToggle) {
        appNav.classList.remove("open");
        menuToggle.setAttribute("aria-expanded", "false");
      }

      // Keep focus behaviour as simple as possible (optional)
      const page = document.getElementById(pageId);
      if (page) {
        const h2 = page.querySelector("h2");
        if (h2) {
          h2.setAttribute("tabindex", "-1");
          h2.focus();
        }
      }
    }

    /* ------------ DOMContentLoaded ------------ */
    document.addEventListener("DOMContentLoaded", () => {
      loadAppState();

      // hamburger toggle
      const menuToggle = document.getElementById("menu-toggle");
      const appNav = document.getElementById("app-nav");
      if (menuToggle && appNav) {
        menuToggle.addEventListener("click", () => {
          const isOpen = appNav.classList.toggle("open");
          menuToggle.setAttribute("aria-expanded", isOpen ? "true" : "false");
        });
      }

      document.getElementById("nav-inventory").addEventListener("click", () => showPage("page-inventory"));
      document.getElementById("nav-recipes").addEventListener("click", () => showPage("page-recipes"));
      document.getElementById("nav-mealplan").addEventListener("click", () => showPage("page-mealplan"));
      document.getElementById("nav-shopping").addEventListener("click", () => showPage("page-shopping"));
      showPage("page-inventory");

      const invForm = document.getElementById("inventory-form");
      const searchInput = document.getElementById("inventory-search");
      const cancelInvEditBtn = document.getElementById("inventory-cancel-edit");
      const fakeScanBtn = document.getElementById("fake-scan-btn");

      invForm.addEventListener("submit", e => {
        e.preventDefault();

        const name = document.getElementById("inv-name").value.trim();
        const qty = parseFloat(document.getElementById("inv-qty").value || "0");
        const unit = (document.getElementById("inv-unit").value || "").trim();

        if (!name || qty <= 0) {
          alert("Please enter a valid name and quantity.");
          return;
        }

        if (editingInventoryKey) {
          setInventoryItemExact(editingInventoryKey, name, qty, unit);
          clearInventoryEditState();
        } else {
          upsertInventoryItem(name, qty, unit);
          document.getElementById("inv-name").value = "";
          document.getElementById("inv-qty").value = "1";
          document.getElementById("inv-unit").value = "";
        }

        renderInventory();
        renderInventoryNameSuggestions();
        saveAppState();
      });

      cancelInvEditBtn.addEventListener("click", () => {
        clearInventoryEditState();
      });

      searchInput.addEventListener("input", () => {
        inventoryFilter = searchInput.value || "";
        renderInventory();
      });

      fakeScanBtn.addEventListener("click", () => {
        fakeBarcodeScanFlow();
      });

      /* recipes: start recipe, ingredient add/import, save, etc. */
      const startRecipeBtn = document.getElementById("start-recipe");
      const ingSection = document.getElementById("recipe-ingredients-section");
      const cancelRecipeEditBtn = document.getElementById("cancel-recipe-edit");
      const importBtn = document.getElementById("import-ingredients-btn");

      startRecipeBtn.addEventListener("click", () => {
        const name = document.getElementById("recipe-name").value.trim();
        const servings = parseFloat(document.getElementById("recipe-servings").value || "0");

        if (!name || servings <= 0) {
          alert("Please enter a recipe name and servings.");
          return;
        }

        if (!currentRecipe || !editingRecipeId) {
          currentRecipe = {
            id: editingRecipeId || String(Date.now()),
            name: titleCase(name),
            servings,
            ingredients: []
          };
        } else {
          currentRecipe.name = titleCase(name);
          currentRecipe.servings = servings;
        }

        ingSection.classList.remove("hidden");
        renderCurrentRecipeIngredients();
        if (editingRecipeId) {
          cancelRecipeEditBtn.classList.remove("hidden");
        } else {
          cancelRecipeEditBtn.classList.add("hidden");
        }
        clearIngredientEditState();
      });

      cancelRecipeEditBtn.addEventListener("click", () => {
        clearRecipeEditState();
      });

      const ingForm = document.getElementById("ingredient-form");
      ingForm.addEventListener("submit", e => {
        e.preventDefault();
        if (!currentRecipe) {
          alert("Start a recipe first.");
          return;
        }

        const name = document.getElementById("ing-name").value.trim();
        const qty = parseFloat(document.getElementById("ing-qty").value || "0");
        const unit = document.getElementById("ing-unit").value.trim();

        if (!name || qty <= 0) {
          alert("Please enter a valid ingredient name and quantity.");
          return;
        }

        const cleanName = titleCase(name);

        if (editingIngredientIndex !== null) {
          currentRecipe.ingredients[editingIngredientIndex] = {
            name: cleanName,
            quantity: qty,
            unit
          };
          clearIngredientEditState();
        } else {
          currentRecipe.ingredients.push({
            name: cleanName,
            quantity: qty,
            unit
          });
        }

        renderCurrentRecipeIngredients();
      });

      document.getElementById("cancel-ingredient-edit").addEventListener("click", () => {
        clearIngredientEditState();
      });

      importBtn.addEventListener("click", () => {
        if (!currentRecipe) {
          alert("Start a recipe first (enter name + servings, then click 'Start new recipe').");
          return;
        }

        const textarea = document.getElementById("import-text");
        const raw = textarea.value || "";
        const lines = raw.split(/\r?\n/);

        let requiredIngredients = [];
        let optionalGroups = [];
        let skipped = 0;

        lines.forEach(lineRaw => {
          let originalLine = lineRaw.trim();
          if (!originalLine) { skipped++; return; }

          const isOptional = /\boptional\b/i.test(originalLine);
          let working = originalLine.replace(/\([^)]*\)/g, "").trim();
          if (!working) { skipped++; return; }

          if (isOptional && /\s+or\s+/i.test(working)) {
            const parts = working.split(/\s+or\s+/i);
            const options = [];
            parts.forEach(p => {
              const parsed = parseIngredientCore(p.trim());
              if (parsed && parsed.name && parsed.quantity > 0) options.push(parsed);
            });
            if (options.length > 0) optionalGroups.push({ originalLine, options });
            else skipped++;
          } else {
            const parsed = parseIngredientCore(working);
            if (!parsed || !parsed.name || parsed.quantity <= 0) { skipped++; return; }
            if (isOptional) optionalGroups.push({ originalLine, options: [parsed] });
            else requiredIngredients.push(parsed);
          }
        });

        requiredIngredients.forEach(ing => {
          currentRecipe.ingredients.push(ing);
        });

        if (!optionalGroups.length) {
          renderCurrentRecipeIngredients();
          if (requiredIngredients.length || skipped) {
            alert(`${requiredIngredients.length} ingredient(s) imported, ${skipped} line(s) skipped or empty.`);
          } else {
            alert("No valid ingredients found to import.");
          }
          if (requiredIngredients.length) textarea.value = "";
          return;
        }

        const overlay = document.createElement("div");
        overlay.className = "optional-overlay";

        const modal = document.createElement("div");
        modal.className = "optional-modal";

        const heading = document.createElement("h3");
        heading.textContent = "Optional ingredients";
        modal.appendChild(heading);

        const desc = document.createElement("p");
        desc.textContent = 'Tick any optional ingredients you want to include, then press "Add selected".';
        modal.appendChild(desc);

        const form = document.createElement("form");
        form.addEventListener("submit", e => e.preventDefault());

        optionalGroups.forEach((group, gIndex) => {
          const fs = document.createElement("fieldset");

          const legend = document.createElement("legend");
          legend.textContent = `From: "${group.originalLine}"`;
          fs.appendChild(legend);

          group.options.forEach((opt, oIndex) => {
            const lbl = document.createElement("label");
            const cb = document.createElement("input");
            cb.type = "checkbox";
            cb.dataset.groupIndex = String(gIndex);
            cb.dataset.optionIndex = String(oIndex);

            const text = document.createTextNode(
              ` ${opt.name}: ${opt.quantity} ${opt.unit}`.trim()
            );

            lbl.appendChild(cb);
            lbl.appendChild(text);
            fs.appendChild(lbl);
          });

          form.appendChild(fs);
        });

        const buttonsDiv = document.createElement("div");
        buttonsDiv.className = "optional-buttons";

        const cancelBtn = document.createElement("button");
        cancelBtn.type = "button";
        cancelBtn.className = "secondary";
        cancelBtn.textContent = "Skip all optional";
        cancelBtn.addEventListener("click", () => {
          document.body.removeChild(overlay);
          renderCurrentRecipeIngredients();
          const baseMsg = `${requiredIngredients.length} required ingredient(s) imported.`;
          const skipMsg = optionalGroups.length ? ` ${optionalGroups.length} optional group(s) skipped.` : "";
          const skipLinesMsg = skipped ? ` ${skipped} line(s) skipped or empty.` : "";
          alert(baseMsg + skipMsg + skipLinesMsg);
          if (requiredIngredients.length) textarea.value = "";
        });

        const addBtn = document.createElement("button");
        addBtn.type = "button";
        addBtn.textContent = "Add selected";
        addBtn.addEventListener("click", () => {
          const checkboxes = form.querySelectorAll('input[type="checkbox"][data-group-index]');
          let addedOptional = 0;
          checkboxes.forEach(cb => {
            if (cb.checked) {
              const g = parseInt(cb.dataset.groupIndex, 10);
              const o = parseInt(cb.dataset.optionIndex, 10);
              const opt = optionalGroups[g]?.options[o];
              if (opt) {
                currentRecipe.ingredients.push({
                  name: opt.name,
                  quantity: opt.quantity,
                  unit: opt.unit
                });
                addedOptional++;
              }
            }
          });

          document.body.removeChild(overlay);
          renderCurrentRecipeIngredients();

          let msg = `${requiredIngredients.length} required ingredient(s) imported.`;
          msg += ` ${addedOptional} optional ingredient(s) added.`;
          if (skipped) msg += ` ${skipped} line(s) skipped or empty.`;
          alert(msg);

          if (requiredIngredients.length || addedOptional) textarea.value = "";
        });

        buttonsDiv.appendChild(cancelBtn);
        buttonsDiv.appendChild(addBtn);
        form.appendChild(buttonsDiv);
        modal.appendChild(form);
        overlay.appendChild(modal);
        document.body.appendChild(overlay);
      });

      document.getElementById("save-recipe").addEventListener("click", () => {
        if (!currentRecipe) {
          alert("No recipe in progress.");
          return;
        }
        if (!currentRecipe.ingredients || !currentRecipe.ingredients.length) {
          alert("Add at least one ingredient.");
          return;
        }

        if (editingRecipeId) {
          const idx = recipes.findIndex(r => r.id === editingRecipeId);
          if (idx !== -1) {
            recipes[idx] = {
              id: editingRecipeId,
              name: currentRecipe.name,
              servings: currentRecipe.servings,
              ingredients: currentRecipe.ingredients
            };
          }
        } else {
          recipes.push(currentRecipe);
        }

        clearRecipeEditState();
        renderRecipesList();
        saveAppState();
      });

      document.getElementById("generate-shopping-list").addEventListener("click", () => {
        generateShoppingList();
        showPage("page-shopping");
      });

      // initial renders
      renderInventory();
      renderInventoryNameSuggestions();
      renderRecipesList();
      renderMealPlan();
    });

    /* service worker */
    if ("serviceWorker" in navigator) {
      navigator.serviceWorker.register("./sw.js").catch(() => {});
    }
       /* ---------- SIMPLE NAV CONTROLLER (ensures nav buttons work) ---------- */
   window.addEventListener("load", () => {
     const pages = Array.from(document.querySelectorAll(".page"));
     const navButtons = Array.from(document.querySelectorAll(".app-nav button"));

     function navShowPage(pageId) {
       // show / hide pages
       pages.forEach(p => {
         if (!p) return;
         p.classList.toggle("hidden", p.id !== pageId);
       });

       // highlight active nav button
       navButtons.forEach(btn => {
         if (!btn) return;
         const controls = btn.getAttribute("aria-controls");
         btn.setAttribute("aria-selected", controls === pageId ? "true" : "false");
       });
     }

     // expose globally so inline onclick="showPage('page-xyz')" also works
     window.showPage = navShowPage;

     // attach click handlers for all nav buttons
     navButtons.forEach(btn => {
       btn.addEventListener("click", () => {
         const target = btn.getAttribute("aria-controls");
         if (target) navShowPage(target);
       });
     });

     // default page on load
     navShowPage("page-inventory");
   });
  </script>
      </script>

    <!-- Tiny navigation fixer: makes the top buttons switch pages -->
    <script>
      window.addEventListener('DOMContentLoaded', function () {
        const pages = Array.from(document.querySelectorAll('.page'));
        const navButtons = Array.from(document.querySelectorAll('.app-nav button'));

        function setActivePage(pageId) {
          // show/hide pages
          pages.forEach(function (page) {
            if (!page) return;
            page.classList.toggle('hidden', page.id !== pageId);
          });

          // highlight active nav button
          navButtons.forEach(function (btn) {
            if (!btn) return;
            const controls = btn.getAttribute('aria-controls');
            btn.setAttribute('aria-selected', controls === pageId ? 'true' : 'false');
          });
        }

        // expose globally so any existing code or inline handlers can call it
        window.showPage = setActivePage;

        // click handlers for the nav buttons
        navButtons.forEach(function (btn) {
          btn.addEventListener('click', function () {
            const target = btn.getAttribute('aria-controls');
            if (target) setActivePage(target);
          });
        });

        // default page on load
        setActivePage('page-inventory');
      });
    </script>
  </body>
</html>
